{"pages":[{"title":"About","date":"2022-09-23T10:58:11.388Z","path":"about/index.html","text":""},{"title":"Categories","date":"2022-09-23T10:58:11.426Z","path":"categories/index.html","text":""},{"title":"Schedules","date":"2022-09-23T10:58:11.433Z","path":"schedules/index.html","text":"조건 및 방식할일 정렬 방식: 공부 -&gt; 하고싶은 일 순서 (마지막의 일은 제한시간 없음) 할 일 조건 생상적이거나 의미있는 일이여함 내부, 외부에 방해요소가 있어선 안됨 일단 컨트롤 할 수 있는 것들은 미리 해결 만약, 방해요소가 있고 그것이 컨트롤 할 수 없는 것(특히나 재미가 없는 일)이라면 그것부터 해결 컨트롤할 수 없지만, 재미가 있다면 그냥 하면 된다. 할 일의 2가지 방법 방해요소를 0으로 만들고 일하기 컨트롤 가능한 방해요소와 함께 일하기 개인 일정은 퇴근 하자마자 작성하기 11.13(금) 일일 커밋 어플 API - 컴포넌트간 데이터 바인딩 11.10 (화) - 11.12(목)회사 일정으로 개인일정 없음 11.9 (월) 일일 커밋 어플 Github API 오브젝트 및 리듀서 연결 11.8 (일) 일일 커밋 어플 오늘 커밋 여부 API 및 UI 컴포넌트 구현 첫 커밋 내용 API 및 UI 컴포넌트 구현 전체 커밋 상황 Analystic API 및 컴포넌트 구현 설정 - 푸쉬 알림 및 세부 설정(간격, 특정 시간) 위젯 로그아웃 쿠버네티스 인 액션 3장 요약정리 11.7 (토) 일일 커밋 어플 Github AccessToken 취득 후, 유저명 가져오기 기획 내용 수정: 커밋 히스토리 추가 React-native Debugger 환경 개선 (네트워크 디버깅) 추후, Live Style Editor가능한지 찾아보기 평가: Redux-saga를 적용한 작업 구조에 익숙해짐. 언제 날잡고 다시한번 바닥부터 템플릿 작성하여 이해도를 더 높일 필요가 있어보임. 11.6 (금) 일일 커밋 어플 Redux-thunk -&gt; Redux-saga 적용 평가: 회사 일정 바쁜 날… 11.5 (목)평가: 개인 일정 없던 날 11.4 일일 커밋 어플 - Redux, React-native Typescript환경에 맞춰 설정 createAsyncAction() 과 redux-thunk 환경 설정 (진행 중) Udemy k8s Practice Test - Statefulsets 쿠버네티스 인 액션 책 요약 - 1장 쿠버네티스 소개 평가: 컨디션 조절이 필요한 시기, 의욕과 일의 효율에 대한 것에 대해 생각해보자 11.3 일일 커밋 어플 - Redux, React-native Typescript환경에 맞춰 설정 개발 규모에 비하여, 상태 관리 라이브러리의 필요가 전혀 없지만, 학습을 위하여 템플릿 구성 Reducer safetype-actions를 이용한 액션 처리 createAsyncAction() 과 redux-thunk 환경 설정 (진행 중) 일일 커밋 어플 - RxJs 설정 - Udemy k8s demo 시청 Udemy k8s Practice Test - Pods 10.30 - 11.2PC 문제로 미작성 10.29개인 일정 없음 10.28 일일 커밋 React-native Redux + Typescript 템플릿 만들기 Redux + Rxjs 템플릿 적용 Udemy 강의 요약 (k8s) 약속으로 인한 일정 축약 책 원고 챕터 하나 작성 함수형 프로그래밍 1챕터 요약 시간 나면, 리액트 1days 요약 10.27 일일 커밋 어플 라우터 구현 및 UI 구현 Udemy 강의 요약 (k8s) 책 원고 챕터 하나 작성 함수형 프로그래밍 1챕터 요약 시간 나면, 리액트 1days 요약 평가: Redux와 Mobx, 그리고 Rxjs에 대한 생각을 다시 가지게된 시간. 한번 시간을 내어 정리할 필요가 있어보임 10.26 일일 커밋 어플 깃허브 로그인 연결 검토 (안되면, userId 검색 방식으로 변경) Expo 에서 지원하는 것을 사용 일일 커밋 어플 UI 구현 Udemy 강의 요약 (k8s) 책 원고 챕터 하나 작성 함수형 프로그래밍 1챕터 요약 시간 나면, 리액트 1days 요약 평가: 리액트 네이티브에 대한 깊이를 늘었지만, 다른 학습과 같이 진행하지 못했다. 어느 정도 진행 이후, 학습을 먼저하고 프로젝트를 뒤로 빼야할 듯… 10.23 ~ 10.25휴가 (대학 동기) 10.22 일일 커밋 어플 UI 구현 7시간 소모 (리액트 네이티브 개발) C++ 3챕터 정리 및 연습문제 풀이 2챕터 간단하게만 정리 + 3챕터 하루 하나 Udemy K8s 강의 듣기 이해했는지 알아보기 위해, 쿠버네티스 공식 페이지를 참고하여 정리 React days에 관해서는 직접 실습해보고, 이후 학습에 대한 내용 적는게 올바른 순서로 보임 책 원고 꾸준히 쓰기 평가: 리액트 네이티브에 대해서 시간 투자를 많이 한 날, 재미는 있었지만 결과값이 그렇게 좋지 않았음, 그런 이유로는 목표로 개발하려는 내용을 공식적으로 제공하는 문서와 라이브러리가 없어서 그것을 스스로 개발하려고 했지만 아직 리액트 네이티브 및 모바일 개발에 대한 숙련도가 낮아서 시간 대비 효율이 좋지 못했다. 10.21 C++ 2챕터 정리 및 연습문제 풀이 하루 하나 Udemy K8s 강의 듣기 일일 커밋 어플 기획 React days에 관해서는 직접 실습해보고, 이후 학습에 대한 내용 적는게 올바른 순서로 보임 Typescript 13장 정리 (마지막 장 - 이후 장은 타입스크립트에 관한 부분이 아니므로 생략) 책 원고 꾸준히 쓰기 평가: udemy 강의를 들으면서, k8s 개발을 하면서 궁금했던 아키텍처나 그 외 개념들에 대해서 자세하게 아는 시간을 가짐 앞으로 꾸준히 들어봐야 알 듯. 10.20 Typescript 13장 정리 일일 커밋 어플 손대보기 React days에 관해서는 직접 실습해보고, 이후 학습에 대한 내용 적는게 올바른 순서로 보임 C++의 경우도 마찬가지 책 원고 꾸준히 쓰기 평가: 회사 일정으로 할게 제법 있어서, 개인 일정을 소화하지 못한 날 10.19 Typescript 12장 정리 C++ 2챕터 정리 연습문제 블로그 정리 - 템플릿 짜기 React 1days 정리 일일커밋 어플 만들기 (~ 2days) 평가: React, C++ 정독은 하였으나, 문서 정리를 어떤 방식으로 해야할지 고민 단계, 블로그 정리가 아닌 깃허브에 정리하는게 좋아보이기도함 10.18 Typescript 11장 정리 (제네릭) C++ 2챕터 정리 연습문제 블로그 정리 - 템플릿 짜기 React 1days 정리 블로그에 개인일정 올릴 수 있게 가능한가 보기 이 md파일을 올리면 되는거 아니야? 그렇다면 about 탭 하나 만들고, 이름만 수정하면 될 것 같음 일일커밋 어플 만들기 (~ 2days) 평가: 개인 주말에 학습 의욕을 내기는 생각보다 힘든 일이며, 의욕을 더 높이기 위한 방법을 더 강구해 봐야할 것 같다. 10.17 Typescript 11장 정리 (제네릭) 오후 6 - 9시 C++ 2챕터 정리 연습문제 블로그 정리 - 템플릿 짜기 9 - 11시 React 1days 정리 11 - 1시 일일커밋 어플 만들기 (~ 2days) 자유 평가: 주말 친구들과 시간을 보냄, 나쁘지 않은 하루였다. 대신 내일 빡세게 살아야겠는 걸… 10.16회사 일정으로 인하여, 개인 일정 없음 10.15 C++ 2챕터 정리 연습문제 블로그 정리 - 템플릿 짜기 React 1days 정리 React native 1 days 훑어보기 Typescript 10장 정리 (타입 선언과 변경, 그리고 호환) 평가: 사람의 집중력은 한도가 있고, 하루에 그것은 한정되있으므로 그것을 어디다 적절히 분배할지 생각하는 습관이 필요해보임"},{"title":"Tags","date":"2022-09-23T10:58:11.433Z","path":"tags/index.html","text":""},{"title":"HTTP 완벽 가이드 1장","date":"2022-09-17T06:45:20.000Z","path":"presentation/HTTP_완벽_가이드/1장/index.html","text":"ul, ol, p { font-size: 0.75rem; } img[alt~=\"center\"] { display: block; margin: 0 auto; } header { color: #fff; font-size: 0.75rem; } footer { font-size: 0.75rem; } ol li { list-style-type: decimal; } .mermaid, .mermaid * { overflow: visible; font-size: initial; text-align: center; } .mermaid > svg { max-height: 45vh; } /* two-colums */ div.twocols { margin-top: 35px; /* pdf */ /* margin-top: 250px; */ column-count: 2; } div.threecols { margin-top: 35px; /* pdf */ /* margin-top: 250px; */ column-count: 3; } div.twocols p:first-child, div.twocols h1:first-child, div.twocols h2:first-child, div.twocols ul:first-child, div.twocols ul li:first-child, div.twocols ul li p:first-child { margin-top: 0 !important; } div.twocols p.break { break-before: column; margin-top: 0; } HTTP 완벽 가이드 1장: HTTP 개관 목차마다 무엇을 알아야하는지 정리 1장 키워드들 HTTP 웹 리소스 MIME 타입 URI, URL, URN HTTP 메시지 Request(시작줄, 헤더, 본문) Response(상태줄, 헤더, 본문) 메서드, 상태코드 TCP 커넥션 프로토콜 버전 웹 구성요소 프록시, 캐시, 게이트웨이, 터널, 에이전트 HTTP에 대해서 대략적으로 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. HTTP(HyperText Transfer Protocol) = 하이퍼미디어 문서를 전송하기위한 애플리케이션 레이어 프로토콜, 서버와 클라이언트 사이간의 메시지 통신 규약 웹 브라우저와 웹 서버간의 커뮤니케이션을위해 디자인되었지만, 다른 목적으로도 사용가능 HTTP는 클라이언트가 요청을 생성하기 위한 연결을 연다음 응답을 받을때 까지 대기하는 전통적인 클라이언트-서버 모델을 따름 ‘웹 리소스’에 대해서 대략적으로 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. 웹 리소스 = HTTP 요청 대상 리소스의 특성은 더 이상 정의되지 않음(어떤 컨텐츠 등 가능) 정적 리소스(ex. text, html, word, pdf 등) 동적 리소스(ex. 게이트웨이)도 포함 ‘MIME 타입’에 대해서 대략적으로 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. MIME(Multipurpose Internet Mail Extensions) = 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘 웹에서 파일의 확장자는 별 의미가 없음 각 문서와 함께 올바른 MIME 타입을 전송하도록, 서버가 정확히 설정하는 것이 중요 브라우저들은 리소스를 내려받았을 때 해야 할 기본 동작이 무엇인지를 결정하기 위해 사용 주 타입(Prmiary object type)/부 타입(Specific subtype)으로 구성 ex. text/html, image/jpeg, audio/mpeg, video/mpeg, application/pdf MIME 타입 전체 목록은 📝부록D 혹은 MIME 전체목록 MDN를 참고 MIME 타입은 대소문자를 구분하지는 않지만 전통적으로 소문자로 쓰여짐 ‘URI’, ‘URL’, ‘URN’에 대해서 관하여 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. URI(Uniform Resource Identifier) = 하나의 리소스를 가리키는 문자열 가장 흔한 URI는 URL로, 웹 상에서의 위치로 리소스를 식별 식별(URI)과 위치(URL)의 차이라고 보면 되지 않을까 싶네요…MDN문서에서도 굳이 이 차이에 대해서 설명하지 않고 있어, 이 부분은 생략하겠습니다. URN은 주어진 이름공간 안의 이름으로 리소스를 식별 ex urn:isbn:0451450523 책에서는 아직 널리 채택되지않은 기술이라고 언급하고 있지만, 현재는 rfc3986에서 확인한 결과 INTERNET STANDARD 상태이다. 주소가 바뀌는 것과 상관없이 사용할 수 있는 것이 특성 HTTP 메시지 구성 및 방식에 대해서 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. 클라이언트와 서버는 HTTP 메시지를 주고받음 HTTP 메시지 = HTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식 메시지 타입은 두 가지 요청(request) = 클라이언트가 서버로 전달해서 서버의 액션이 일어나게끔 하는 메시지 응답(response) = 요청에 대한 서버의 답변 HTTP 요청 HTTP 요청은 시작줄, 헤더, 본문으로 구성 시작줄(start-line) 첫번째로 오는 것은 HTTP 메서드로, 영어 동사(GET, PUT,POST) 혹은 명사(HEAD, OPTIONS)를 사용해 서버가 수행해야 할 동작 표시 두번째로 오는 요청 타겟은 주로 URL origin 형식: 끝에 &#39;?&#39;와 쿼리 문자열이 붙는 절대 경로 ex. GET /background.png HTTP/1.0 absolute 형식: 완전한 URL 형식 프록시에 연결하는 경우 대부분 GET과 함께 사용 ex. GET http://developer.mozilla.org/ HTTP/1.1 … authority 형식: 도메인 이름 및 옵션 포트(‘:’가 앞에 붙음)로 이루어진 URL의 authority component HTTP 터널을 구축하는 경우에만 CONNECT와 함께 사용 ex. CONNECT developer.mozilla.org:80 HTTP/1.1 asterisk 형식: OPTIONS와 함께 별표(‘*’) 하나로 간단하게 서버 전체를 표시 ex. OPTIONS * HTTP/1.1 마지막으로 ​​​​HTTP 버전을 표시 ex. HTTP/1.1 헤더(header) 요청에 들어가는 HTTP 헤더는 HTTP 헤더의 기본 구조를 따름 대소문자 구분없는 문자열 다음에 콜론(‘:’)이 붙음 다양한 종류의 요청 헤더 General 헤더: Via와 같은 헤더는 메시지 전체에 적용 Request 헤더: User-Agent 또는 Accept와 같은 헤더 Representation 헤더: Content-Type와 같은 헤더 본문(body) 모든 요청에 본문이 들어가지는 않음 GET, HEAD, DELETE , OPTIONS 리소스를 가져오는 요청은 보통 본문이 필요없음 넓게 보면 본문은 두가지 종류 단일-리소스 본문(single-resource bodies): 헤더 두 개(Content-Type와 Content-Length)로 정의된 단일 파일로 구성 다중-리소스 본문(multiple-resource bodies): 멀티파트 본문으로 구성되는 다중 리소스 본문에서는 파트마다 다른 정보를 지니게 됩니다. 보통 HTML 폼과 관련 다중 리소스 참고블로그 HTTP 응답상태줄(Status Line) HTTP 응답의 시작 줄은 상태 줄(status line)이라고 불림 프로토콜 버전: ex. HTTP/1.1 상태 코드: 요청의 성공 여부 상태 텍스트: 짧고 간결하게 상태 코드에 대한 설명을 글로 나타내어 사람들이 HTTP 메시지를 이해할 때 도움 HTTP 2부터는 사유 구절(reason phrase)이 제거됨 ex. HTTP/1.1 404 Not Found 시작줄과 다른 점은 요청타겟 대신 상태코드가 3자리 숫자로 구성되어 표시 (전체목록 참조) 1xx: 정보 응답 2xx: 성공 3xx: 리다이렉션 4xx: 클라이언트 오류 5xx: 서버 오류 헤더(header): Request Header와 동일본문(body) 모든 응답에 본문이 들어가지는 않음( 201, 204과 같은 상태 코드를 가진 응답에는 보통 본문이 없음) 넓게 3가지 종류로 구분 이미 길이가 알려진 단일 파일로 구성된 단일-리소스 본문: 헤더 두개(Content-Type와 Content-Length)로 정의 길이를 모르는 단일 파일로 구성된 단일-리소스 본문: Transfer-Encoding가 chunked로 설정되어 있으며, 파일은 청크로 나뉘어 인코딩 서로 다른 정보를 담고 있는 멀티파트로 이루어진 다중 리소스 본문 책 내용 외 추가작성. chrome 개발자도구에서는 HTTP Raw Message를 확인할 수 없다. 그렇다면 어떻게 확인할 수 있을까? 네트워크 패널에서 확인하고 싶은 요청의 curl을 복사(copy) 터미널을 열고 nc -l 8080(임의포트) 실행(요즘은 telnet대신 nc를 사용하는 추세) Netcat(ornc)은 TCP 또는 UDP 프로토콜을 사용하여 네트워크 연결을 통해 데이터를 읽고 쓰는 명령줄 유틸리티 일반적으로 상대 서버의 포트가 열렸는지 확인하거나, 직접 서버가 되어 원격 서버에서(클라이언트) 접속이 가능하지 확인하는 용도로 사용 복사한 curl을 붙여넣기(paste)하고 --raw -i 옵션을 추가하여 실행 nc가 실행된 터미널에서 HTTP 메시지 확인 가능 HTTP 어플리케이션 계층과 TCP 데이터 전송 계층을 이해했다면 이 섹션을 건너뛰어도 좋습니다. HTTP는 애플리케이션 계층 프로토콜로 네트워크 통신 핵심적인 세부적인 사항에 대해서 처리를 하지는 않음 대신 대중적이고 신뢰성 있는 TCP/IP에게 그 역할을 맡김 이 책에서 설명하는 TCP 특징 오류 없는 데이터 전송(신뢰성) 언제나 보낸 순서대로 도착 언제든 어떤 크기로든 보낼 수 있음 HTTP 프로토콜 5계층 HTTP (어플리케이션 계층) TCP (전송 계층) IP (네트워크 계층) Ethernet (네트워크 인터페이스 계층) 물리 계층 네트워크를 설명할 때 넘어갈 수 없는 것이 OSI 7계층, OSI 자체는 현재 사용되진 않지만 참조 모델로 주로 사용 1계층 물리 계층: 전기적, 기계적, 기능적인 특성을 이용해 데이터를 전송 2계층 데이터 링크 계층: 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리 3계층 네트워크 계층: 네트워크 통신 경로 선택 4계층 전송 계층: 네트워크 통신 관리 5계층 세션 계층: 통신 시작과 종료 순서 6계층 표현 계층: 데이터의 표현 방법을 정의 7계층 응용 계층: 사용자의 요구를 만족시키는 응용 서비스를 제공 TCP/IP를 설명할 때는 보통 4계층으로 묶어서 설명애플리케이션(5-7계층), 전송(4계층)네트워크(3계층), 링크 계층(1-2계층) HTTP 버전간의 차이를 설명할 수 있다면 이 장을 생략 HTTP 초기 버전에는 버전 번호가 없었음 0.9부터 버전 관리를 시작 HTTP/0.9 – 원-라인 프로토콜 요청은 단일 라인으로 구성 가능한 메서드는 GET이 유일 HTTP 헤더가 없었는데 이는 HTML 파일만 전송될 수 있으며 다른 유형의 문서는 전송될 수 없음을 의미 문제가 발생한 경우, 특정 HTML 파일이 사람이 처리할 수 있도록, 해당 파일 내부에 문제에 대한 설명과 함께 되돌려 보내짐 HTTP/1.0 – 확장성 만들기 - RFC 1945에 공개 버전 정보가 각 요청 사이내로 전송 ex. GET HTTP/1.0 상태 코드 라인 또한 응답의 시작 부분에 붙어 전송 (브라우저가 요청에 대한 성공과 실패를 알 수 있음) HTTP 헤더 개념은 요청과 응답 모두를 위해 도입 일반적인 요청 예시 1234567891011GET &#x2F;mypage.html HTTP&#x2F;1.0User-Agent: NCSA_Mosaic&#x2F;2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:31 GMTServer: CERN&#x2F;3.0 libwww&#x2F;2.17Content-Type: text&#x2F;html&lt;HTML&gt;A page with an image &lt;IMG SRC&#x3D;&quot;&#x2F;myimage.gif&quot;&gt;&lt;&#x2F;HTML&gt; HTTP/1.1 – 표준 프로토콜 현재 가장 널리 사용되는 HTTP 버전 커넥션이 재사용 가능 (keep-alive: Three-shake 오버헤드를 줄임) 파이프라이닝을 추가(첫번째 요청에 대한 응답이 완전히 전송되기 이전에 두번째 요청 전송을 가능케 하여, 커뮤니케이션 레이턴시를 낮춤) 청크된 응답 또한 지원 추가적인 캐시 제어 메커니즘이 도입 캐시 제어 메커니즘에 대한 내용은 이곳에서 확인 가능 언어, 인코딩 혹은 타입을 포함한 컨텐츠 협상이 도입 Host 헤더 덕분에, 동일 IP 주소에 다른 도메인을 호스트하는 기능이 서버 collocation을 가능 HTTP/2 – 더 나은 성능을 위한 프로토콜 텍스트 프로토콜이라기 보다는 이진 프로토콜 (더 이상 읽을 수도 없고 수작업을 만들어낼 수 없음) 병렬 요청이 동일한 커넥션 상에서 다루어질 수 있는 다중화 프로토콜(순서를 제거해주고 HTTP/1.x 프로토콜의 제약사항을 막음) 전송된 데이터의 분명한 중복과 그런 데이터로부터 유발된 불필요한 오버헤드를 제거(연속된 요청 사이의 매우 유사한 내용으로 존재하는 헤더들을 압축) 서버로 하여금 사전에 클라이언트 캐시를 서버 푸쉬라고 불리는 메커니즘, 필요한 데이터 채우기 허용 HTTP2 사용현황 - 2022. 09 기준 44% 사용 프록시, 캐시, 게이트웨이, 터널, 에이전트에 대해서 설명할 수 있다면 이 섹션을 건너뛰어도 좋습니다. 프록시 클라이언트와 서버 사이에 위치하여 클라이언트의 요청을 받아 서버에 전달하고, 서버의 응답을 받아 클라이언트에 전달하는 역할을 하는 중간 서버 웹 보안, 어플리케이션 통합, 성능 최적화 등의 목적으로 사용 일반적으로 크게 주로 2가지 종류의 프록시 서버가 존재 포워드 프록시(forward proxy)는 인터넷 상에서 어디로든지 리퀘스트를 전송해주는 프록시 주로 캐싱, IP 우회 , 접근 제한 등 으로 사용 리버스 프록시(reverse proxy)는 인터넷에서 리퀘스트를 받으면, 내부망 내의 서버로 전송 주로 로드밸런싱, 보안 등 으로 사용 vpn과 forward proxy의 차이?개인 생각으로는 데이터 암호화로, forward proxy가 vpn을 포함하는 더 큰 범주라고 생각 캐시 웹 캐시와 캐시 프록시는 자신을 거쳐 가는 리소스 중 자주 찾는 것의 사본을 저장하는 특별한 HTTP 프록시 라고 책에서 설명되고 있음 (7장에서 더 자세하게 설명) 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 더 빨리 문서를 받을 수 있음(웹 캐시는 레이턴시와 네트워크 트래픽을 줄여줌) 캐시 큰 종류는 설(private) 혹은 공유(shared) 캐시 두 가지 부류로 분류 공유 캐시는 한 명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시 사설 캐시는 한 명의 사용자만 사용하는 캐시 그 외 게이트웨이 캐시, CDN, 리버스 프록시 캐시 그리고 로드 밸랜서 등이 있지만 현재 장에서 생략 브라우저 캐시(Private Cache) 사설 캐시는 단일 사용자가 전용으로 사용 사용자에 의하여 HTTP를 통해 다운로드된 모든 문서들을 가지고 있음 서버에 대한 추가적인 요청 없이 뒤로 가기나 앞으로 가기, 저장, 소스로 보기 등을 위해 방문했던 문서들을 사용 프록시 캐시(Shared Cache) 공유 캐시는 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시 회사의 ISP는 많은 사용자들을 서비스하기 위해 지역 네트워크 기반의 일부분으로서 웹 프록시를 설치가 가능 덕분에 조회가 많이 되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 레이턴시를 줄여줌 위 내용 제어를 원한다면 cache-control 헤더를 사용 12Cache-Control: private # 단일 사용자만을 위한 것이며 공유 캐시에 의해 저장되어서는 안됨Cache-Control: public # 응답이 어떤 캐시에 의해서든 캐시되어도 좋음 게이트웨이 다른 서버들의 중개자로 동작하는 특별한 서버 책에서는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기위해 사용된다고 설명 (ex. HTTP/FTP) 게이트웨이와 프록시에 대한 차이는 모호하긴 하지만, 목적에 대한 차이가 있음 게이트웨이는 서로 다른 서버를 연결해주는데 주 목적 (보통 2개 이상의 서버) 프록시는 필터링, 보안, 최적화에 등 목적을 갖고 다른 사이트를 대신하며 우회하는데 주 목적 (보통 1개의 서버) HTTP 터널 터널은 두 커넥션 사이에서 raw 데이터를 그대로 전달해주는 HTTP 애플리케이션 예시로 HTTP/SSL 터널링이 있음 에이전트 HTTP 요청을 만들어주는 클라이언트 프로그램(보통 웹 브라우저), 추가로 자동화 스파이더, 웹로봇이 존재 (9장 설명)"},{"title":"아키텍처 변천사","date":"2022-09-19T15:00:00.000Z","path":"presentation/아키텍처/아키텍처_흐름/index.html","text":"mermaid.initialize({ startOnLoad: window.clientInformation.userAgent.includes(`Electron`) ? true : false, flowchart: { useMaxWidth: true, htmlLabels: true, curve: 'cardinal' }, securityLevel:'loose' }); // 버그픽스: mermaid window.target = document.querySelector(\"#p\"); window.observer = new MutationObserver(function(mutations) { mutations.some(function(mutation) { if (mutation.target.classList.contains(`bespoke-marp-active`) && mutation.target.querySelector(`.mermaid`)) { window.mermaid.init(undefined,document.querySelectorAll(\".mermaid\")); return true; } }); }); window.config = { attributes: true, childList: true, subtree: true || null, }; window.observer.observe(target, config); ul, ol, p { font-size: 0.75rem; } img[alt~=\"center\"] { display: block; margin: 0 auto; } header { color: #fff; font-size: 0.75rem; } footer { font-size: 0.75rem; } ol li { list-style-type: decimal; } .mermaid, .mermaid * { overflow: visible; font-size: initial; text-align: center; } .mermaid > svg { max-height: 45vh; } /* two-colums */ div.twocols { margin-top: 35px; /* pdf */ /* margin-top: 250px; */ column-count: 2; } div.threecols { margin-top: 35px; /* pdf */ /* margin-top: 250px; */ column-count: 3; } div.twocols p:first-child, div.twocols h1:first-child, div.twocols h2:first-child, div.twocols ul:first-child, div.twocols ul li:first-child, div.twocols ul li p:first-child { margin-top: 0 !important; } div.twocols p.break { break-before: column; margin-top: 0; } 아키텍처 변천사 아무렇게나 코드를 던져두면 필요할 때마다 찾기가 힘듦 그래서 개발자들은 비슷한 코드를 모아 서로 이해할 수 있게 분류하기로 결정(아키텍처 = 모두가 이해하고 따를 수 있도록 하는 구조) 그런데 개발의 시간이 흐르면서 분류 방식에 대한 논쟁 및 트렌드 변경으로 각 아키텍처에 대한 차이를 알고 이해하기 위해 글을 작성 flowchart LR view --> model controller --> model controller -->|data| view 화살표의 방향은 의존성을 의미 (ex. view는 model을 알고, model은 view를 모름) 기존 mvc의 약점으로 지적된 사항들 view 가 model을 알고 있는 것의 문제 model = 비즈니스 로직(businness domain)이기 때문에 변동성이 잦음 (화면 표시에 대한 이유와는 다른 변동성) 변화에 대한 이유가 다른데 의존성을 가지고 있음 model과 view의 관계가 너무 강한 것이 주로 이야기됨 ex. Java Spring (서버에서는 view -&gt; model 의존성이 없기 때문에 적합) 구성 Controller: 사용자의 요청사항을 데이터를 Model에 전달하고, 데이터를 View에 반영 Model: 데이터를 주관하는 영역, 데이터를 다루는 로직을 모델에 모아두어 view와 격리 View: 화면상에 출력되는 내용, 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너 flowchart LR view --> controller model --> controller controller --> model controller -->|data| view 모든 것을 controller가 관리하는 형태 기존 위의 mvc의 view -&gt; model에 대한 의존성이 사라졌지만, controller의 역할이 커짐 view와 model이 조금만 변경되도 controller까지 변경이 필요함 (유지보수 및 개발 공수가 큼) flowchart LR view[view - getter,setter ] --> presenter model --> presenter presenter --> model presenter -->|data| view presenter가 view 컴포넌트의 getter, setter를 통해 접근 native dom이 아닌 인터페이스로 취급 (model을 주지 않아 로직이 없음) 모든 기능에 1:1 대응되는 getter, setter 작성 필요 ex. MFC, Android, visual basic 12345678910111213141516171819202122232425262728293031323334353637var PhotoView = Backbone.View.extend(&#123; //... is a list tag. tagName: &quot;li&quot;, // Pass the contents of the photo template through a templating // function, cache it for a single photo template: _.template( $(&quot;#photo-template&quot;).html() ), // The DOM events specific to an item. events: &#123; &quot;click img&quot; : &quot;toggleViewed&quot; &#125;, // The PhotoView listens for changes to // its model, re-rendering. Since tHere&#x27;s // a one-to-one correspondence between a // **Photo** and a **PhotoView** in this // app, we set a direct reference on the model for convenience. initialize: function() &#123; this.model.on( &quot;change&quot;, this.render, this ); this.model.on( &quot;destroy&quot;, this.remove, this ); &#125;, // Re-render the photo entry render: function() &#123; $( this.el ).html( this.template(this.model.toJSON() )); return this; &#125;, // Toggle the `&quot;viewed&quot;` state of the model. toggleViewed: function() &#123; this.model.viewed(); &#125;&#125;); flowchart LR binder --> view binder -->|observe| view-model view-model --> model model --> view-model view-model = view를 대신하는 순수한 데이터 구조체 view-model에 변경이 감지됬을 때, view가 자동으로 갱신, 혹은 view에서 이벤트가 발생했을 때 view-model을 변경 view-model은 view에 대한 존재를 몰라야함 Binder 보통은 아래 2가지 방식이 고려됨, 서로 장단점이 있음 - 참고 flowchart LR scanner --> binder scanner --> Dom binder -->|observe| view-model view-model --> model model --> view-model DOM 스캔 방식 (angular, svelte): Binder에서 Scanner 분리 model과 view 분리 쉬움 DOM에 대한 의존성이 크기 때문에 scanner를 분리 (binder를 보호하기 위함) 변화율(변동에 대한 시간)에 따라 분리 자체 DOM([vdom)을 소유 (react) Component 방식(model과 view가 같이 관리 - setState) TodoMVC Learning JavaScript Design Patterns 프론트엔드 아키텍처 트렌드 프론트엔드에서-MV-아키텍쳐 생활코딩 MVC 객체지향 JS Android MVP Proxy와 가상 돔을 사용하여 나만의 프레임워크 만들기 JavaScript Proxy. 근데 이제 Reflect를 곁들인 프레임워크별 DOM렌더링 전략 Book: 프레임워크 없는 프론트엔드 개발 - VanillaJS로 프레임워크의 원리 구현"},{"title":"TIL 10월 11일 (월)","date":"2022-09-23T10:58:11.429Z","path":"presentation/TIL/2021/10/11/index.html","text":"ul, ol, p { font-size: 0.75rem; } img[alt~=\"center\"] { display: block; margin: 0 auto; } header { color: #fff; } table { font-size: 0.6rem; } pre > code { color: initial; } h1 { font-size: 1.2rem; } h2 { font-size: 1rem; } h3 { font-size: 0.8rem; } h4 { font-size: 0.6rem; } h5 { font-size: 0.4rem; } TIL: 10월 11일 (월) h2, h3 { /* display: flex; justify-content: center; align-items: center; */ text-align: center; line-height: 0.8rem; color: #000; } h2 { font-size: 1.8rem; } h3 { font-size: 1.2rem; } strong { color: #fff; } p { color: #fff; } K8S Ingress section { display: flex; align-items: center; justify-content: center; } h3 { font-size: 1rem; } 참고 자료: https://arisu1000.tistory.com/27840 인그레스 정의인그레스(ingress)는 클러스터 외부에서 내부로 접근하는 요청들을 어떻게 처리할지 정의해둔 규칙들의 모음 할 수 있는 것들 외부에서 접근가능한 URL을 사용할 수 있게 함 트래픽 로드밸런싱 SSL 인증서 처리 도메인 기반으로 가상 호스팅을 제공 이런 규칙들을 실제로 동작하게 해주는게 인그레스 컨트롤러(ingress controller) 클라우드 서비스는 별다른 설정없이 자사의 로드밸런서 서비스들과 연동해서 인그레스를 사용 직접 쿠버네티스 클러스터를 구축해서 사용하는 경우라면 인그레스 컨트롤러를 직접 인그레스와 연동 이때 가장 많이 사용되는건 쿠버네티스에서 제공하는 ingress-nginx(https://github.com/kubernetes/ingress-nginx) YAML 예제foo.bar.com으로 요청이 들어오더라도 뒷부분의 경로에 따라 /foos1이면 서비스 s1으로 연결되고 /bars2이면 서비스 s2쪽으로 연결 12345678910111213141516171819202122232425apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: test annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: rules: - host: foo.bar.com http: paths: - path: /foos1 backend: serviceName: s1 servicePort: 80 - path: /bars2 backend: serviceName: s2 servicePort: 80 - host: bar.foo.com http: paths: - backend: serviceName: s2 servicePort: 80 pre { font-size: 0.5rem; } Cert-manager section { display: flex; align-items: center; justify-content: center; } h3 { font-size: 1rem; } 설명 cert-manager는 k8s에서 자동으로 TLS 인증서를 갱신해주는 쿠버네티스 에드온 kube lego 프로젝트에 기초 유사 프로젝트로 kube-cert-manager가 존재 외부 Issuers를 사용하거나 self-signed 방식으로 자동 갱신 openssl로 안하고 이걸 사용하는 이유는 인증서 자동 갱신 및 관리? 설치cert-manager 네임스페이스를 사용 1kubectl apply -f https:&#x2F;&#x2F;github.com&#x2F;jetstack&#x2F;cert-manager&#x2F;releases&#x2F;download&#x2F;v1.5.4&#x2F;cert-manager.yaml 설치 확인12345678910111213141516171819[root@stg-accordion1 twkang] k get all -n cert-manager NAME READY STATUS RESTARTS AGEpod/cert-manager-7c6f78c46d-t9j4r 1/1 Running 0 100spod/cert-manager-cainjector-668d9c86df-lwhzv 1/1 Running 0 100spod/cert-manager-webhook-979688b46-zffvw 1/1 Running 0 100sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/cert-manager ClusterIP 10.98.36.159 &lt;none&gt; 9402/TCP 101sservice/cert-manager-webhook ClusterIP 10.102.126.21 &lt;none&gt; 443/TCP 101sNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/cert-manager 1/1 1 1 101sdeployment.apps/cert-manager-cainjector 1/1 1 1 101sdeployment.apps/cert-manager-webhook 1/1 1 1 101sNAME DESIRED CURRENT READY AGEreplicaset.apps/cert-manager-7c6f78c46d 1 1 1 101sreplicaset.apps/cert-manager-cainjector-668d9c86df 1 1 1 101sreplicaset.apps/cert-manager-webhook-979688b46 1 1 1 101s Cert-manager는 기본적으로 외부 Issuer(let’s enscypt)가 아닌,Cluster 내부에서 사용할 수 있는 자체적으로 서명된 self-signed issuer를 생성 Issuer 뜻 = CA라고 칭하는 서명할 수 있는 주체를 지칭, Certificate(인증서)를 생성할 수 있는 발급기관 cluster 내부에서 사용하거나 테스트 용도로 사용하는 것이라면 self-signed 인증서를 사용하는 것도 좋은 방법 시스템 구성도 cert-manager를 이용해서 클러스터 전역에서 사용할 수 있는 Cluster Issuer를 생성 해당 Issuer를 이용해서 각각의 Namespace 별로 Certificate를 생성 클러스터/네임스페이스 스코프별로 ClusterIssuer, Issuer 리소스 따로 존재 Usage Issuer 생성 123456apiVersion: cert-manager.io/v1kind: ClusterIssuermetadata: name: selfsigned-issuerspec: selfSigned: &#123;&#125; 결과 123[root@stg-accordion1 twkang] k get clusterissuers.cert-manager.io -ANAME READY AGEselfsigned-issuer True 4s Certificate 생성 생성된 ClusterIssuer를 사용해서 self-signed Certificate를 생성 해당 Certificate는 속해있는 Namespace 내의 모든 서비스가 사용할 수 있는 인증서가 됨 해당 인증서가 생성됨과 동시에 Certificate는 Kubernetes내에서 사용할 수 있도록 Public key, Secret key와 같은 데이터를 가진 secret 리소스가 생성 아래 yaml을 apply 하면 certificate와 secret 리소스가 함께 생성 (v1 기준으로 작성: v1beta1은 yaml 스펙이 다름) 123456789101112131415161718192021222324apiVersion: cert-manager.io/v1kind: Certificatemetadata: name: selfsigned-cert namespace: &lt;네임스페이스명&gt;spec: secretName: selfsigned-cert-tls # Certificate와 동시에 함께 생성되는 secret의 이름 duration: 2880h # 120d, 인증서의 유효기간 renewBefore: 360h # 15d, 자동으로 인증서를 갱신할 때를 지정 commonName: example.com # host name, dnsName 옵션과 함게 사용가능 # commonName이 설정되지 않았을 경우에는 dnsName의 가장 첫번째 값을 commonName이 기본값 isCA: false # CA서명이 유효하도록 하는 옵션 privateKey: algorithm: RSA encoding: PKCS1 size: 2048 usages: # 참고 https://cert-manager.io/docs/reference/api-docs/#cert-manager.io/v1alpha2.KeyUsage - digital signature - key encipherment - server auth issuerRef: name: selfsigned-issuer kind: ClusterIssuer group: cert-manager.io pre { font-size: 0.6rem; } 결과 123[root@stg-accordion1 twkang] k get certificate -n docs selfsigned-cert NAME READY SECRET AGEselfsigned-cert True selfsigned-cert-tls 9s 생성되는 secret 데이터 확인 ca.crt: public certificate file tls.crt: Public Key tls.key: Private Key 123[root@stg-accordion1 twkang] k get secrets -n docs NAME TYPE DATA AGEselfsigned-cert-tls kubernetes.io/tls 3 10m 생성된 TLS Secret을 Ingress에 적용 123456789101112131415161718192021222324apiVersion: networking.k8s.io/v1kind: Ingressmetadata: annotations: # 1. add an annotation indicating the issuer to use. cert-manager.io/cluster-issuer: selfsigned-issuer name: myIngress namespace: myIngressspec: rules: - host: example.com http: paths: - pathType: Prefix path: / backend: service: name: myservice port: number: 80 tls: # &lt; 2. placing a host in the TLS config will determine what ends up in the cert&#x27;s subjectAltNames - hosts: - example.com secretName: selfsigned-cert-tls # &lt; 3. cert-manager will store the created certificate in this secret."},{"title":"Helm 사용자 시나리오","date":"2022-09-23T10:58:11.430Z","path":"presentation/TIL/2021/11/20/index.html","text":"ul, ol, p { font-size: 0.75rem; } img[alt~=\"center\"] { display: block; margin: 0 auto; } header { color: #fff; line-height: 0%; } table { font-size: 0.6rem; } pre > code { color: initial; } h1 { font-size: 1.2rem; } h2 { font-size: 1rem; } h3 { font-size: 0.8rem; } h4 { font-size: 0.6rem; } h5 { font-size: 0.4rem; } section { background-size: 108% !important; } Helm 사용해보기 h2, h3 { /* display: flex; justify-content: center; align-items: center; */ text-align: center; line-height: 0.8rem; color: #000; } h2 { font-size: 1.8rem; } h3 { font-size: 1.2rem; } strong { color: #fff; } Helm이란 Usage. Helm Chart 생성 Usage. Helm Chart 삭제 Usage. values.yaml으로 템플릿 문법 사용 Usage. Release 템플릿 문법 사용 Usage. 그 외 Helm 자주 사용하는 명령어 Usage. values.yaml override Usage. Helm Chart 업그레이드 Usage. Helm Rollback 비유를 한다면 개발자가 Docker Registry에서 검색하여 쉽게 이미 셋팅된 컨테이너 환경을 실행하듯이Helm에서 검색하여 이미 셋팅된 쿠버네티스 환경을 실행한다라고 이해하면 되지 않을 듯 싶다.ex. Dockerhub처럼 ArtifactHub에서 많은 템플릿이 등록되고 공유되고 있다. 컨테이너 환경을 Dockerfile로 구성 하는 것처럼 Helm도 차트로 구성을 한다. 차트 = 쿠버네티스 YAML을 템플릿으로 구성한 파일들 Helm Chart를 생성하기 위해서는 위에서 설명한 구조의 파일들을 생성할 필요가 있음 nginx 템플릿을 단계별로 구성하여 따라해보기 /templates 폴더 생성하여 배포할 쿠버네티스 YAML 작성 deployment, service YAML은 뒤에 작성 1234.└── templates ├── deployment.yaml └── service.yaml deployment.yaml123456789101112131415161718192021apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-test labels: app: nginx-testspec: replicas: 1 selector: matchLabels: app: nginx-test template: metadata: labels: app: nginx-test spec: containers: - name: nginx image: nginx:latest ports: - containerPort: 80 service.yaml1234567891011apiVersion: v1kind: Servicemetadata: name: nginx-testspec: selector: app: nginx-test ports: - port: 80 targetPort: 80 type: ClusterIP Chart.yaml 작성 Chart.yaml = Helm 차트의 이름, 버전 등 메타데이터를 입력하는 파일 123apiVersion: v2 # 차트 API 버전 (필수)name: nginx-test # 차트명 (필수)version: 0.0.1 # SemVer 2 버전 (필수) 현재 파일 구성 12345.├── Chart.yaml└── templates ├── deployment.yaml └── service.yaml values.yaml 작성 values.yaml = /templates 내부에 쿠버네티스 YAML에 있는 값을 동적으로 지정할 때 사용하는 파일 일단은 파일이 비어있는 상태로도 설치가 가능하기 때문에 파일만 생성1touch values.yaml 123456.├── Chart.yaml├── templates│ ├── deployment.yaml│ └── service.yaml└── values.yaml Helm Chart 설치 1helm install &lt;이름&gt; &lt;차트_경로&gt; -n &lt;네임스페이스&gt; 실행 결과 12345678# helm install nginx-test . -n testNAME: nginx-testLAST DEPLOYED: Sun Nov 21 05:41:08 2021NAMESPACE: testSTATUS: deployedREVISION: 1 # helm upgrade 반영 횟수TEST SUITE: None Helm 조회 123# helm ls -n testNAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSIONnginx-test test 1 2021-11-21 05:41:08.564944731 +0900 KST deployed nginx-test-0.0.1 실제 쿠버네티스 배포현황 확인 123456# k get deploy,svc -n testNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/nginx-test 1/1 1 1 4m3sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/nginx-test ClusterIP 10.100.29.142 &lt;none&gt; 80/TCP 4m3s 차트 삭제1helm delete &lt;릴리즈된_차트명&gt; -n &lt;네임스페이스&gt; 실행 결과 123# helm delete nginx-test -n testrelease &quot;nginx-test&quot; uninstalled 이후, helm ls -n test 명령어 실행시 차트가 삭제된 것을 확인할 수 있음 p13.에서 “values.yaml = /templates 내부에 쿠버네티스 YAML에 있는 값을 동적으로 지정할 때 사용하는 파일” 라고 이야기된 단계에 관한 설명 위 과정을 하기 위해서는 템플릿 문법을 사용해야함 예시로 /templates 내에 deployment.yaml에서 이미지 버전이 현재 latest로 되어있는 것을 외부에서 바꿀 수 있게 변경을 진행 /templates/*.yaml 수정 1234567... spec: containers: - name: nginx image: nginx:&#123;&#123; .Values.version &#125;&#125; ports: - containerPort: 80 values.yaml 수정 1version: stable Helm Chart 설치 1helm install nginx-values-test . 실행 결과 123456NAME: nginx-values-testLAST DEPLOYED: Sun Nov 21 06:11:26 2021NAMESPACE: testSTATUS: deployedREVISION: 1TEST SUITE: None 배포 확인: 아래처럼 image version tag가 바뀐 것을 확인할 수 있다. 1k get deploy nginx-test -o yaml 12... - image: nginx:stable Helm Chart로 공개된 오픈소스 문법 참고 Nginx Prometheus Grafana 기존 .Values 템플릿 문법으로는 helm install &lt;차트명&gt;에서 입력되는 차트명까지는 가져오지 못한다.이러한 문제를 해결해주기 위한 템플릿 문법으로 .Release가 있다. 1234567891011121314151617# 1. /templates/deployment.yaml 릴리즈 템플릿 적용apiVersion: apps/v1kind: Deploymentmetadata: name: &#123;&#123; .Release.Name &#125;&#125; labels: app: &#123;&#123; .Release.Name &#125;&#125;spec: replicas: 1 selector: matchLabels: app: &#123;&#123; .Release.Name &#125;&#125; template: metadata: labels: app: &#123;&#123; .Release.Name &#125;&#125;... 123456789101112# 2. /templates/service.yaml 릴리즈 템플릿 적용apiVersion: v1kind: Servicemetadata: name: &#123;&#123; .Release.Name &#125;&#125;spec: selector: app: &#123;&#123; .Release.Name &#125;&#125; ports: - port: 80 targetPort: 80 type: ClusterIP Helm Chart 설치 (.Release 문법 적용) 1helm install nginx-rename-test . -n test 실행 결과 1234567891011# helm install nginx-rename-test . -n testNAME: nginx-rename-testLAST DEPLOYED: Sun Nov 21 06:48:04 2021NAMESPACE: testSTATUS: deployedREVISION: 1TEST SUITE: None# helm ls -n testNAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSIONnginx-rename-test test 1 2021-11-21 06:48:04.719317331 +0900 KST deployed nginx-test-0.0.1 nginx-values-test test 1 2021-11-21 06:11:26.928779655 +0900 KST deployed nginx-test-0.0.1 아래 명령을 실행하면, Helm이 최종적으로 어떤 정보로 릴리즈를 했는지 알 수 있다. Helm 명명된 릴리스에 대한 모든 정보 조회 1helm get all &lt;RELEASE_NAME&gt; 실행 결과 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# helm get all nginx-rename-testNAME: nginx-rename-testLAST DEPLOYED: Sun Nov 21 06:48:04 2021NAMESPACE: testSTATUS: deployedREVISION: 1TEST SUITE: NoneUSER-SUPPLIED VALUES:nullCOMPUTED VALUES:version: stableHOOKS:MANIFEST:---# Source: nginx-test/templates/service.yamlapiVersion: v1kind: Servicemetadata: name: nginx-rename-testspec: selector: app: nginx-rename-test ports: - port: 80 targetPort: 80 type: ClusterIP---# Source: nginx-test/templates/deployment.yamlapiVersion: apps/v1kind: Deploymentmetadata: name: nginx-rename-test labels: app: nginx-rename-testspec: replicas: 1 selector: matchLabels: app: nginx-rename-test template: metadata: labels: app: nginx-rename-test spec: containers: - name: nginx image: nginx:stable ports: - containerPort: 80 릴리스 히스토리를 가져오기, 업그레이드 내역(revision) 확인 등 유용 1helm history &lt;릴리즈_차트명&gt; Helm Chart 문법 검사 1helm lint &lt;차트_경로&gt; Helm /templates + values.yaml 최종 결과를 보여준다. 1helm template &lt;차트명&gt; &lt;차트_경로&gt; Helm 차트 릴리즈 업그레이드 추후 과정에서 더 자세히 설명 1helm upgrade &lt;릴리즈_차트명&gt; &lt;차트_경로&gt; 보통의 경우에는 values.yaml을 직접 작성하지 않고, 남이 작성한 파일을 가져오기 때문에 override(덮어쓰기)하여 사용이 된다. 아래의 2가지 방법이 있다. --set 인자 사용 -f 옵션으로 파일을 작성 --set 인자 사용 1helm install --set version=1.21.4 -n test nginx-set-test . 실행 결과 123456NAME: nginx-set-testLAST DEPLOYED: Sun Nov 21 07:09:41 2021NAMESPACE: testSTATUS: deployedREVISION: 1TEST SUITE: None 배포 결과 (values.yaml version 값이 stable이지만 1.21.4로 된 것을 알 수 있음) 123# k get deploy -n test nginx-set-test -o yaml | grep image... - image: nginx:1.21.4 -f 옵션으로 파일을 작성 1helm install -f &lt;파일경로&gt; -n test nginx-file-test . 2-1. override_values.yaml 파일을 아래와 같이 작성 1version: stable-alpine 차트 파일 구성 123456789.├── Chart.yaml├── override_values.yaml # 추가됨├── templates│ ├── deployment.yaml│ └── service.yaml└── values.yaml1 directory, 5 files 2-2. -f 옵션으로 Helm Chart 설치 1helm install -f override_values.yaml -n test nginx-file-test . 실행 결과 123456NAME: nginx-file-testLAST DEPLOYED: Sun Nov 21 07:16:31 2021NAMESPACE: testSTATUS: deployedREVISION: 1TEST SUITE: None 배포 결과 123# k get deploy -n test nginx-file-test -o yaml | grep image... - image: nginx:stable-alpine 실제 override 할 때는 각 차트의 configuration 항목을 참조하여 변경 필요한 값만 지정하여 설치 예제. nginx chart 기존 릴리즈된 차트 내용을 변경 요구시 사용 이력 관리를 위해 사용 Helm Chart 기본 설치1helm install -n test nginx-test . 결과 확인 (revision)1helm get all nginx-test Helm Chart 업그레이드1helm upgrade --set version=stable-alpine -n test nginx-test . REVISION이 올라가고 이미지 배포 버전이 바뀐 것을 알 수 있음 values.yaml을 변경하고 업그레이드를 진행하여도 변경이 됨 업그레이드시 주의사항 Helm 업그레이드시 Pod가 재기동됨(RollingUpdate) 12345# 1helm upgrade --set version=stable-alpine -n test nginx-test .# 2helm upgrade -n test nginx-test . 위 과정을 진행하면, helm 버전에 따라 values.yaml참고가 다르다. version3: 이전 revision을 그대로 따라 버전을 유지 version2: 이전 revision 버전을 유지하지 않는다. (첫 설치 values.yaml) 1helm rollback &lt;릴리즈_차트명&gt; &lt;REVISION&gt; 실행 결과 12345678910[root@acc-master nginx-chart]# helm rollback -n test nginx-test 1Rollback was a success! Happy Helming![root@acc-master nginx-chart]# helm lsNAME NAMESPACE REVISION UPDATED STATUS CHART APP VERSIONnginx-test test 3 2021-11-21 07:47:41.211560477 +0900 KST deployed nginx-test-0.0.1 [root@acc-master nginx-chart]# k get deploy -n test nginx-test -o yaml | grep image f:image: &#123;&#125; f:imagePullPolicy: &#123;&#125; - image: nginx:stable imagePullPolicy: IfNotPresent 롤백은 한다고 해도 revision은 이력관리를 위해 증가한다. 버전이 최초 설치와 동일한 stable로 변경된 것을 알 수 있다."},{"title":"TIL 10월 10일 (일)","date":"2022-09-23T10:58:11.428Z","path":"presentation/TIL/2021/10/10/index.html","text":"ul, ol, p { font-size: 0.75rem; } img[alt~=\"center\"] { display: block; margin: 0 auto; } header { color: #fff; } table { font-size: 0.6rem; } pre > code { color: initial; } h1 { font-size: 1.2rem; } h2 { font-size: 1rem; } h3 { font-size: 0.8rem; } h4 { font-size: 0.6rem; } h5 { font-size: 0.4rem; } TIL: 10월 10일 (일) h2, h3 { /* display: flex; justify-content: center; align-items: center; */ text-align: center; line-height: 0.8rem; color: #000; } h2 { font-size: 1.8rem; } h3 { font-size: 1.2rem; } strong { color: #fff; } p { color: #fff; } 1. impersonation에 대해서 잘 몰라서 정리 section { display: flex; align-items: center; justify-content: center; } h3 { font-size: 1rem; } 임퍼스네이션에 대해서 잘 몰라서 정리참고자료: https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation User impersonation 임퍼스네이션 헤더를 통해 다른 사용자 역할을 수행 가능 authenticates을 override를 하여 재정의 예를 들면, admin이 디버그를 위해 임시적으로 다른 유저를 가장함 동작 순서 credentials과 impersonation headers과 함께 API 요청 API 서버는 사용자를 인증 (Impersonation 권한을 체크함) HTTP 헤더 Impersonate-User: 유저명 Impersonate-Group: 유저 그룹, 여러개 가능. Impersonate-Extra-( extra name ): 추가 커스텀 헤더 Impersonate-Uid: UID, k8s 1.22.0 버전 이상에서 지원 사용 예시일반 1kubectl drain mynode Impersonation 사용 예시 1kubectl drain mynode --as=superman --as-group=system:masters 사용 조건ClusterRole에 impersonate verbs 필요 12345678apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: impersonatorrules:- apiGroups: [&quot;&quot;] resources: [&quot;users&quot;, &quot;groups&quot;, &quot;serviceaccounts&quot;] verbs: [&quot;impersonate&quot;] 다양한 예시 12345678910111213141516171819202122232425262728apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: limited-impersonatorrules:# Can impersonate the user &quot;jane.doe@example.com&quot;- apiGroups: [&quot;&quot;] resources: [&quot;users&quot;] verbs: [&quot;impersonate&quot;] resourceNames: [&quot;jane.doe@example.com&quot;]# Can impersonate the groups &quot;developers&quot; and &quot;admins&quot;- apiGroups: [&quot;&quot;] resources: [&quot;groups&quot;] verbs: [&quot;impersonate&quot;] resourceNames: [&quot;developers&quot;,&quot;admins&quot;]# Can impersonate the extras field &quot;scopes&quot; with the values &quot;view&quot; and &quot;development&quot;- apiGroups: [&quot;authentication.k8s.io&quot;] resources: [&quot;userextras/scopes&quot;] verbs: [&quot;impersonate&quot;] resourceNames: [&quot;view&quot;, &quot;development&quot;]# Can impersonate the uid &quot;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&quot;- apiGroups: [&quot;authentication.k8s.io&quot;] resources: [&quot;uids&quot;] verbs: [&quot;impersonate&quot;] resourceNames: [&quot;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&quot;] pre { font-size: 0.5rem; } API 접근 확인 1kubectl auth can-i create deployments --namespace dev 결과는 다음과 같이 출력 1yes kubectl은 API 인증 계층을 신속하게 쿼리하기 위한 “auth can-i” 하위 명령어를 제공 이 명령은 현재 사용자가 지정된 작업을 수행할 수 있는지 여부를 알아내기 위해 SelfSubjectAccessReview API를 사용 사용되는 인가 모드에 관계없이 작동 관리자는 이를 사용자 가장(impersonation)과 병행하여 다른 사용자가 수행할 수 있는 작업을 결정 가능 1kubectl auth can-i list secrets --namespace dev --as dave SelfSubjectAccessReview는 authorization.k8s.io API 그룹의 일부로서 API 서버 인가를 외부 서비스에 노출 이 그룹의 기타 리소스에는 다음이 포함 SubjectAccessReview 현재 사용자뿐만 아니라 모든 사용자에 대한 접근 검토 API 서버에 인가 결정을 위임하는 데 유용 예를 들어, kubelet 및 확장(extension) API 서버는 자신의 API에 대한 사용자 접근을 결정하기 위해 해당 리소스를 사용 LocalSubjectAccessReview SubjectAccessReview와 비슷하지만 특정 네임스페이스로 제한 SelfSubjectRulesReview 사용자가 네임스페이스 안에서 수행할 수 있는 작업 집합을 반환하는 검토 사용자가 자신의 접근을 빠르게 요약해서 보거나 UI가 작업을 숨기거나 표시하는 데 유용 이러한 API는 반환된 오브젝트의 응답 “status” 필드가 쿼리의 결과인 일반 쿠버네티스 리소스를 생성하여 쿼리 가능 12345678910kubectl create -f - -o yaml &lt;&lt; EOFapiVersion: authorization.k8s.io/v1kind: SelfSubjectAccessReviewspec: resourceAttributes: group: apps resource: deployments verb: create namespace: devEOF 다음 페이지 계속 생성된 SelfSubjectAccessReview 는 다음과 같다. 12345678910111213apiVersion: authorization.k8s.io/v1kind: SelfSubjectAccessReviewmetadata: creationTimestamp: nullspec: resourceAttributes: group: apps resource: deployments namespace: dev verb: createstatus: allowed: true denied: false 음… can-i 명령을 이용하여 모든 리소스 권한을 알 수는 없을까? 아래의 명령을 이용하면 가능 1kubectl auth can-i --list 2. 쿠버네티스 API 헬스 엔드포인트 (/readyz) section { display: flex; align-items: center; justify-content: center; } h3 { font-size: 1rem; } 쿠버네티스 API 서버는 현재 상태를 나타내는 세 가지 API 엔드포인트(healthz, livez 와 readyz)를 제공 healthz 엔드포인트는 사용 중단(deprecated)됨 (쿠버네티스 v1.16 버전 이후) -&gt; 대신 보다 구체적인 livez 와 readyz 엔드포인트를 사용 livez livez 엔드포인트는 –livez-grace-period 플래그 옵션을 사용하여 시작 대기 시간을 지정 가능 readyz /readyz 엔드포인트는 –shutdown-delay-duration 플래그 옵션을 사용하여 정상적(graceful)으로 셧다운 가능 API 서버의 health/livez/readyz 를 사용하는 머신은 HTTP 상태 코드에 의존 모든 엔드포인트는 verbose 파라미터를 사용하여 검사 항목과 상태를 출력 가능(API 서버의 현재 상태를 디버깅하는데 유용) 1curl -k https:&#x2F;&#x2F;localhost:6443&#x2F;livez?verbose 인증을 사용하는 원격 호스트에서 사용할 경우에는 다음과 같이 수행1kubectl get --raw&#x3D;&#39;&#x2F;readyz?verbose&#39; 123456789101112[+]ping ok[+]log ok[+]etcd ok[+]poststarthook&#x2F;start-kube-apiserver-admission-initializer ok[+]poststarthook&#x2F;generic-apiserver-start-informers ok[+]poststarthook&#x2F;start-apiextensions-informers ok[+]poststarthook&#x2F;start-apiextensions-controllers ok[+]poststarthook&#x2F;crd-informer-synced ok[+]poststarthook&#x2F;bootstrap-controller ok...[+]poststarthook&#x2F;apiservice-openapi-controller okhealthz check passed 또한 쿠버네티스 API 서버는 특정 체크를 제외 가능1curl -k &#39;https:&#x2F;&#x2F;localhost:6443&#x2F;readyz?verbose&amp;exclude&#x3D;etcd&#39; 12345[+]ping ok[+]log ok...[+]etcd excluded: okhealthz check passed pre [class*=\"hljs-\"]:nth-child(n+8):nth-child(-n+10) { background-color: yellow; } 개별 헬스 체크 (FEATURE STATE: Kubernetes v1.22 [alpha]) 각 개별 헬스 체크는 HTTP 엔드포인트를 노출하고 개별적으로 체크가 가능 개별 체크를 위한 스키마는 /livez/&lt;healthcheck-name&gt; livez 와 readyz 는 API 서버의 활성 상태 또는 준비 상태인지를 확인할 때 사용 &lt;healthcheck-name&gt; 경로 위에서 설명한 verbose 플래그를 사용 1curl -k https:&#x2F;&#x2F;localhost:6443&#x2F;livez&#x2F;etcd 3. 파라렐즈 리눅스 외부에서도 접속 가능하게 하기 section { display: flex; align-items: center; justify-content: center; } h3 { font-size: 1rem; } 참고자료: https://khmirage.tistory.com/382 원인 Parallels를 이용해서 운영체제를 설치하게되면 기본적으로 네트워크가 NAT모드로 설정되어서 Guest OS의 IP 대역이 10.x.x.x로 잡히게 됨 10.x.x.x 대역으로 IP가 설정이 되버리면 Parallels가 설치되어있는 컴퓨터가 아닌 공유기 아래의 다른 컴퓨터에서는 저 가상머신에 접근할수가 없게 됨 해결 Parallels의 VM설정에서 Hardware -&gt; Network1 에서 Type을 Shared Network에서 Bridge 모드의 Default Adapter를 선택 Ubuntu Server를 재부팅1shutdown -h now IP 변경됬는지 확인 이후 ssh 연결시 정상 접속되는 것을 확인 공유기 설정을 통해 공인IP까지 맞추면 외부 접속 가능할 듯?"}],"posts":[{"title":"아키텍처 변천사 간략한 정리","date":"2022-09-19T15:00:00.000Z","path":"wiki/아키텍처/아키텍처_흐름/","text":"아키텍처 변천사 아무렇게나 코드를 던져두면 필요할 때마다 찾기가 힘듦 그래서 개발자들은 비슷한 코드를 모아 서로 이해할 수 있게 분류하기로 결정(아키텍처 = 모두가 이해하고 따를 수 있도록 하는 구조) 그런데 개발의 시간이 흐르면서 분류 방식에 대한 논쟁 및 트렌드 변경으로 각 아키텍처에 대한 차이를 알고 이해하기 위해 글을 작성 header: MVC flowchart LR view --> model controller --> model controller -->|data| view 화살표의 방향은 의존성을 의미 (ex. view는 model을 알고, model은 view를 모름) 기존 mvc의 약점으로 지적된 사항들 view 가 model을 알고 있는 것의 문제 model = 비즈니스 로직(businness domain)이기 때문에 변동성이 잦음 (화면 표시에 대한 이유와는 다른 변동성) 변화에 대한 이유가 다른데 의존성을 가지고 있음 model과 view의 관계가 너무 강한 것이 주로 이야기됨 ex. Java Spring (서버에서는 view -&gt; model 의존성이 없기 때문에 적합) 구성 Controller: 사용자의 요청사항을 데이터를 Model에 전달하고, 데이터를 View에 반영 Model: 데이터를 주관하는 영역, 데이터를 다루는 로직을 모델에 모아두어 view와 격리 View: 화면상에 출력되는 내용, 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너 header: 변형된 MVC flowchart LR view --> controller model --> controller controller --> model controller -->|data| view 모든 것을 controller가 관리하는 형태 기존 위의 mvc의 view -&gt; model에 대한 의존성이 사라졌지만, controller의 역할이 커짐 view와 model이 조금만 변경되도 controller까지 변경이 필요함 (유지보수 및 개발 공수가 큼) header: MVP flowchart LR view[view - getter,setter ] --> presenter model --> presenter presenter --> model presenter -->|data| view presenter가 view 컴포넌트의 getter, setter를 통해 접근 native dom이 아닌 인터페이스로 취급 (model을 주지 않아 로직이 없음) 모든 기능에 1:1 대응되는 getter, setter 작성 필요 ex. MFC, Android, visual basic 12345678910111213141516171819202122232425262728293031323334353637var PhotoView = Backbone.View.extend(&#123; //... is a list tag. tagName: &quot;li&quot;, // Pass the contents of the photo template through a templating // function, cache it for a single photo template: _.template( $(&quot;#photo-template&quot;).html() ), // The DOM events specific to an item. events: &#123; &quot;click img&quot; : &quot;toggleViewed&quot; &#125;, // The PhotoView listens for changes to // its model, re-rendering. Since tHere&#x27;s // a one-to-one correspondence between a // **Photo** and a **PhotoView** in this // app, we set a direct reference on the model for convenience. initialize: function() &#123; this.model.on( &quot;change&quot;, this.render, this ); this.model.on( &quot;destroy&quot;, this.remove, this ); &#125;, // Re-render the photo entry render: function() &#123; $( this.el ).html( this.template(this.model.toJSON() )); return this; &#125;, // Toggle the `&quot;viewed&quot;` state of the model. toggleViewed: function() &#123; this.model.viewed(); &#125;&#125;); header: MVVM flowchart LR binder --> view binder -->|observe| view-model view-model --> model model --> view-model view-model = view를 대신하는 순수한 데이터 구조체 view-model에 변경이 감지됬을 때, view가 자동으로 갱신, 혹은 view에서 이벤트가 발생했을 때 view-model을 변경 view-model은 view에 대한 존재를 몰라야함 Binder 보통은 아래 2가지 방식이 고려됨, 서로 장단점이 있음 - 참고 flowchart LR scanner --> binder scanner --> Dom binder -->|observe| view-model view-model --> model model --> view-model DOM 스캔 방식 (angular, svelte): Binder에서 Scanner 분리 model과 view 분리 쉬움 DOM에 대한 의존성이 크기 때문에 scanner를 분리 (binder를 보호하기 위함) 변화율(변동에 대한 시간)에 따라 분리 자체 DOM([vdom)을 소유 (react) Component 방식(model과 view가 같이 관리 - setState) header: 참고링크 TodoMVC Learning JavaScript Design Patterns 프론트엔드 아키텍처 트렌드 프론트엔드에서-MV-아키텍쳐 생활코딩 MVC 객체지향 JS Android MVP Proxy와 가상 돔을 사용하여 나만의 프레임워크 만들기 JavaScript Proxy. 근데 이제 Reflect를 곁들인 프레임워크별 DOM렌더링 전략 Book: 프레임워크 없는 프론트엔드 개발 - VanillaJS로 프레임워크의 원리 구현","tags":[{"name":"아키텍처","slug":"아키텍처","permalink":"https://taeuk-gang.github.io/tags/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"}],"categories":[{"name":"아키텍처","slug":"아키텍처","permalink":"https://taeuk-gang.github.io/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"}]},{"title":"HTTP 완벽 가이드 1장","date":"2022-09-17T06:45:20.000Z","path":"wiki/HTTP_완벽_가이드/1장/","text":"HTTP 완벽 가이드 1장: HTTP 개관 목차마다 무엇을 알아야하는지 정리 목차 1장 키워드들 HTTP 웹 리소스 MIME 타입 URI, URL, URN HTTP 메시지 Request(시작줄, 헤더, 본문) Response(상태줄, 헤더, 본문) 메서드, 상태코드 TCP 커넥션 프로토콜 버전 웹 구성요소 프록시, 캐시, 게이트웨이, 터널, 에이전트 1. HTTP 📝3-4p, HTTP MDNHTTP에 대해서 대략적으로 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. HTTP(HyperText Transfer Protocol) = 하이퍼미디어 문서를 전송하기위한 애플리케이션 레이어 프로토콜, 서버와 클라이언트 사이간의 메시지 통신 규약 웹 브라우저와 웹 서버간의 커뮤니케이션을위해 디자인되었지만, 다른 목적으로도 사용가능 HTTP는 클라이언트가 요청을 생성하기 위한 연결을 연다음 응답을 받을때 까지 대기하는 전통적인 클라이언트-서버 모델을 따름 2. 웹 리소스 📝5p, MIME_Types MDN‘웹 리소스’에 대해서 대략적으로 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. 웹 리소스 = HTTP 요청 대상 리소스의 특성은 더 이상 정의되지 않음(어떤 컨텐츠 등 가능) 정적 리소스(ex. text, html, word, pdf 등) 동적 리소스(ex. 게이트웨이)도 포함 3. MIME 타입 📝6p. MIME 타입 MDN, 뒷장에서 더 설명되서 자세한 내용은 생략‘MIME 타입’에 대해서 대략적으로 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. MIME(Multipurpose Internet Mail Extensions) = 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘 웹에서 파일의 확장자는 별 의미가 없음 각 문서와 함께 올바른 MIME 타입을 전송하도록, 서버가 정확히 설정하는 것이 중요 브라우저들은 리소스를 내려받았을 때 해야 할 기본 동작이 무엇인지를 결정하기 위해 사용 주 타입(Prmiary object type)/부 타입(Specific subtype)으로 구성 ex. text/html, image/jpeg, audio/mpeg, video/mpeg, application/pdf MIME 타입 전체 목록은 📝부록D 혹은 MIME 전체목록 MDN를 참고 MIME 타입은 대소문자를 구분하지는 않지만 전통적으로 소문자로 쓰여짐 4. URI vs URL 📝7-8p, URL과 URN MDN‘URI’, ‘URL’, ‘URN’에 대해서 관하여 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. URI(Uniform Resource Identifier) = 하나의 리소스를 가리키는 문자열 가장 흔한 URI는 URL로, 웹 상에서의 위치로 리소스를 식별 식별(URI)과 위치(URL)의 차이라고 보면 되지 않을까 싶네요…MDN문서에서도 굳이 이 차이에 대해서 설명하지 않고 있어, 이 부분은 생략하겠습니다. URN은 주어진 이름공간 안의 이름으로 리소스를 식별 ex urn:isbn:0451450523 책에서는 아직 널리 채택되지않은 기술이라고 언급하고 있지만, 현재는 rfc3986에서 확인한 결과 INTERNET STANDARD 상태이다. 주소가 바뀌는 것과 상관없이 사용할 수 있는 것이 특성 5. HTTP 메시지 📝9-13p, HTTP 메시지 MDNHTTP 메시지 구성 및 방식에 대해서 설명할 수 있으면 이 섹션을 건너뛰어도 좋습니다. 클라이언트와 서버는 HTTP 메시지를 주고받음 HTTP 메시지 = HTTP 메시지는 서버와 클라이언트 간에 데이터가 교환되는 방식 메시지 타입은 두 가지 요청(request) = 클라이언트가 서버로 전달해서 서버의 액션이 일어나게끔 하는 메시지 응답(response) = 요청에 대한 서버의 답변 HTTP 요청 HTTP 요청은 시작줄, 헤더, 본문으로 구성 시작줄(start-line) 첫번째로 오는 것은 HTTP 메서드로, 영어 동사(GET, PUT,POST) 혹은 명사(HEAD, OPTIONS)를 사용해 서버가 수행해야 할 동작 표시 두번째로 오는 요청 타겟은 주로 URL origin 형식: 끝에 &#39;?&#39;와 쿼리 문자열이 붙는 절대 경로 ex. GET /background.png HTTP/1.0 absolute 형식: 완전한 URL 형식 프록시에 연결하는 경우 대부분 GET과 함께 사용 ex. GET http://developer.mozilla.org/ HTTP/1.1 … authority 형식: 도메인 이름 및 옵션 포트(‘:’가 앞에 붙음)로 이루어진 URL의 authority component HTTP 터널을 구축하는 경우에만 CONNECT와 함께 사용 ex. CONNECT developer.mozilla.org:80 HTTP/1.1 asterisk 형식: OPTIONS와 함께 별표(‘*’) 하나로 간단하게 서버 전체를 표시 ex. OPTIONS * HTTP/1.1 마지막으로 ​​​​HTTP 버전을 표시 ex. HTTP/1.1 헤더(header) 요청에 들어가는 HTTP 헤더는 HTTP 헤더의 기본 구조를 따름 대소문자 구분없는 문자열 다음에 콜론(‘:’)이 붙음 다양한 종류의 요청 헤더 General 헤더: Via와 같은 헤더는 메시지 전체에 적용 Request 헤더: User-Agent 또는 Accept와 같은 헤더 Representation 헤더: Content-Type와 같은 헤더 본문(body) 모든 요청에 본문이 들어가지는 않음 GET, HEAD, DELETE , OPTIONS 리소스를 가져오는 요청은 보통 본문이 필요없음 넓게 보면 본문은 두가지 종류 단일-리소스 본문(single-resource bodies): 헤더 두 개(Content-Type와 Content-Length)로 정의된 단일 파일로 구성 다중-리소스 본문(multiple-resource bodies): 멀티파트 본문으로 구성되는 다중 리소스 본문에서는 파트마다 다른 정보를 지니게 됩니다. 보통 HTML 폼과 관련 다중 리소스 참고블로그 HTTP 응답상태줄(Status Line) HTTP 응답의 시작 줄은 상태 줄(status line)이라고 불림 프로토콜 버전: ex. HTTP/1.1 상태 코드: 요청의 성공 여부 상태 텍스트: 짧고 간결하게 상태 코드에 대한 설명을 글로 나타내어 사람들이 HTTP 메시지를 이해할 때 도움 HTTP 2부터는 사유 구절(reason phrase)이 제거됨 ex. HTTP/1.1 404 Not Found 시작줄과 다른 점은 요청타겟 대신 상태코드가 3자리 숫자로 구성되어 표시 (전체목록 참조) 1xx: 정보 응답 2xx: 성공 3xx: 리다이렉션 4xx: 클라이언트 오류 5xx: 서버 오류 헤더(header): Request Header와 동일본문(body) 모든 응답에 본문이 들어가지는 않음( 201, 204과 같은 상태 코드를 가진 응답에는 보통 본문이 없음) 넓게 3가지 종류로 구분 이미 길이가 알려진 단일 파일로 구성된 단일-리소스 본문: 헤더 두개(Content-Type와 Content-Length)로 정의 길이를 모르는 단일 파일로 구성된 단일-리소스 본문: Transfer-Encoding가 chunked로 설정되어 있으며, 파일은 청크로 나뉘어 인코딩 서로 다른 정보를 담고 있는 멀티파트로 이루어진 다중 리소스 본문 책 내용 외 추가작성. chrome 개발자도구에서는 HTTP Raw Message를 확인할 수 없다. 그렇다면 어떻게 확인할 수 있을까? 네트워크 패널에서 확인하고 싶은 요청의 curl을 복사(copy) 터미널을 열고 nc -l 8080(임의포트) 실행(요즘은 telnet대신 nc를 사용하는 추세) Netcat(ornc)은 TCP 또는 UDP 프로토콜을 사용하여 네트워크 연결을 통해 데이터를 읽고 쓰는 명령줄 유틸리티 일반적으로 상대 서버의 포트가 열렸는지 확인하거나, 직접 서버가 되어 원격 서버에서(클라이언트) 접속이 가능하지 확인하는 용도로 사용 복사한 curl을 붙여넣기(paste)하고 --raw -i 옵션을 추가하여 실행 nc가 실행된 터미널에서 HTTP 메시지 확인 가능 6. TCP 커넥션 📝13-18p.HTTP 어플리케이션 계층과 TCP 데이터 전송 계층을 이해했다면 이 섹션을 건너뛰어도 좋습니다. HTTP는 애플리케이션 계층 프로토콜로 네트워크 통신 핵심적인 세부적인 사항에 대해서 처리를 하지는 않음 대신 대중적이고 신뢰성 있는 TCP/IP에게 그 역할을 맡김 이 책에서 설명하는 TCP 특징 오류 없는 데이터 전송(신뢰성) 언제나 보낸 순서대로 도착 언제든 어떤 크기로든 보낼 수 있음 HTTP 프로토콜 5계층 HTTP (어플리케이션 계층) TCP (전송 계층) IP (네트워크 계층) Ethernet (네트워크 인터페이스 계층) 물리 계층 네트워크를 설명할 때 넘어갈 수 없는 것이 OSI 7계층, OSI 자체는 현재 사용되진 않지만 참조 모델로 주로 사용 1계층 물리 계층: 전기적, 기계적, 기능적인 특성을 이용해 데이터를 전송 2계층 데이터 링크 계층: 물리 계층을 통해 송수신되는 정보의 오류와 흐름을 관리 3계층 네트워크 계층: 네트워크 통신 경로 선택 4계층 전송 계층: 네트워크 통신 관리 5계층 세션 계층: 통신 시작과 종료 순서 6계층 표현 계층: 데이터의 표현 방법을 정의 7계층 응용 계층: 사용자의 요구를 만족시키는 응용 서비스를 제공 TCP/IP를 설명할 때는 보통 4계층으로 묶어서 설명애플리케이션(5-7계층), 전송(4계층)네트워크(3계층), 링크 계층(1-2계층) 7. 프로토콜 버전 📝18-19p. HTTP의 진화 MDNHTTP 버전간의 차이를 설명할 수 있다면 이 장을 생략 HTTP 초기 버전에는 버전 번호가 없었음 0.9부터 버전 관리를 시작 HTTP/0.9 – 원-라인 프로토콜 요청은 단일 라인으로 구성 가능한 메서드는 GET이 유일 HTTP 헤더가 없었는데 이는 HTML 파일만 전송될 수 있으며 다른 유형의 문서는 전송될 수 없음을 의미 문제가 발생한 경우, 특정 HTML 파일이 사람이 처리할 수 있도록, 해당 파일 내부에 문제에 대한 설명과 함께 되돌려 보내짐 HTTP/1.0 – 확장성 만들기 - RFC 1945에 공개 버전 정보가 각 요청 사이내로 전송 ex. GET HTTP/1.0 상태 코드 라인 또한 응답의 시작 부분에 붙어 전송 (브라우저가 요청에 대한 성공과 실패를 알 수 있음) HTTP 헤더 개념은 요청과 응답 모두를 위해 도입 일반적인 요청 예시 1234567891011GET &#x2F;mypage.html HTTP&#x2F;1.0User-Agent: NCSA_Mosaic&#x2F;2.0 (Windows 3.1)200 OKDate: Tue, 15 Nov 1994 08:12:31 GMTServer: CERN&#x2F;3.0 libwww&#x2F;2.17Content-Type: text&#x2F;html&lt;HTML&gt;A page with an image &lt;IMG SRC&#x3D;&quot;&#x2F;myimage.gif&quot;&gt;&lt;&#x2F;HTML&gt; HTTP/1.1 – 표준 프로토콜 현재 가장 널리 사용되는 HTTP 버전 커넥션이 재사용 가능 (keep-alive: Three-shake 오버헤드를 줄임) 파이프라이닝을 추가(첫번째 요청에 대한 응답이 완전히 전송되기 이전에 두번째 요청 전송을 가능케 하여, 커뮤니케이션 레이턴시를 낮춤) 청크된 응답 또한 지원 추가적인 캐시 제어 메커니즘이 도입 캐시 제어 메커니즘에 대한 내용은 이곳에서 확인 가능 언어, 인코딩 혹은 타입을 포함한 컨텐츠 협상이 도입 Host 헤더 덕분에, 동일 IP 주소에 다른 도메인을 호스트하는 기능이 서버 collocation을 가능 HTTP/2 – 더 나은 성능을 위한 프로토콜 텍스트 프로토콜이라기 보다는 이진 프로토콜 (더 이상 읽을 수도 없고 수작업을 만들어낼 수 없음) 병렬 요청이 동일한 커넥션 상에서 다루어질 수 있는 다중화 프로토콜(순서를 제거해주고 HTTP/1.x 프로토콜의 제약사항을 막음) 전송된 데이터의 분명한 중복과 그런 데이터로부터 유발된 불필요한 오버헤드를 제거(연속된 요청 사이의 매우 유사한 내용으로 존재하는 헤더들을 압축) 서버로 하여금 사전에 클라이언트 캐시를 서버 푸쉬라고 불리는 메커니즘, 필요한 데이터 채우기 허용 HTTP2 사용현황 - 2022. 09 기준 44% 사용 8. 웹 구성요소 📝19-22p. 프록시 서버 MDN프록시, 캐시, 게이트웨이, 터널, 에이전트에 대해서 설명할 수 있다면 이 섹션을 건너뛰어도 좋습니다. 프록시 클라이언트와 서버 사이에 위치하여 클라이언트의 요청을 받아 서버에 전달하고, 서버의 응답을 받아 클라이언트에 전달하는 역할을 하는 중간 서버 웹 보안, 어플리케이션 통합, 성능 최적화 등의 목적으로 사용 일반적으로 크게 주로 2가지 종류의 프록시 서버가 존재 포워드 프록시(forward proxy)는 인터넷 상에서 어디로든지 리퀘스트를 전송해주는 프록시 주로 캐싱, IP 우회 , 접근 제한 등 으로 사용 리버스 프록시(reverse proxy)는 인터넷에서 리퀘스트를 받으면, 내부망 내의 서버로 전송 주로 로드밸런싱, 보안 등 으로 사용 vpn과 forward proxy의 차이?개인 생각으로는 데이터 암호화로, forward proxy가 vpn을 포함하는 더 큰 범주라고 생각 📝19-22p. HTTP 캐싱 MDN 캐시 웹 캐시와 캐시 프록시는 자신을 거쳐 가는 리소스 중 자주 찾는 것의 사본을 저장하는 특별한 HTTP 프록시 라고 책에서 설명되고 있음 (7장에서 더 자세하게 설명) 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 더 빨리 문서를 받을 수 있음(웹 캐시는 레이턴시와 네트워크 트래픽을 줄여줌) 캐시 큰 종류는 설(private) 혹은 공유(shared) 캐시 두 가지 부류로 분류 공유 캐시는 한 명 이상의 사용자가 재사용할 수 있도록 응답을 저장하는 캐시 사설 캐시는 한 명의 사용자만 사용하는 캐시 그 외 게이트웨이 캐시, CDN, 리버스 프록시 캐시 그리고 로드 밸랜서 등이 있지만 현재 장에서 생략 브라우저 캐시(Private Cache) 사설 캐시는 단일 사용자가 전용으로 사용 사용자에 의하여 HTTP를 통해 다운로드된 모든 문서들을 가지고 있음 서버에 대한 추가적인 요청 없이 뒤로 가기나 앞으로 가기, 저장, 소스로 보기 등을 위해 방문했던 문서들을 사용 프록시 캐시(Shared Cache) 공유 캐시는 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시 회사의 ISP는 많은 사용자들을 서비스하기 위해 지역 네트워크 기반의 일부분으로서 웹 프록시를 설치가 가능 덕분에 조회가 많이 되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 레이턴시를 줄여줌 위 내용 제어를 원한다면 cache-control 헤더를 사용 12Cache-Control: private # 단일 사용자만을 위한 것이며 공유 캐시에 의해 저장되어서는 안됨Cache-Control: public # 응답이 어떤 캐시에 의해서든 캐시되어도 좋음 📝19-22p. Proxy servers and tunneling MDN 게이트웨이 다른 서버들의 중개자로 동작하는 특별한 서버 책에서는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기위해 사용된다고 설명 (ex. HTTP/FTP) 게이트웨이와 프록시에 대한 차이는 모호하긴 하지만, 목적에 대한 차이가 있음 게이트웨이는 서로 다른 서버를 연결해주는데 주 목적 (보통 2개 이상의 서버) 프록시는 필터링, 보안, 최적화에 등 목적을 갖고 다른 사이트를 대신하며 우회하는데 주 목적 (보통 1개의 서버) HTTP 터널 터널은 두 커넥션 사이에서 raw 데이터를 그대로 전달해주는 HTTP 애플리케이션 예시로 HTTP/SSL 터널링이 있음 에이전트 HTTP 요청을 만들어주는 클라이언트 프로그램(보통 웹 브라우저), 추가로 자동화 스파이더, 웹로봇이 존재 (9장 설명)","tags":[{"name":"HTTP 완벽 가이드","slug":"HTTP-완벽-가이드","permalink":"https://taeuk-gang.github.io/tags/HTTP-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C/"}],"categories":[{"name":"HTTP 완벽 가이드","slug":"HTTP-완벽-가이드","permalink":"https://taeuk-gang.github.io/categories/HTTP-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C/"}]},{"title":"k8s 1.22 -> 1.23 변경사항 정리","date":"2022-09-04T15:00:00.000Z","path":"wiki/k8s/1.22_1.23_k8s_update/","text":"1.23에서 stable로 변경된 문서들(변경 en:11, ko: 8) Container Runtime Interface (CRI) IPv4/IPv6 dual-stack IngressClass scope Generic ephemeral volumes Automatic Clean-up for Finished Jobs TTL mechanism for finished Jobs * 영문만 존재 Dual-stack support with kubeadm Configure volume permission and ownership change policy for Pods * 영문만 존재 Horizontal Pod Autoscaling Scaling on custom metrics Scaling on multiple metrics Configurable scaling behavior 특별히 봐야될 것만 작성 1. Container Runtime Interface (CRI) 쿠버네티스 v1.23에서는, Kubelet은 CRI v1을 사용하는 것을 권장 컨테이너 런타임이 CRI v1 버전을 지원하지 않는다면, Kubelet은 지원 가능한 이전 지원 버전으로 협상을 시도 v1.23 Kubelet은 CRI v1alpha2버전도 협상할 수 있지만, 해당 버전은 사용 중단(deprecated)으로 간주 Kubelet이 지원되는 CRI 버전을 협상할 수 없는 경우, Kubelet은 협상을 포기하고 노드로 등록하지 않는다. 2. IPv4/IPv6 dual-stack IPv4/IPv6 이중 스택 네트워킹을 사용하면 파드와 서비스에 IPv4와 IPv6 주소를 모두 할당 IPv4/IPv6 이중 스택 네트워킹은 1.21부터 쿠버네티스 클러스터에 기본적으로 활성화 IPv4 및 IPv6 주소를 동시에 할당 가능 자세한 내용은 링크 참조 3. IngressClass scope 인그레스 컨트롤러의 종류에 따라, 클러스터 범위로 설정한 파라미터의 사용이 가능할 수도 있고, 또는 한 네임스페이스에서만 사용 가능 클러스터 인그레스클래스 파라미터의 기본 범위는 클러스터 범위 .spec.parameters 필드만 설정하고 .spec.parameters.scope 필드는 지정하지 않거나, .spec.parameters.scope 필드를 Cluster로 지정하면, 인그레스클래스는 클러스터 범위의 리소스를 참조 예시 12345678910111213141516---apiVersion: networking.k8s.io/v1kind: IngressClassmetadata: name: external-lb-1spec: controller: example.com/ingress-controller parameters: # 이 인그레스클래스에 대한 파라미터는 &quot;external-config-1&quot; 라는 # ClusterIngressParameter(API 그룹 k8s.example.net)에 기재되어 있다. # 이 정의는 쿠버네티스가 # 클러스터 범위의 파라미터 리소스를 검색하도록 한다. scope: Cluster apiGroup: k8s.example.net kind: ClusterIngressParameter name: external-config-1 네임스페이스 .spec.parameters 필드를 설정하고 .spec.parameters.scope 필드를 Namespace로 지정하면, 인그레스클래스는 네임스페이스 범위의 리소스를 참조 파라미터의 kind(+apiGroup)는 네임스페이스 범위의 API (예: 컨피그맵) 를 참조하며, 파라미터의 name은 namespace에 명시한 네임스페이스의 특정 리소스를 가리킴 네임스페이스 범위의 파라미터를 이용하여, 클러스터 운영자가 워크로드에 사용되는 환경 설정(예: 로드 밸런서 설정, API 게이트웨이 정의)에 대한 제어를 위임 가능 클러스터 범위의 파라미터를 사용했다면 다음 중 하나에 해당 다른 팀의 새로운 환경 설정 변경을 적용하려고 할 때마다 클러스터 운영 팀이 매번 승인 애플리케이션 팀이 클러스터 범위 파라미터 리소스를 변경할 수 있게 하는 RBAC 롤, 바인딩 등의 특별 접근 제어를 클러스터 운영자가 정의 인그레스클래스 API 자신은 항상 클러스터 범위 네임스페이스 범위의 파라미터를 참조하는 인그레스클래스 예시 12345678910111213141516---apiVersion: networking.k8s.io/v1kind: IngressClassmetadata: name: external-lb-2spec: controller: example.com/ingress-controller parameters: # 이 인그레스클래스에 대한 파라미터는 # &quot;external-configuration&quot; 환경 설정 네임스페이스에 있는 # &quot;external-config&quot; 라는 IngressParameter(API 그룹 k8s.example.com)에 기재되어 있다. scope: Namespace apiGroup: k8s.example.com kind: IngressParameter namespace: external-configuration name: external-config 4. Generic ephemeral volumes 일반 임시 볼륨은 프로비저닝 후 일반적으로 비어 있는 스크래치 데이터에 대해 파드 별 디렉터리를 제공한다는 점에서 emptyDir 볼륨과 유사 하지만 다음과 같은 추가 기능도 제공 스토리지는 로컬이거나 네트워크 연결형(network-attached)일 수 있음 볼륨의 크기를 고정할 수 있으며 파드는 이 크기를 초과할 수 없음 드라이버와 파라미터에 따라 볼륨이 초기 데이터를 가질 수 있음 볼륨에 대한 일반적인 작업은 드라이버가 지원하는 범위 내에서 지원(스냅샷, 복제, 크기 조정, 및 스토리지 용량 추적 를 포함) 12345678910111213141516171819202122232425kind: PodapiVersion: v1metadata: name: my-appspec: containers: - name: my-frontend image: busybox volumeMounts: - mountPath: &quot;/scratch&quot; name: scratch-volume command: [ &quot;sleep&quot;, &quot;1000000&quot; ] volumes: - name: scratch-volume ephemeral: volumeClaimTemplate: metadata: labels: type: my-frontend-volume spec: accessModes: [ &quot;ReadWriteOnce&quot; ] storageClassName: &quot;scratch-storage-class&quot; resources: requests: storage: 1Gi 5. Automatic Clean-up for Finished Jobs 완료-이후-TTL(TTL-after-finished) 컨트롤러는 실행이 완료된 리소스 오브젝트의 수명을 제한하는 TTL (time to live) 메커니즘을 제공 TTL 컨트롤러는 잡만을 제어 완료-이후-TTL 컨트롤러 완료-이후-TTL 컨트롤러는 잡만을 지원 클러스터 운영자는 예시 와 같이 .spec.ttlSecondsAfterFinished 필드를 명시하여 완료된 잡(완료 또는 실패)을 자동으로 정리하기 위해 이 기능을 사용가능 잡의 작업이 완료된 TTL 초(sec) 후 (다른 말로는, TTL이 만료되었을 때), 완료-이후-TTL 컨트롤러는 해당 잡이 정리될 수 있다고 가정 완료-이후-TTL 컨트롤러가 잡을 정리할때 잡을 연속적으로 삭제 의존하는 오브젝트도 해당 잡과 함께 삭제되는 것을 의미 잡이 삭제되면 완료자(finalizers)와 같은 라이프 사이클 보증이 적용 TTL 초(sec)는 언제든지 설정이 가능 잡 필드 중 .spec.ttlSecondsAfterFinished 를 설정하는 몇 가지 예시 작업이 완료된 다음, 일정 시간 후에 자동으로 잡이 정리될 수 있도록 잡 메니페스트에 이 필드를 지정 이미 완료된 기존 잡에 이 새 기능을 적용하기 위해서 이 필드를 설정 어드미션 웹후크 변형 을 사용해서 잡 생성시 이 필드를 동적으로 설정, 클러스터 관리자는 이것을 사용해서 완료된 잡에 대해 TTL 정책을 적용 잡이 완료된 이후에 어드미션 웹후크 변형 을 사용해서 이 필드를 동적으로 설정, 잡의 상태, 레이블 등에 따라 다른 TTL 값을 선택 경고TTL 초(sec) 업데이트 TTL 기간은, 예를 들어 잡의 .spec.ttlSecondsAfterFinished 필드는 잡을 생성하거나 완료한 후에 수정가능 그러나, 잡을 삭제할 수 있게 되면(TTL이 만료된 경우) 시스템은 TTL을 연장하기 위한 업데이트가 성공적인 API 응답을 리턴하더라도 작업이 유지되도록 보장하지 않는다. 시간 차이(Skew) 완료-이후-TTL 컨트롤러는 쿠버네티스 잡에 저장된 타임스탬프를 사용해서 TTL의 만료 여부를 결정 클러스터 간의 시간 차이에 민감, 시간 차이에 의해서 완료-이후-TTL 컨트롤러가 잘못된 시간에 잡 오브젝트를 정리가 될 수 도 있음 6. TTL mechanism for finished Jobs * 영문만 존재 한글 문서 업데이트가 안되긴 했지만, 바뀐 내용 버전(beta -&gt; stable)외에 변경된 것외에 없음 완료된 잡 (Complete 또는 Failed)을 자동으로 정리하는 또 다른 방법 잡의 .spec.ttlSecondsAfterFinished 필드를 지정해서 완료된 리소스에 대해 TTL 컨트롤러에서 제공하는 TTL 메커니즘을 사용 TTL 컨트롤러는 잡을 정리하면 잡을 계단식으로 삭제 잡과 함께 파드와 같은 종속 오브젝트를 삭제 잡과 함께 파드와 같은 종속 오브젝트를 삭제 예시 pi-with-ttl 잡은 완료 후 100 초 이후에 자동으로 삭제 12345678910111213apiVersion: batch/v1kind: Jobmetadata: name: pi-with-ttlspec: ttlSecondsAfterFinished: 100 template: spec: containers: - name: pi image: perl command: [&quot;perl&quot;, &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;] restartPolicy: Never 만약 필드를 0 으로 설정하면, 잡이 완료된 직후에 자동으로 삭제되도록 할 수 있음 만약 필드를 설정하지 않으면, 이 잡이 완료된 후에 TTL 컨트롤러에 의해 정리되지 않음 참고 AC2-1396 이슈와 관련된 내용 ttlSecondsAfterFinished 필드를 설정하는 것을 권장 이는 관리되지 않는 잡(직접 생성한, 크론잡 등 다른 워크로드 API를 통해 간접적으로 생성하지 않은 잡)의 기본 삭제 정책이 orphanDependents(관리되지 않는 잡이 완전히 삭제되어도 해당 잡에 의해 생성된 파드를 남겨둠)이기 때문 삭제된 잡의 파드가 실패하거나 완료된 뒤 컨트롤 플레인이 언젠가 가비지 콜렉션을 한다고 해도, 이렇게 남아 있는 파드는 클러스터의 성능을 저하시킴 최악의 경우에는 이 성능 저하로 인해 클러스터가 중단 리밋 레인지(Limit Range)와 리소스 쿼터를 사용하여 특정 네임스페이스가 사용할 수 있는 자원량을 제한하는 것도 방법 7. Dual-stack support with kubeadm IPv4/IPv6 이중 스택이 활성화된 쿠버네티스 클러스터들을 어떻게 검증하는지 설명 v1.23 이전 버전에서도 검증을 수행할 수 있지만 GA 기능으로만 제공되며, v1.23부터 공식적으로 지원 자세한 내용은 링크 참조 Configure volume permission and ownership change policy for Pods * 영문만 존재 Pods에 대한 볼륨 사용 권한 및 소유권 변경 정책 구성 기본적으로 Kubernetes는 볼륨이 마운트될 때 각 볼륨의 컨텐츠에 대한 소유권과 사용 권한을 포드 SecurityContext에 지정된 fsGroup과 일치하도록 반복적으로 변경 대규모 볼륨의 경우 소유권 및 사용 권한을 확인하고 변경하는 데 많은 시간이 소요되어 포드 시작 속도가 느려질 수 있음 SecurityContext 내에서 fsGroupChangePolicy 필드를 사용하여 Kubernetes가 볼륨에 대한 소유권 및 사용 권한을 확인하고 관리하는 방법을 제어가 가능 fsGroupChangePolicy fsGroupChangePolicy는 포드 내부에 expose 되기 전에 볼륨의 소유권 및 사용 권한을 변경하는 동작을 정의 이 필드는 fsGroup 제어 소유권 및 사용 권한을 지원하는 볼륨 유형에만 적용 이 필드에는 두 가지 값이 존재 OnRootMismatch: 루트 디렉터리의 권한 및 소유권이 볼륨의 예상 권한과 일치하지 않는 경우만 변경, 이렇게 하면 볼륨의 소유권과 사용 권한을 변경하는 데 걸리는 시간을 단축가능 Always: 볼륨 마운트되면 항상 볼륨의 사용 권한 및 소유권을 변경 예시. 12345securityContext: runAsUser: 1000 runAsGroup: 3000 fsGroup: 2000 fsGroupChangePolicy: &quot;OnRootMismatch&quot; 이 필드는 secret, configMap 및 emptydir와 같은 사용 후 삭제 볼륨 유형에는 영향 X 9. Horizontal Pod Autoscaling stable로 변경된 기능 3가지 사용자 정의 메트릭을 이용하는 스케일링 이전에는 autoscaling/v2beta2 API 버전이 이 기능을 베타 기능으로 제공 autoscaling/v2beta2 API 버전을 사용하는 경우, (쿠버네티스 또는 어느 쿠버네티스 구성 요소에도 포함되어 있지 않은) 커스텀 메트릭을 기반으로 스케일링을 수행하도록 HorizontalPodAutoscaler를 구성할 수 있음, 이 경우 HorizontalPodAutoscaler 컨트롤러가 이러한 커스텀 메트릭을 쿠버네티스 API로부터 조회 요구 사항에 대한 정보는 메트릭 API를 위한 지원을 참조 복수의 메트릭을 이용하는 스케일링 이전에는 autoscaling/v2beta2 API 버전이 이 기능을 베타 기능으로 제공 autoscaling/v2 API 버전을 사용하는 경우, HorizontalPodAutoscaler는 스케일링에 사용할 복수의 메트릭을 설정 가능 이 경우 HorizontalPodAutoscaler 컨트롤러가 각 메트릭을 확인하고 해당 단일 메트릭에 대한 새로운 스케일링 크기를 제안 HorizontalPodAutoscaler는 새롭게 제안된 스케일링 크기 중 가장 큰 값을 선택하여 워크로드 사이즈를 조정(이 값이 이전에 설정한 ‘총 최대값(overall maximum)’보다는 크지 않을 때에만) 구성가능한 스케일링 동작 이전에는 autoscaling/v2beta2 API 버전이 이 기능을 베타 기능으로 제공 v2 버전의 HorizontalPodAutoscaler API를 사용한다면, behavior 필드(API 레퍼런스 참고)를 사용하여 스케일업 동작과 스케일다운 동작을 별도로 구성가능 각 방향에 대한 동작은 behavior 필드 아래의 scaleUp / scaleDown를 설정하여 지정가능 stabilizationWindow 를 명시하여 스케일링 목적물의 레플리카 수 워크로드 스케일링의 안정성을 고려할 수 있음 스케일링 정책 스펙의 behavior 섹션에 하나 이상의 스케일링 정책을 지정 정책이 여러 개 지정된 경우 가장 많은 양의 변경을 허용하는 정책이 기본적으로 선택된 폴리시 스케일 다운 예시 123456789behavior: scaleDown: policies: - type: Pods value: 4 periodSeconds: 60 - type: Percent value: 10 periodSeconds: 60 periodSeconds 는 폴리시가 참(true)으로 유지되어야 하는 기간을 나타냄 첫 번째 정책은 (파드들) 이 1분 내에 최대 4개의 레플리카를 스케일 다운할 수 있도록 허용 두 번째 정책은 비율 로 현재 레플리카의 최대 10%를 1분 내에 스케일 다운할 수 있도록 허용 기본적으로 가장 많은 변경을 허용하는 정책이 선택되기에 두 번째 정책은 파드의 레플리카 수가 40개를 초과하는 경우에만 사용 레플리카가 40개 이하인 경우 첫 번째 정책이 적용 예를 들어 80개의 레플리카가 있고 대상을 10개의 레플리카로 축소해야 하는 경우 첫 번째 단계에서 8개의 레플리카가 스케일 다운 레플리카의 수가 72개일 때 다음 반복에서 파드의 10%는 7.2 이지만, 숫자는 8로 올림 오토스케일러 컨트롤러의 각 루프에서 변경될 파드의 수는 현재 레플리카의 수에 따라 재계산 레플리카의 수가 40 미만으로 떨어지면 첫 번째 폴리시 (파드들) 가 적용되고 한번에 4개의 레플리카가 줄어듬 확장 방향에 대해 selectPolicy 필드를 확인하여 폴리시 선택을 변경 가능 레플리카의 수를 최소로 변경할 수 있는 폴리시를 선택하는 최소(Min)로 값을 설정 값을 Disabled 로 설정하면 해당 방향으로 스케일링이 완전히 비활성화 stabilizationWindow stabilizationWindow는 스케일링에 사용되는 메트릭이 계속 변동할 때 레플리카 수의 안정성을 위해 사용 오토스케일링 알고리즘은 이전의 목표 상태를 추론하고 워크로드 수의 원치 않는 변화를 방지하기 위해 이stabilizationWindow를 활용 scaleDown에 대해 안정화 윈도우 예시 123behavior: scaleDown: stabilizationWindowSeconds: 300 메트릭 관측 결과 스케일링 목적물이 스케일 다운 되어야 하는 경우, 알고리즘은 이전에 계산된 목표 상태를 확인하고, 해당 구간에서 계산된 값 중 가장 높은 값을 사용 위의 예시에서, 이전 5분 동안의 모든 목표 상태가 고려 대상이 됨 이를 통해 동적 최대값(rolling maximum)을 근사화하여, 스케일링 알고리즘이 빠른 시간 간격으로 파드를 제거하고 바로 다시 동일한 파드를 재생성하는 현상을 방지 기본 동작 사용자 지정 스케일링을 사용하기 위해서 모든 필드를 지정하지 않아도 됨 사용자 정의가 필요한 값만 지정 가능 이러한 사용자 지정 값은 기본값과 병합 기본값은 HPA 알고리즘의 기존 동작과 동일 1234567891011121314151617behavior: scaleDown: stabilizationWindowSeconds: 300 policies: - type: Percent value: 100 periodSeconds: 15 scaleUp: stabilizationWindowSeconds: 0 policies: - type: Percent value: 100 periodSeconds: 15 - type: Pods value: 4 periodSeconds: 15 selectPolicy: Max 스케일링 다운의 경우 300 초 (또는 제공된 경우–horizontal-pod-autoscaler-downscale-stabilization 플래그의 값 스케일링 다운에서는 현재 실행 중인 레플리카의 100%를 제거할 수 있는 단일 정책만 존재하며 이는 스케일링 대상을 최소 허용 레플리카로 축소할 수 있음을 의미 스케일링 업에는 stabilizationWindow가 없다 메트릭이 대상을 스케일 업해야 한다고 표시된다면 대상이 즉시 스케일 업을 한다. 두 가지 폴리시가 존재 HPA가 정상 상태에 도달 할 때까지 15초 마다 4개의 파드 또는 현재 실행 중인 레플리카의 100% 가 추가된다. 예시: 다운스케일 stabilizationWindow 변경 사용자 지정 다운스케일 안정화 윈도우를 1분 동안 제공하기 위해 다음 동작이 HPA에 추가 123behavior: scaleDown: stabilizationWindowSeconds: 60 예시: 스케일 다운 속도 제한 HPA에 의해 파드가 제거되는 속도를 분당 10%로 제한하기 위해 다음 동작이 HPA에 추가 123456behavior: scaleDown: policies: - type: Percent value: 10 periodSeconds: 60 분당 제거되는 파드 수가 5를 넘지 않도록 하기 위해, 크기가 5로 고정된 두 번째 축소 정책을 추가하고, selectPolicy 를 최소로 설정 selectPolicy 를 Min 으로 설정하면 자동 스케일러가 가장 적은 수의 파드에 영향을 주는 정책을 선택함을 의미 12345678910behavior: scaleDown: policies: - type: Percent value: 10 periodSeconds: 60 - type: Pods value: 5 periodSeconds: 60 selectPolicy: Min 예시: 스케일 다운 비활성화 selectPolicy 의 Disabled 값은 주어진 방향으로의 스케일링을 끔 따라서, 다운 스케일링을 방지하기 위해 다음 폴리시가 사용 123behavior: scaleDown: selectPolicy: Disabled 1.23 버전 변경된 리소스 추가 io.k8s.api.apps.v1.StatefulSetPersistentVolumeClaimRetentionPolicy 변경 io.k8s.api.apps.v1.StatefulSetSpec 추가 persistentVolumeClaimRetentionPolicy 추가 io.k8s.api.autoscaling.v2.ContainerResourceMetricSource 변경 io.k8s.api.batch.v1.JobStatus 추가 ready 추가 io.k8s.api.core.v1.GRPCAction 제거 io.k8s.api.core.v1.Handler 추가 io.k8s.api.core.v1.LifecycleHandler 변경 io.k8s.api.core.v1.PersistentVolumeClaimStatus 추가 allocatedResources 추가 io.k8s.api.core.v1.PodOS 추가 io.k8s.api.core.v1.PodSpec 추가 os 변경 io.k8s.api.core.v1.Probe 추가 grpc 추가 io.k8s.api.flowcontrol.v1beta2.FlowDistinguisherMethod 추가 io.k8s.api.flowcontrol.v1beta2.FlowSchema 제거 io.k8s.api.rbac.v1alpha1.AggregationRule 제거 io.k8s.api.rbac.v1alpha1.ClusterRole 제거 io.k8s.api.scheduling.v1alpha1.PriorityClass 제거 io.k8s.api.storage.v1alpha1.VolumeAttachment 제거 io.k8s.api.storage.v1alpha1.VolumeAttachmentList 제거 io.k8s.api.storage.v1alpha1.VolumeAttachmentSource 제거 io.k8s.api.storage.v1alpha1.VolumeAttachmentStatus 제거 io.k8s.api.storage.v1alpha1.VolumeError 추가 io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1.ValidationRule 1.23 버전 변경된 k8s-apiserver 변경 /api/v1/namespaces/&#123;namespace&#125;/services method: delete 추가 /apis/autoscaling/v2/ methods: get 추가 /apis/autoscaling/v2/horizontalpodautoscalers methods: get 추가 /apis/autoscaling/v2/namespaces/&#123;namespace&#125;/horizontalpodautoscalers methods: delete, get, post 추가 /apis/autoscaling/v2/namespaces/&#123;namespace&#125;/horizontalpodautoscalers/&#123;name&#125; methods: delete, get, patch, put 추가 /apis/autoscaling/v2/namespaces/&#123;namespace&#125;/horizontalpodautoscalers/&#123;name&#125;/status methods: get, patch, put 추가 /apis/autoscaling/v2/watch/horizontalpodautoscalers methods: get 추가 /apis/autoscaling/v2/watch/namespaces/&#123;namespace&#125;/horizontalpodautoscalers methods: get 추가 /apis/autoscaling/v2/watch/namespaces/&#123;namespace&#125;/horizontalpodautoscalers/&#123;name&#125; methods: get 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/ methods: get 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas methods: delete, get, post 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/&#123;name&#125; methods: delete, get, patch, put 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/flowschemas/&#123;name&#125;/status methods: get, patch, put 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations methods: delete, get, post 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/&#123;name&#125; methods: delete, get, patch, put 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/prioritylevelconfigurations/&#123;name&#125;/status methods: get, patch, put 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas methods: get 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/flowschemas/&#123;name&#125; methods: get 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations methods: get 추가 /apis/flowcontrol.apiserver.k8s.io/v1beta2/watch/prioritylevelconfigurations/&#123;name&#125; methods: get 제거 /apis/rbac.authorization.k8s.io/v1alpha1/ 제거 /apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings 제거 /apis/rbac.authorization.k8s.io/v1alpha1/clusterrolebindings/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/clusterroles 제거 /apis/rbac.authorization.k8s.io/v1alpha1/clusterroles/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/namespaces/&#123;namespace&#125;/rolebindings 제거 /apis/rbac.authorization.k8s.io/v1alpha1/namespaces/&#123;namespace&#125;/rolebindings/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/namespaces/&#123;namespace&#125;/roles 제거 /apis/rbac.authorization.k8s.io/v1alpha1/namespaces/&#123;namespace&#125;/roles/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/rolebindings 제거 /apis/rbac.authorization.k8s.io/v1alpha1/roles 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterrolebindings 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterrolebindings/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterroles 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/clusterroles/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/&#123;namespace&#125;/rolebindings 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/&#123;namespace&#125;/rolebindings/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/&#123;namespace&#125;/roles 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/namespaces/&#123;namespace&#125;/roles/&#123;name&#125; 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/rolebindings 제거 /apis/rbac.authorization.k8s.io/v1alpha1/watch/roles 제거 /apis/scheduling.k8s.io/v1alpha1/ 제거 /apis/scheduling.k8s.io/v1alpha1/priorityclasses 제거 /apis/scheduling.k8s.io/v1alpha1/priorityclasses/&#123;name&#125; 제거 /apis/scheduling.k8s.io/v1alpha1/watch/priorityclasses 제거 /apis/scheduling.k8s.io/v1alpha1/watch/priorityclasses/&#123;name&#125; 변경 /apis/storage.k8s.io/v1alpha1/namespaces/&#123;namespace&#125;/csistoragecapacities/&#123;name&#125; 제거 /apis/storage.k8s.io/v1alpha1/volumeattachments/&#123;name&#125; 제거 /apis/storage.k8s.io/v1alpha1/watch/volumeattachments 제거 /apis/storage.k8s.io/v1alpha1/watch/volumeattachments/&#123;name&#125;","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"}],"categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/"}]},{"title":"Helm 사용해보기","date":"2021-11-20T14:15:22.000Z","path":"wiki/TIL/2021/11/20/helm/","text":"","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"},{"name":"Helm","slug":"Helm","permalink":"https://taeuk-gang.github.io/tags/Helm/"}],"categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/"},{"name":"Helm","slug":"Kubernetes/Helm","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/Helm/"}]},{"title":"TIL 10월 11일 (월)","date":"2021-10-11T03:15:22.000Z","path":"wiki/TIL/2021/10/11/","text":"","tags":[{"name":"TIL","slug":"TIL","permalink":"https://taeuk-gang.github.io/tags/TIL/"}],"categories":[{"name":"TIL","slug":"TIL","permalink":"https://taeuk-gang.github.io/categories/TIL/"},{"name":"2021","slug":"TIL/2021","permalink":"https://taeuk-gang.github.io/categories/TIL/2021/"},{"name":"10","slug":"TIL/2021/10","permalink":"https://taeuk-gang.github.io/categories/TIL/2021/10/"}]},{"title":"TIL 10월 10일 (일)","date":"2021-10-10T03:15:22.000Z","path":"wiki/TIL/2021/10/10/","text":"","tags":[{"name":"TIL","slug":"TIL","permalink":"https://taeuk-gang.github.io/tags/TIL/"}],"categories":[{"name":"TIL","slug":"TIL","permalink":"https://taeuk-gang.github.io/categories/TIL/"},{"name":"2021","slug":"TIL/2021","permalink":"https://taeuk-gang.github.io/categories/TIL/2021/"},{"name":"10","slug":"TIL/2021/10","permalink":"https://taeuk-gang.github.io/categories/TIL/2021/10/"}]},{"title":"리팩토링 - Typescript","date":"2020-12-15T14:43:18.000Z","path":"wiki/Refactoring_typescript/","text":"리팩토링: Typescript 작성 방식 AS-IS 를 제시하고, 리팩토링 기법을 사용한 결과인 TO-BE 와 비교 연관성 있는 리팩토링 기법은 묶기 중요도 순서별로 순서 배열하기 코드 악취 (안티 코딩)1. 기이한 이름 함수 선언 바꾸기 변수 이름 바꾸기 필드 이름 바꾸기 2. 중복 코드3. 긴 함수4. 긴 매개변수 목록5. 전역 데이터6. 가변 데이터7. 뒤엉킨 변경8. 산탄총 수술9. 기능 편애10. 데이터 뭉치11. 기본형 집착12. 반복 switch문13. 반복문14. 성의 없는 요소15. 추측성 일반화16. 임시 필드17. 메시지 체인18. 중개자19. 내부자 거래20. 거대한 클래스21. 서로 다른 인터페이스의 대안 클래스22. 데이터 클래스23. 상속 포기24. 주석리팩토링 기법기본적인 리팩토링7. 변수 이름 바꾸기AS-IS1let a = height * width; TO-BE1let area = heigth * width; 캡슐화기능 이동데이터 조직화조건부 로직 간소화API 리팩토링상속 다루기값을 참조로 바꾸기만약 데이터를 갱신해야하는 경우면, 해당 데이터를 값으로 복사하면 안된다. 갱신의 경우에는 참조를 이용 AS-IS1let customer = new Customer(customData); TO-BE1let customer = customerRepository.get(customerData.id); 참조를 값으로 바꾸기AS-IS12345class Product &#123; applyDiscount(arg) &#123; this._price.amount -= arg; &#125;&#125; TO-BE12345class Product &#123; applyDiscount(arg) &#123; this._price = new Money(this._price.amount - arg, this._price.currency); &#125;&#125; 객체 통째로 넘기기변화에 대응이 쉬움, 그러나 함수가 레코드 자체에 의존하지 않는다면 쓰지말 것 AS-IS1234const low = aRoom.daysTemRange.low;const high = aRoom.daysTemRange.high;if (aPlan.withinRangle(low, high)) TO-BE1if (aPlan.withinRange(aRoom.daysTempRange)) 계층 합치기클래스 계층구조가 개발하면서, 부모와 자식관계가 너무 비슷해져 더는 독립적일 필요가 없는 경우에 사용 AS-IS12class Employee &#123;...&#125;class Salesperson extends Employee &#123;...&#125; TO-BE1class Employee &#123;...&#125; 기본형을 객체로 바꾸기 직관적이지는 않으나, 이후 프로그램이 커질수록 유지보수가 쉬워짐 AS-IS1234567891011121314151617181920212223242526272829303132333435363738const PRIORITY_VALUE = &#123; low: 0, normal: 1, high: 2, rush: 3,&#125; as const;type PRIORITY_VALUE = typeof PRIORITY_VALUE[keyof typeof PRIORITY_VALUE];type PRIORITY_KEY = keyof typeof PRIORITY_VALUE;class Order &#123; _priority: PRIORITY_KEY; constructor(data: any) &#123; this._priority = data.priority; &#125; get priority(): PRIORITY_KEY &#123; return this._priority; &#125; set priority(value: PRIORITY_KEY) &#123; this._priority = value; &#125; higherThan(otherValue: PRIORITY_KEY): boolean &#123; return PRIORITY_VALUE[this._priority] &gt; PRIORITY_VALUE[otherValue]; &#125;&#125;const orders: Order[] = [ new Order(&#123;priority: `normal`&#125;), new Order(&#123;priority: `high`&#125;), new Order(&#123;priority: `rush`&#125;)];console.log( orders.filter(order =&gt; order.higherThan(`high`))); TO-BE123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const PRIORITY_VALUE = &#123; low: 0, normal: 1, high: 2, rush: 3,&#125; as const;type PRIORITY_VALUE = typeof PRIORITY_VALUE[keyof typeof PRIORITY_VALUE];type PRIORITY_KEY = keyof typeof PRIORITY_VALUE;// 2. 기본형 대신, 클래스 생성class Priority &#123; _value: PRIORITY_KEY; constructor(value: PRIORITY_KEY) &#123; this._value = value; &#125; priority(): PRIORITY_KEY &#123; return this._value; &#125; higherThan(other: Priority): boolean &#123; return PRIORITY_VALUE[this._value] &gt; PRIORITY_VALUE[other._value]; &#125;&#125;class Order &#123; _priority: Priority; // 1. 캡슐화 constructor(data: any) &#123; this._priority = new Priority(data.priority); &#125; // 3. 게터 및 세터 수정 get priority(): Priority &#123; return this._priority; &#125; get priorityValue(): PRIORITY_KEY &#123; return this._priority.priority(); &#125; set priorityValue(value: PRIORITY_KEY) &#123; this._priority = new Priority(value); &#125;&#125;const orders: Order[] = [ new Order(&#123;priority: `normal`&#125;), new Order(&#123;priority: `high`&#125;), new Order(&#123;priority: `rush`&#125;)];console.log( orders.filter(order =&gt; order.priority.higherThan(new Priority(`normal`)))); 절차 변수 캡슐화 클래스 생성 setter와, getter 수정 단계 쪼개기AS-IS123const orderData = orderString.split(`/\\s+/`);const productPrice = priceList[orderData[0].split(`-`)[1]];const orderPrice = parseInt(orderData[1]) * productPrice; TO-BE123456789101112131415const orderRecord = parseOrder(order);const productPrice = priceList[orderData[0].split(`-`)[1]];function parseOrder(aString) &#123; const values = aString.split(/\\s+/); return &#123; productID: values[0].split(`-`)[1], quantity: parseInt(values[1]), &#125;;&#125;function price(order, priceList) &#123; return order.quantity + priceList[order.productID];&#125; 레코드 캡슐화하기AS-IS1234organization = &#123; name: `taeuk`, country: `korea`,&#125; TO-BE12345678910111213141516171819202122class Organization &#123; constructor(data) &#123; this._name = data.name; this._country = data.country; &#125; get name(): string &#123; return this._name; &#125; set name(aString): string &#123; this._name = aString; &#125; get country(): string &#123; return this._country; &#125; set country(aString): string &#123; this._country = aString; &#125;&#125; 매개변수 객체 만들기AS-IS1function amountInvoiced(startDate, endDate) &#123; ... &#125; TO-BE1function amountInvoiced(aDateRange) &#123; ... &#125; 매개변수를 질의 함수로 바꾸기AS-IS1 TO-BE1 질의 함수를 매개변수로 바꾸기AS-IS1 TO-BE1 9. 매직 리터럴 바꾸기AS-IS1 TO-BE1 10. 메서드 내리기AS-IS1 TO-BE1 11. 메서드 올리기AS-IS1 TO-BE1 12. 명령을 함수로 바꾸기AS-IS1 TO-BE1 13. 문장 슬라이드하기AS-IS1 TO-BE1 14. 문장을 함수로 옮기기AS-IS1 TO-BE1 15. 문장을 호출한 곳으로 옮기기AS-IS1 TO-BE1 16. 반복문 쪼개기AS-IS1 TO-BE1 17. 반복문을 파이프라인으로 바꾸기AS-IS1 TO-BE1 18. 변수 이름 바꾸기AS-IS1 TO-BE1 19. 변수 인라인하기AS-IS1 TO-BE1 20. 변수 쪼개기AS-IS1 TO-BE1 21. 변수 추출하기AS-IS1 TO-BE1 22. 변수 캡슐화하기AS-IS1 TO-BE1 23. 생성자 본문 올리기AS-IS1 TO-BE1 24. 생성자를 팩터리 함수로 바꾸기AS-IS1 TO-BE1 25. 서브클래스 제거하기AS-IS1 TO-BE1 26. 서브클래스를 위임으로 바꾸기AS-IS1 TO-BE1 27. 세터 제거하기AS-IS1 TO-BE1 28. 수정된 값 변환하기AS-IS1 TO-BE1 29. 슈퍼클래스 추출하기AS-IS1 TO-BE1 30. 슈퍼클래스를 위임으로 바꾸기AS-IS1 TO-BE1 31. 알고리즘 교체하기AS-IS1 TO-BE1 32. Assertion 추가하기AS-IS1 TO-BE1 33. 여러 함수를 변환 함수로 묶기AS-IS1 TO-BE1 34. 여러 함수를 클래스로 묶기AS-IS1 TO-BE1 35. 예외를 사전확인으로 바꾸기AS-IS1 TO-BE1 36. 오류 코드를 예외로 바꾸기AS-IS1 TO-BE1 37. 위임 숨기기AS-IS1 TO-BE1 38. 인라인 코드를 함수 호출로 바꾸기AS-IS1 TO-BE1 39. 임시 변수를 질의 함수로 바꾸기AS-IS1 TO-BE1 40. 제어 플래그를 탈출문으로 바꾸기AS-IS1 TO-BE1 41. 조건문 분해하기AS-IS1 TO-BE1 42. 조건부 로직을 다형성으로 바꾸기AS-IS1 TO-BE1 43. 조건식 통합하기AS-IS1 TO-BE1 44. 죽은 코드 제거하기AS-IS1 TO-BE1 45. 중개자 제거하기AS-IS1 TO-BE1 46. 중첩 조건문을 보호 구문으로 바꾸기AS-IS1 TO-BE1 48. 질의 함수와 변경 함수 분리하기AS-IS1 TO-BE1 50. 컬렉션 캡슐화하기AS-IS1 TO-BE1 51. 클래스 인라인하기AS-IS1 TO-BE1 52. 클래스 추출하기AS-IS1 TO-BE1 53. 타입 코드를 서브클래스로 바꾸기AS-IS1 TO-BE1 54. 특이 케이스 추가하기AS-IS1 TO-BE1 55. 파생 변수를 질의 함수로 바꾸기AS-IS1 TO-BE1 56. 플래그 인수 제거하기AS-IS1 TO-BE1 57. 필드 내리기AS-IS1 TO-BE1 58. 필드 올리기AS-IS1 TO-BE1 59. 필드 옮기기AS-IS1 TO-BE1 60. 필드 이름 바꾸기AS-IS1 TO-BE1 61. 함수 매개변수화하기AS-IS1 TO-BE1 62. 함수 선언 바꾸기AS-IS1 TO-BE1 63. 함수 옮기기AS-IS1 TO-BE1 64. 함수 인라인하기AS-IS1 TO-BE1 65. 함수 추출하기AS-IS1 TO-BE1 66. 함수를 명령으로 바꾸기AS-IS1 TO-BE1","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"kind를 이용한 클러스터 설치","date":"2020-11-15T14:43:18.000Z","path":"wiki/make-kind-cluster/","text":"kind를 이용한 클러스터 설치Download123curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.8.1/kind-$(uname)-amd64chmod +x ./kindmv ./kind /some-dir-in-your-PATH/kind # e.g. mv ./kind /usr/local/bin/kind Basic command기본값으로 kind-kind 의 이름으로 클러스터가 생성됨 1kind create cluster 확인방법1kubectl config get-contexts 현재는 이미 생성되어있는 클러스터 목록들 config1kind create cluster --config config.yaml config.yaml 1234567kind: ClusterapiVersion: kind.x-k8s.io/v1alpha4networking: apiServerPort: 6443 apiServerAddress: 0.0.0.0nodes:- role: control-plane 이름 설정기본 명령어만 치면, kind라는 이름의 클러스터명으로만 생성이 되기 때문에 1kind create cluster --naeme &lt;클러스터명&gt; 위의 명령어를 이용해 클러스터명을 지정할 수 있다. 결론위와 같이 kind를 이용하여, 클러스터를 생성하고 관리하면 쿠버네티스 오브젝트를 독립적으로 관리할 수 있다. 예를 들면, kubectl api-resources 를 이용하여 확인 했을 경우, 클러스터 마다 다른 것을 알 수있다. 확인은 아래의 예시를 통해 알 수 있다. 예시1. kind-rancher 클러스터의 경우, 오브젝트 목록 예시2. kind-kubesphere 클러스터의 경우, 오브젝트 목록","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"}],"categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/"}]},{"title":"4장 레플리케이션과 컨트롤러 - 관리되는 파드 배포","date":"2020-11-15T13:33:18.000Z","path":"wiki/4_k8s_replication/","text":"개인이 “쿠버네티스 인 액션” 책을 읽고 학습한 내용으로, 주말에 술 마시고 공부한 내용으로… 틀린 내용이 있을 수 있습니다. 4장 래플리케이션과 컨트롤러 - 관리되는 파드 배포 다루는 내용 소개 4.1 파드의 안정적 유지4.1.1 라이브니스 프로브 소개4.1.2 HTTP 기반 라이브니스 프로브 생성4.1.3 동작 중인 라이브니스 프로브 확인4.1.4 라이브니스 프로브 추가 속성 설정4.1.5 효과적인 라이브니스 프로브 생성오늘 여기까지 4.2 레플리케이션 컨트롤러 소개4.2.1 레플리케이션 컨트롤러 동작4.2.2 레플리케이션 컨트롤러 생성4.2.3 레플리케이션 컨트롤러 작동 확인4.2.4 레플리케이션 컨트롤러 범위 안팎으로 파드 이동4.2.5 파드 템플릿 변경4.2.6 수평 파드 스케일링4.2.7 레플리케이션 컨트롤러 삭제4.3 레플리케이션 컨트롤러 대신 레플리카셋 사용4.3.1 레플리카셋 vs 레플리케이션 컨트롤러4.3.2 레플리카셋 정의4.3.3 레플리카셋 생성 및 정의4.3.4 레플리카셋 라벨 셀렉터 정의4.3.5 레플리카셋 정리4.4 데몬셋으로 각 노드에서 파드 1개로 처리하기4.4.1 데몬셋으로 모든 노드에 파드 실행4.4.2 데몬셋으로 특정 노드에서만 파드 실행4.5 완료 가능한 단일 태스크 수행가능한 파드 생성4.5.1 잡 리소스 소개4.5.2 잡 리소스 정의4.5.3 파드 실행한 잡 정의4.5.4 잡에서 여러 파드 인스턴스 실행4.5.5 잡 파드가 완료되는 시간 제한4.6 잡 주기적으로 또는 한번 실행 스케줄링4.6.1 크론잡 생성4.6.2 스케줄된 잡의 실행 방법 이해4.7 요약","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"}],"categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/"}]},{"title":"3장 파드 - 쿠버네티스에서 컨테이너 실행","date":"2020-11-08T13:33:18.000Z","path":"wiki/k8s_3_pod/","text":"개인이 “쿠버네티스 인 액션” 책을 읽고 학습한 내용으로, 틀린 내용이 있을 수 있습니다. 3장 파드: 쿠버네티스에서 컨테이너 실행 주요 내용 파드 생성, 실행, 정지 파드, 다른 리소스를 라벨로 조직화 특정 라벨을 가진 모든 파드에서 작업 수행 네임스페이스로 파드 나누기 특정 형식을 가진 워커노드에 파드 배치 3.1 파드 소개Q: 파드가 뭔가요? A: 쿠버네티스의 기본 단위로, 컨테이너를 개별적으로 배포하기보다 일반적으로 한개의 컨테이너를 가진 파드를 배포하여 운영합니다. 특정 상황에서는 두개 이상이 될 수도 있겠지만, 일반적으로 하나의 컨테이너만 포함한 상태로 배포를 합니다.중요한 것은 항상 하나의 워커 노드에서 실행이 된다는 것입니다. 3.1.1 파드 필요 이유Q: 왜 파드가 필요한가요?or 컨테이너를 왜 직접 사용하지 않나요?or 왜 일반적으로 여러 컨테이너를 같이 실행하지 않나요?or 모든 프로세스를 단일 컨테이너에 넣으면 안되나요? A: 컨테이너는 단일 프로세스를 실행하는 것을 목적으로 설계되었고, 그 이유는 관련 없는 다른 프로세스들 을 모두 집어넣었을 경우, 동일한 표준 출력으로 로그를 기록하기 때문에 각 로그가 누가 남긴 로그인지 분별하기 힘들다. 단일 책임 원칙과 비슷한 원리로 이해됨, 상세 이유는 그 뒷장에서 소개됨 간단히 더 이야기하면, 컨테이너 그룹(파드)를 쪼갤 수록 노드의 파드들을 균형있게 분배할 수 있으며, 한쪽으로 자원이 넘쳐 실행되지 않을 것이다. 3.1.2 파드 이해(질문 이어서) A: 여러 프로세스를 단일 컨테이너로 묶지 않기 때문에, 컨테이너를 묶을 단위가 필요하여 나타난게 파드이다. 쿠버네티스는 파드 안에 모든 컨테이너가 네임스페이스가 아닌 동일한 리눅스 네임스페이스를 공유하도록 도커를 설정함 Q: 설정 내용이 뭐가 있나요? A: 파드 내의 컨테이너들은 같은 호스트이름과 네트워크 인터페이스를 공유하고 IPC를 통해 서로 통신합니다.그래서 파드 내 컨테이너는 동일한 IP주소와 포트를 공유합니다. Q: 그럼 부분 격리라고 하였는데, 현재 공유되는 내용만 이야기되었는데 격리되는 내용은 무엇인가요? A: 기본값으로 파일시스템은 다른 컨테이너와 완전히 분리됩니다. 볼륨에서 설정을 통해야만 파일을 공유할 수 있습니다. Q: 파드간 네트워크 IP주소와 포트는 다르다는 이야기로 들리는데, 파드간에는 어떻게 통신하나요? A: 파드간 다른 IP주소를 통해 접근을 하지만, 둘 사이에는 NAT(network address translation)이 없어서, LAN간 통신처럼 통신할 수 있습니다. 이것을 플랫 네트워크라고 표현합니다. 이는 소프트웨어 네트워크 계층으로 이루어져있습니다. 3.1.3 파드와 컨테이너 구성Q: 프론트 서버와 백엔드(DB) 컨테이너를 어떻게 구성하면 좋을까요? A: 앞에 이야기한 내용에서 일반적으로 한개의 컨테이너당 하나의 파드로 분할하여 실행시키는 것이 좋습니다. 만약 둘이 하나의 파드로 묶여 관리된다면 둘은 항상 같은 노드에서 실행되어야하며, 만약 두개의 노드가 있다면 1개는 유휴 상태가 될 것 입니다. A2: 또한 두 컨테이너를 하나의 파드에서 관리하면 안되는 이유로는 스케일링 입니다. 파드가 스케일링의 기본 최소 단위이기 때문에 쿠버네티스는 개별 컨테이너를 수평으로 확장하지 못합니다. 그래서 전체 파드를 수평으로 확장해야합니다. 그런데 프론트와 백엔드는 서로 다른 스케일링 요구사항을 가지고있기 때문에 나누는 것이 좋습니다. Q: 그럼에도 불구하고, 예외적으로 하나의 파드에서 여러 컨테이너를 사용해야하는 경우가 있을까요? A: 여러 컨테이너를 단일 파드에 넣는 주요 경우는 (주 컨테이너 + 보조 컨테이너들) 을 이루는 경우인데요. 예를 들어,주 컨테이너 = 웹 서버보조 컨테이너 = 주기적으로 컨텐츠를 웹서버 디렉토리에 저장혹은 로그 수집, 데이터 프로세서, 통신 어댑터 등등 을 사유로하는 컨테이너들이 함께 실행되야하는 경우입니다. 그래서 여러 컨테이너를 단일 파드에서 실행해야한다면 다음과 같은 조건을 생각해야합니다. 컨테이너를 함께 실행시켜야하는가? 여러 컨테이너가 결국 하나의 구성요소인가? 컨테이너가 함께 스케일링 되어야하는가? 3.2 YAML 또는 JSON으로 파드 생성Q: YAML으로 작성하면 장점이 무엇이 있나요? A: kubectl run으로 간단하게 리소소를 생성 가능하지만, 제한된 속성만 생성할 수 있으며, YAML을 사용할 경우 버전 관리가 가능해지는 장점이 있습니다. YAML의 작성은 해당 링크를 참조하면 됩니다. (하루종일 보고 사는 링크…;;) 3.2.1 기존 파드 YAML 살펴보기1kubectl get pod &lt;파드명&gt; -o yaml 위의 명령어를 입력하면 YAML 정의를 볼 수 있다. 막상 보면 너무 긴 내용이 있을텐데, 주요 파트는 3개이다. metadata: 이름, 네임스페이스, 라벨, 파드에 관한 정보 Spec: 파드 컨테이너, 볼륨, 파드 실제 명세 정보 status: 파드 상태, 각 컨테이너 설명, 상태, 파드 내부IP 등 현재 실행중인 파드 정보파드를 생성할 때는 작성할 필요없는 항목 3.2.2 파드 정의 YAML 작성kubia-manual.yaml 1234567891011apiVersion: v1kind: Podmetadata: name: kubia-menualspec: containers: - image: luksa/kubia name: kubia ports: - containerPort: 8080 protocol: TCP 포트를 지정해둔 것은 단지 정보에 불과, 이를 생략해도 다른 클라이언트에서 포트를 통해 파드에 연결할 수 있는지에 영향 미치지 않음. 0.0.0.0 주소에 열어둔 포트를 통해 접속을 허용시에 파드 스펙과 별개로 항상 해당 파드에 접속이 가능하기 때문 Q: 그럼 왜 명시하나요? A: 포트를 명시적으로 정의하면, 클러스터를 사용하는 모든 사람이 볼 수 있고, 포트에 이름을 지정해 편리하게 사용 가능 기타: 유용한 명령어 kubucetl explain1kubectl explain pods 1kubectl explain pod.spec 3.2.3 kubectl create음… 리소스를 만들기 전에 현재 어느 네임스페이스에서 만드는지는 확인하는 것이 좋다 123k config get-contexts# ork config view --minify | grep namespace: 클러스터 c201에서 test2 네임스페이스를 사용하는 것을 확인할 수 있음 생성1k create -f kubia-manual.yaml -o yaml 생성 확인1k get pods 3.2.4 애플리케이션 로그 보기컨테이너의 애플리케이션은 보통 로그를 파일에 쓰기보다는 표준 출력과 표준 에러에 로그를 남기는 것이 일반적 컨테이너 런타임(ex. 도커)는 이러한 스트림을 파일로 전달하고 다음 명령을 통해 로그를 가져옴 쿠버네티스를 사용하지 않았다면, ssh로 파드가 실행 중인 노드에 접속해 docker logs &lt;컨테이너ID&gt;를 치겠지만, 1kubectl logs kubia-manual 쿠버네티스는 해당 명령을 제공한다. 주의 사항컨테이너 로그는 하루 단위 또는 로그 파일이 10MB에 도달할 때마다 순환함 kubectl logs는 마지막으로 순환된 로그만 보여줌 또한 파드가 삭제되면 로그도 삭제됨 파드가 삭제되도 로그를 확인하고 싶다면 클러스터 전체의 중앙집중식 로깅을 설정해야함(17장) 여러 컨테이너를 가진 파드의 로그 확인12# kubectl logs &lt;파드명&gt; -c &lt;컨테이너명&gt;kubectl logs kubia-manual -c kubia 3.2.5 파드에 요청 보내기파드의 실제 동작을 보는 방법 (kubectl expose를 사용하지 않고) 파드에 테스트와 디버깅 목적으로 사용, 포트포워딩 1kubectl port-forward kubia-manual 8888:8080 1curl localhost:8888 curl을 통해 접근이 가능 3.3 라벨을 이용한 파드 구성실제 애플리케이션들이 배포된 클러스터 내에는 매우 많은 파드들이 존재, 그러므로 파드를 정리하는 매커니즘이 필요 3.3.1 라벨 소개위의 이유로 라벨은 리소스에 키-값으로 첨부할 수 있다. 해당 리소스내에서 고유하다면, 원하는 만큼 추가할 수 있다. 예를 들면, app=ui, app=as, app=pc 등으로 애플리케이션 라벨을 붙이고, rel=stable, rel=beta, rel=alpha로 버전을 관리할 수 있다. 3.3.2 파드 생성시 라벨 지정1234567891011121314apiVersion: v1kind: Podmetadata: name: kubia-menual labels: app: test rel: betaspec: containers: - image: luksa/kubia name: kubia ports: - containerPort: 8080 protocol: TCP 파드 라벨 보기1kubectl get pod --show-labels 파드 특정 라벨만 보기1kubectl get pod -L app 3.3.3 기존 파드 라벨 수정파드에 새로운 라벨 추가1kubectl label po kubia-manual added_label=0 파드에 기존 라벨 수정1kubectl label po kubia-manual added_label=1 3.4 라벨 셀렉터로 파드 부분 집합 나열라벨의 중요성은 라벨 셀렉터를 함께 사용할때 알 수 있음 예를 들어, 특정 키를 포함하거나 포함하지않는 라벨의 리소스 특정 키와 값을 가진 라벨의 리소스 특정 키를 가지고있지만, 다른 값을 라벨의 리소스 3.4.1 라벨 셀렉터로 파드 나열특정 키와 값 라벨 셀렉터 조건1kubectl get po -l app=test -L app 값은 상관하지않는 라벨 셀렉터 조건1kubectl get po -l app -L app 값을 가지고있지 않는 라벨 셀렉터 조건1kubectl get po -l &#x27;!app&#x27; 값이 아닌 라벨 셀렉터 조건1kubectl get po -l app!=test 값이 A 또는 B 인 조건1kubectl get po -l env in (test, rel) 값이 둘다 아닌 것1kubectl get po -l env notin (test, rel) 3.4.2 라벨 셀렉터에서 조건 사용책에 자세한 내용 X 해당 링크 참조 3.5 라벨 셀렉터로 파드 스케줄링쿠버네티스는 기본적으로 무작위로 워커 노드에 스케줄링한다. 모든 노드를 하나의 대규모 배포 플랫폼으로 생각하고 어떤 노드에 스케줄링은 중요하지 않기 때문이다. 그러나, 하드웨어 인프라가 동일하지 않은 상황일 경우, ex- 워커 노드 중 일부는 ssd, 다른 일부는 hdd, 거나 GPU 가속 제한 등은 특정 파드를 스케줄링 해주어야 할 것이다. 정확한 노드를 지정하는 대신, 노드의 필요 요구사항을 기술하고 만족하는 노드를 선택하도록 한다.이를 노드 라벨과 라벨 셀렉터를 통해 할 수 있다. 3.5.1 워커 노드 분류에 라벨 사용라벨은 모든 리소스에 적용 가능 1kubectl label node &lt;노드명&gt; gpu=true 3.5.2 특정 노드에 파드 스케줄링12345678910apiVersion: v1kind: Podmetadata: name: kubia-gpuspec: nodeSelector: gpu: &quot;true&quot; containers: - image: luksa/kubia name: kubia spec.nodeSelector를 사용하여 파드 스케줄링 3.5.3 하나의 특정 노드로 스케줄링각 노드에는 kubernetes.io/hostname=&lt;호트트네임&gt;으로 고유 라벨이 존재하기 때문에 특정 하나의 노드로 스케줄링이 가능하다. 그러나, 해당 노드가 오프라인일 경우, 스케줄링이 되지 않을 수 있다. 3.6 파드에 어노테이션 달기어노테이션 또한 라벨처럼 모든 리로스에 추가할 수 있다. 그러나 차이점으로, 식별 정보를 가지고 있지 않다.(셀렉터가 없음) 그러면 어디다 쓰지? 라벨보다 많은 정보를 가질 수 있다. (256kb까지 허용) 주로 쿠버네티스의 새기능이 추가하기 전에 어노테이션에서 시험적으로 적용되고, 이후 결정되면 필드로 도입된다. 유용하게 사용되는 경우는 오브젝트를 만든 사람을 어노테이션으로 지정해두면, 협업자들이 더 쉽게 알 수 있다. 3.6.1 오브젝트 어노테이션 조회k describe or k get po -o json 으로 조회 3.6.2 어노테이션 추가 및 수정1kubectl annotate pod kubia-manual company.com/annotation=&quot;test data&quot; 어노테이션의 경우 --overwrite없이 덮어쓰기 때문에 위의 형식처럼 입력된다. 3.7 네임스페이스로 리소스 그룹화쿠버네티스 네임스페이스는 프로세스를 격리하는데 사용하는 리눅스 네임스페이스와는 다르다. 오브젝트 그룹이 서로 겹칠 수 있기 때문에 한번에 하나의 그룹에서만 작업하고 싶을 때 사용 3.7.1 네임스페이스 필요성여러 네임스페이스를 사용하면, 멀티테넌트 환경처럼 리소스를 분리하는데 사용된다. (다른 네임스페이스 간에는 동일한 리소스명을 가질 수 있다) 예를 들어, 프로덕션, 개발, QA 환경 등으로 나누어 사용할 수 있다. 또한 네임스페이스는 리소스를 격리하는 것외에도 특정 사용자가 지정된 리소스에만 접근할 수 있도록 하고, 컴퓨팅 리소스르 ㄹ제한하는데도 사용된다. 3.7.2 네임스페이스 조회12345# 네임스페이스 목록 조회kubectl get ns# 특정 네임스페이스에 속한 파드 목록 조회kubectl get po -n kube-system 3.7.3 네임스페이스 생성Yaml로 생성1234apiVersion: v1kind: Namespacemetadata: name: custom-ns 1k create -f create-ns.yaml 명령어로 생성1kubectl create ns custom-ns 대부분의 오브젝트는 RFC1035 규칙 - 문자, 숫자, 대시, 점을 표현할 수 있지만, 네임스페이스의 경우 점(.)을 포함하지 못한다. 3.7.4 다른 네임스페이스 오브젝트 관리1kubectl create -f &lt;YAML파일명&gt;.yaml -n &lt;파드를 생성할 네임스페이스명&gt; 현재 네임스페이스 빠르게 변경하는 alias~/.bashrc에 추가 1alias kcd=&#x27;kubectl config set-context $(kubectl config current-context) --namespace &#x27; 3.7.5 네임스페이스 격리 이해네임스페이스를 사용하면 오브젝트를 별도 그룹으로 분리해 작업할 수 있게 하지만, 실행 중인 오브젝트에 대한 격리는 제공하지 않는다. 예를 들어, 다른 사용자들이 서로 다른 네임스페이스에 파드를 배포할 때 해당 파드가 서로 격리되어 통신할 수 없는 것이 반드시 이루어지지는 않는다. 해당 쿠버네티스 네트워킹 솔루션에 따라 다르다. 3.8 파드 중지 제거3.8.1 이름으로 파드 삭제12345# kubectl delete po &lt;삭제할 파드명&gt;kubectl delete po kubia-gpu# 여러개 제거시kubectl delete po pod1 pod2 파드를 삭제하면, 해당 파드 안에 있는 모든 컨테이너를 종료하도록 지시한다. 과정은 아래와 같다. 쿠버네티스는 프로세스에 SIGTERM 신호를 보냄 (기본값 30초 동안 기다림) 종료되지 않으면 SIGKILL 신호를 통해 종료 (정상 종료는 SIGTERM) 3.8.2 라벨 셀렉터로 파드 삭제1kubectl delete po -l rel=beta 해당 라벨에 관련된 파드가 제거됨 3.8.3 네임스페이스로 파드 제거1kubectl delete ns custom-ns 네임스페이스 전체를 삭제하고, 해당 내에 파드는 자동으로 삭제된다. 3.8.4 네임스페이스 유지하면서 안에 모든 파드 삭제1kubectl delete po --all 현재 네임스페이스 내의 모든 파드를 제거 만약 파드를 삭제하더라도 계속 생성이 된다면, 레플리케이션컨트롤러가 계속 재생성하는 것으로 레플리케이션컨트롤러를 삭제해야한다. 3.8.5 네임스페이스 모든 리소스 삭제1kubectl delete all --all 현재 네임스페이스에 모든 리소스 제거 명령 3.9 요약다 읽고 할 수 있어야 하는 것들 특정 컨테이너를 파드로 묶어야 하는지 결정 파드로 여러 프로세스를 실행 YAML 또는 JSON으로 파드 작성, 정의, 상태 확인 라벨과 라벨 셀렉터로 파드를 그룹화하고 한번에 여러 파드를 작업 노드 라벨과 셀렉터로 특정 노드에 파드를 스케줄링 어노테이션을 이용하여 더 큰 데이터 파드에 달기 네임스페이스로 팀들 간 동일한 클러스터를 각자 작업 Kubectl explain 명령으로 리소스 정보를 찾기","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"}],"categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/"}]},{"title":"일일 커밋 알람 어플","date":"2020-11-01T13:22:05.000Z","path":"wiki/DailyCommit/","text":"일일 커밋 알림 어플기획 키워드 타겟: 일일 커밋을 목표로 하는 개발자 = 승민이와 나, 개발자의 자기관리 오늘 커밋이 없으면, 1시간(옵션 조절 가능)마다 알림 메세지 발송 위젯 넣어서, 하루 커밋 개수 확인 개발 키워드 리액트 네이티브 레이아웃https://xd.adobe.com/view/95d7530f-77a4-496a-638a-c9f49a13014a-e3e6/ expo -&gt; react-native-cli 로 넘어가기expo 를 사용하면, 네이티브 라이브러리 사용에 제한이 되는 것을 알 수 있었음 https://reactnative.dev/docs/0.60/getting-started 여길 참고하여 셋팅 12345npx react-native init daily-github --template react-native-template-typescriptnpx react-native run-iosnpx react-native run-android typescript template 사용할 때 버그 발생공식 깃허브 에도 있는 known issue이고, 같은 버그가 발생한 사람 이 있어서, 이 글을 참고하여 해결 12345npm uninstall -g react-native-cliyarn global add @react-native-community/clinpx react-native init MyApp --template react-native-template-typescript 그리고 MyApp처럼 카멜케이스로 입력해야함 - 가 들어가면 에러가 뜸 해당 에러 정상 설치시 뜨는 화면 Fast Debug 및 시뮬레이터 둘다 뜨는 것 확인 eslint auto fixworkspace setting.json에 설정 [해당링크](https://www.digitalocean.com/community/tutorials/linting-and-formatting-with-eslint-in-vs- code) 참조 1234&quot;editor.codeActionsOnSave&quot;: &#123; &quot;source.fixAll.eslint&quot;: true&#125;,&quot;eslint.validate&quot;: [&quot;javascript&quot;] 백그라운드 이미지 삽입 (스플래시)1234567import &#123;ImageBackground&#125; from &#39;react-native&#39;;const image &#x3D; require(&#39;.&#x2F;assets&#x2F;img&#x2F;logo-og.png&#39;);&lt;ImageBackground source&#x3D;&#123;image&#125; style&#x3D;&#123;styles.image&#125;&gt; &lt;Text style&#x3D;&#123;styles.text&#125;&gt;백그라운드 이미지&lt;&#x2F;Text&gt;&lt;&#x2F;ImageBackground&gt; resizemode가 제대로 적용이 안됬는데..? 아니… react-native 공식 다큐먼트가 잘못 작성함 style에 들어가는 것이 아닌, prop에 들어가야 적용이 됨. 1&lt;ImageBackground resizeMode&#x3D;&quot;contain&quot;&gt; React-native-firebase 환경설정https://rnfirebase.io/ 참고 흐음… 어째 코르도바랑 하는 일은 똑같네 Mac 안드로이드 에뮬레이터에서 인터넷이 안될때 ios google-service.json 추가 방법폴더에 넣는 것만으로는 절대! 안되며, 이런 형식으로 프로젝트에 추가해줘야함 React-native-firebaseui 설치 깃허브 로그인(oauth) 만들기 목적 설치 123456789yarn add @react-native-firebase/appyarn add @react-native-firebase/authcd ios/ &amp;&amp; pod installnpm install react-native-firebaseui --savereact-native link react-native-firebaseui podfile 설정 1pod &#39;SDWebImage&#39;, &#39;~&gt; 4.0&#39; auth에 관한 것이 아니었음 React-native-firebaseui-auth 사용https://github.com/oijusti/react-native-firebaseui-auth 이걸 사용해보기로함 멀티인덱스 에러 이슈 https://stackoverflow.com/questions/50199565/react-native-build-error-while-merging-dex-archives 참고하여 해결 안됨 =&gt; expo에서 깃허브로 로그인을 구현한 사례가 있어서 이동 GitHubhttps://blog.expo.io/firebase-github-authentication-with-react-native-2543e32697b4 여기를 참고하여, 따라가보기 expo-auth-session이 독립되면서 많이 바뀐 듯함 공식 docs 여기를 참고하는 것이 좋아보임 Authorization callback URL &amp; Redirect URLdevelopment모드에서는 exp:// 을 사용하고, 배포시에는 scheme://를 사용 dev1exp:&#x2F;&#x2F;127.0.0.1:19000&#x2F;--&#x2F;expo-auth-session prod1comdailycommit:&#x2F;&#x2F;redirect accessToken 얻기https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/ accessToken 발급 확인 완료 라우터 구현https://docs.expo.io/guides/routing-and-navigation/ - 공식 docs의 예제가 오래된 것인지 작동하지 않는다. ~~https://wordbe.tistory.com/entry/React-Native-5-React-Navigation-%EC%84%A4%EC%A0%95~~ 음. 이걸 따라해보지 뭐… deprecated된 패키지 공식 문서 를 참고하여 따라해봄 참고 예제 따라하면 될 듯 react-native folder structure https://github.com/pcofilada/simple-react-native-starter Header 제거 https://reactnavigation.org/docs/stack-navigator/#headershown 여기 참고 1&lt;Stack.Navigator initialRouteName&#x3D;&quot;Home&quot; headerMode&#x3D;&quot;none&quot;&gt; headerMode 설정과 관련이 있음 React-native http통신 + useEffecthttps://ko.reactjs.org/docs/hooks-effect.html https://loy124.tistory.com/238 Redux + Typescript뭐쓰지? redux? mobx? redux가 함수형에 가까우므로, 오랜만에 사용해보자 참고 링크 https://www.digitalocean.com/community/tutorials/react-react-native-redux https://chaewonkong.github.io/posts/react-native-redux.html https://react.vlpt.us/using-typescript/05-ts-redux.html# Redux는 선택사항 이라는 글을 읽고…useState를 사용하면서, redux의 필요성에 관해 의문이 들어 자료 조사 https://delivan.dev/react/stop-asking-if-react-hooks-replace-redux-kr/ Redux Action + axioshttps://velog.io/@secho/React-13-%EB%A6%AC%EB%8D%95%EC%8A%A4-Axios%EB%A1%9C-%EC%83%81%ED%83%9C%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0 createAsyncAction : https://github.com/piotrwitek/typesafe-actions#createasyncaction 흠… 앱의 규모에 맞지않게 기술 스택이 너무 깊어지는데? 학습 목적이라고 생각을 해야하나… 기존의 간단한 코드로 가능한 사항들이 복잡도가 올라가고 있어서 불편 Debuggerhttps://medium.com/duckuism/react-native-%EB%94%94%EB%B2%84%EA%B9%85-%ED%99%98%EA%B2%BD-%EB%A7%8C%EB%93%A4%EA%B8%B0-7e46bfe89f6 아래 링크로 접속해야함 1rndebugger:&#x2F;&#x2F;set-debugger-loc?host&#x3D;localhost&amp;port&#x3D;19001 Router Hookhttps://reactrouter.com/web/api/Hooks 비율전체 높이: 100% 헤더 10% 오늘 커밋 15% 첫 커밋 내용 10% 전체 커밋 현황 25% 셋팅 30% 로그아웃 10% 오늘 커밋 개수 구하기1https:&#x2F;&#x2F;api.github.com&#x2F;repos&#x2F;&#123;owner&#125;&#x2F;&#123;repo&#125;&#x2F;stats&#x2F;commit_activity owner, repo 필요함 owner: 이미 access_token으로 가지고있음 + organzation 도 포함해야할듯 organization List의 경우, 하나하나 사용자가 클릭해서 허락해줘야하는 번거로움이 있어 퍼블릭 올거니제이션만 포함 repo: repo list에서 반복 돌려야할듯 :owner1https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;taeuk-gang&#x2F;orgs + login(유저 고유아이디) :repo1https:&#x2F;&#x2F;api.github.com&#x2F;user&#x2F;repos 1https:&#x2F;&#x2F;api.github.com&#x2F;orgs&#x2F;:org&#x2F;repos commit history개인 레포 1&#x2F;user&#x2F;repos 올거니제이션 레포 1&#x2F;repos&#x2F;&#123;owner&#125;&#x2F;&#123;repo&#125;&#x2F;commits","tags":[{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/tags/Projects/"}],"categories":[{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/categories/Projects/"},{"name":"Daily-Commit App","slug":"Projects/Daily-Commit-App","permalink":"https://taeuk-gang.github.io/categories/Projects/Daily-Commit-App/"}]},{"title":"Quick Start Typescript ~ 12장 정리","date":"2020-10-18T15:00:00.000Z","path":"wiki/Typescript quick start_12/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 12장 비동기 처리📝395p. 브라우저 Promise 지원 현황IE 지원 안함 Chrome 57 이상 Safari 10 이상 Android Browser 53 이상 IOS safari 10.2 이상 📝SetTimeout 3번째 인자https://developer.mozilla.org/ko/docs/Web/API/WindowTimers/setTimeout param ~ paramN : 타이머 완료 이후, 추가적으로 전달되는 파라미터 12345678910const promiseAsync = new Promise((resolve, reject) =&gt; &#123; let sec = Math.floor(Math.random() * 5) + 1; setTimeout((isTrue: boolean) =&gt; &#123; if (isTrue) &#123; resolve(sec); &#125; &#125;, sec * 1000, true);&#125;).then(res =&gt; &#123; console.log(res + `s`);&#125;); Promise.all([]) 결과값1234567891011121314151617181920212223function asyncDelay(order: number) &#123; return new Promise((resolve) =&gt; &#123; const ms = Math.floor(Math.random() * 1000) + 1; window.setTimeout(() =&gt; &#123; console.log(`작업 완료: ` + order); resolve(order); &#125;, ms); &#125;);&#125;function syncResultPromise() &#123; const p1 = asyncDelay(1); const p2 = asyncDelay(2); const p3 = asyncDelay(3); const p4 = asyncDelay(4); Promise.all([p1, p2, p3, p4]).then(order =&gt; &#123; console.log(`동기화된 출력: $&#123;order&#125;`); &#125;); // LOG: 동기화된 출력: 1,2,3,4&#125;syncResultPromise(); [p1, p2, p3, p4]의 결과값을 한번에 결과값으로 제공해주는 것을 알 수 있음 📝404p. RxJS RxJS에 관한 책이 아니기 때문에, 간단하게 설명하고 넘어간 듯 하다. 간단하게만 정리 반응형 프로그래밍 모델은 스트림 형태의 입력 이벤트를 감지해 반응을 처리할 수 있는 모델 입력된 데이터 스트림은 관측할 수 있고 다랄 수 있는 대상이 되므로 observables이 됨 발행 구독 패턴 옵저버 &lt;-&gt; 옵저버블 -&gt; 구독 &lt;- 통지 설치1npm i @reactivex/rxjs Import1import * as Rx from &#x27;@reactivex/rxjs&#x27;; 데이터 스트림의 형태유형1: 규칙이 있고, 제한범위가 있는 경우 유형2: 규칙이 있고, 제한 범위가 없는 유형3: 규칙이 없고, 제한 범위가 있는 유형4: 규칙이 없고, 제한 범위가 없는 비동기 코드 제어의 방식 차이promise와 다르게 오퍼레이터 메서드를 이용하여 연쇄적으로 처리할 수 있게 관련 인터페이스를 제공 생성 연산자 변형 연산자 콤비네이션 연산자 조건 연산자 필터링 연산자 자세한 사항은 RxJs에 관한 문서가 아니기 때문에 생략 추후, 별도 문서에서 공식 도큐먼트 참고하여 작성하기로…","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 11장 정리","date":"2020-10-17T15:00:00.000Z","path":"wiki/Typescript quick start_11/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 11장 제네릭📝361p 제네릭 소개제네릭(generics)은 클래스와 함수에 타입이 고정되는 것을 방지하고 재사용할 수 있는 요소를 선언할 수 있게 하는 것 기존 C#, JAVA에서 제공되었던 기능, 타입스크립트는 0.9부터 지원 장점 컴파일 시간에 진행해 타입 안정성을 보장 타입 캐스팅과 관련된 코드를 제거 가능 재사용이 가능한 코드 작성 가능 사용법12345678function arrayConcat&lt;T&gt;(array1: T[], array2: T[]): T[] &#123; return [...array1, ...array2];&#125;const array1 = [1,2,3];const array2 = [4,5,6];const resultConcat = arrayConcat&lt;number&gt;(array1, array2); &lt;T&gt; 가상의 타입(= 타입 매개변수(type parameter) = 제네릭 타입 변수(generic type variables))으로 임의의 단어를 사용해도 된다. 예제. 타입 캐스팅과 관련 코드 제거 음… 결국 문자열만 받아서, 캐스팅 코드를 없애거나, 숫자를 받아서 캐스팅 코드를 이후 처리하는거나 조삼모사 아닌가? 그럼 본질적으로 타입 캐스팅과 관련된 코드를 제거할 수 없는 것이 아닌가? 이전 12345function concat(str1, str2) &#123; return String(str) + String(str2);&#125;concat(`abc`, 123); 이후 12345function concat&lt;T&gt;(str1: T, str2: T): T &#123; return str1 + str2;&#125;concat&lt;string&gt;(`abc`, String(123)); // 음 결국? 캐스팅 코드가 필요해져버림 📝366p. 타입 매개변수 T를 특정 타입으로 제한해야할 경우12345// &lt;T extends string&gt;function concat&lt;T extends string&gt;(str1: T, str2: T): string &#123; return str1 + str2;&#125; 📝367p. 오버로드시의 제네릭1234function concat&lt;T&gt;(str1: T, str2: T): T;function concat(str1: any, str2: any) &#123; return str1 + str2;&#125; 📝369p. 타입 매개변수 2개 이상 선언법12345678910111213let mapArray = [];function put&lt;T, T2&gt;(str1: T, str2: T2): T;function put(idx: any, str: any) &#123; mapArray[idx] = str;&#125;function get&lt;T, T2&gt;(idx: T): T2;function get(idx: any) &#123; return mapArray[idx];&#125;put&lt;number, string&gt;(1, `hello`);console.log(get&lt;number, string&gt;(1)); 📝371p. Generic class1234567class 클래스명&lt;T&gt; &#123; 메소드(param: Array&lt;T&gt;, param2: number): T &#123; return param[param2]; &#125;&#125;const 인스턴스명 = new 클래스명&lt;number&gt;(파라미터); Example 12345678910111213141516interface IName &#123; name: string;&#125;class Profile implements IName &#123; name: string = `taeuk`;&#125;class Accessor&lt;T extends IName&gt; &#123; getKey(obj: T) &#123; return obj.name; &#125;&#125;let acc = new Accessor();console.log(acc.getKey(new Profile())); // LOG: taeuk 📝377p. 룩업 타입(lookup)keyof 키워드로 키값을 탐색하여, 유니언 타입처럼 작동시킴 아래의 예제를 보면, 인터페이스의 키값만을 허용하는 유니언 방식처럼 작동됨을 알 수 있음 1234567interface INumber &#123; one: number; two: number; three: number;&#125;type NumberKeys = keyof INumber; // one, two, three, 인터페이스 키값만을 허용 활용 예제12345678910function getValue&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let numbersKeys = &#123; one: 1, two: 2, three: 3,&#125;;console.log(getValue(numbersKeys, `one`)); // LOG: 1 📝379p. 인터페이스 상속과 동시에 제네릭 확장12345678910111213interface IFilter&lt;T&gt; &#123; unique(array: Array&lt;T&gt;): Array&lt;T&gt;;&#125;class Filter&lt;T&gt; implements IFilter&lt;T&gt; &#123; unique(array: Array&lt;T&gt;): Array&lt;T&gt; &#123; return array.filter((v, i, array) =&gt; array.indexOf(v) === i); &#125;&#125;let myFilter = new Filter&lt;string&gt;();let resultFilter = myFilter.unique([`a`, `b`, `c`, `a`, `b`]);console.log(resultFilter); // LOG: [`a`, `b`, `c`] 📝381p. 맵 객체 소개생략 📝384p. 제네릭 기반의 자료구조 작성스택, 큐, ArrayList같은 자료구조는 내장 객체로 지원되지 않아서 직접 구현을 필요로 하는데, 이 때 제네릭을 사용하는 것이 좋음 이 중 책에서는 ArrayList를 구현하는 것을 설명 자료구조를 학습하는 것이 목적이 아니기 때문에 생략","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 10장 정리","date":"2020-10-14T11:39:05.000Z","path":"wiki/Typescript quick start_10/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 10장 타입 선언과 변경, 타입 호환📝342p. 타입 캐스팅과 타입 변환의 차이명시적인 것의 차이 타입 캐스팅(type casting): 명시적으로 선언한 캐스팅 코드에 의한 타입 변경 타입 변환(type conversion): JS 인터프리터에 의한 타입 변경 123456789101112// Type castinglet a: number = 3;let b: string;b = String(a); // 명시적인 타입 캐스팅// Type conversionlet a = 3;let b = ``;console.log(typeof b); // stringb = a; // 자동 타입 변환console.log(typeof b); // number 📝343p. 타입 캐스팅(type casting)과 타입 어설션(type assertion) 차이컴파일 이후의 유지 여부 타입 캐스팅의 경우: 컴파일 이후, 코드 유지 타입 어설션의 경우: 컴파일 과정까지만 유효, 컴파일 이후 제거 📝344p. 타입 어셜선 선언 방법12345// 방법 1let num4: number = &lt;number&gt;myNum;// 방법 2let num5: number = myNum as number; 방법1 (꺾쇠 방식)의 경우는 JSX 문법과 유사해 충돌 위험이 존재하여, as를 쓰는 것을 권장 📝346p. 프로그래밍 언어마다의 타입 검사 방식과 타입스크립트의 타이핑 방식 동적 타입 검사(dynamic type checking): Javascript의 duck typing - 런타임 시점 정적 타입 검사(static type chcking): C++, Java - 컴파일 시점 타입 스크립트의 경우는 두개 모두 지원 타입스크립트의 4가지 타입 지정 방식 아래와 같은 방법의 이름은 몰라도 개발하면서 자연스럽게 사용해야한다. 덕 타이핑(Duck typing) 구조 타이핑(structural typing) 구조 서브타이핑(structural subtyping) 명목 타이핑(nominal typing) 덕 타이핑123456789101112131415161718192021222324252627282930313233interface DuckGoose &#123; speak(); swim();&#125;class Duck &#123; speak() &#123; console.log(`꽥`); &#125; swim() &#123; console.log(`수영 중...`); &#125;&#125;class Goose &#123; speak() &#123; console.log(`구우`); &#125; swim() &#123; console.log(`거위 수영 중...`); &#125;&#125;function swim(obj: DuckGoose) &#123; obj.speak(); obj.swim();&#125;let duck = new Duck();let goose = new Goose();swim(duck);swim(goose); 자바스크립트 런타임시 동적으로 타이핑이 이뤄지는 타입 지정 방식 같은 메서드를 호출하는 것을 볼 수 있음, 선언되지 않은 메소드의 경우 에러 발생 구조 타이핑1. 구조가 같은 클래스의 경우12345678910111213141516class Animal &#123; name: number; constructor(name: string, weight: number) &#123;&#125;&#125;class Bird &#123; name: number; constructor(speed: number) &#123;&#125;&#125;let animal: Animal = new Animal(`happy`, 100);let bird: Bird = new Bird(10);// 타입 호환 가능animal = bird;bird = animal; 타입스크립트 컴파일 시간에 타입 호환이 가능한지를 검사 클래스의 멤버 변수가 같으므로 서로 타입 호환이 가능 생성자 매개변수는 상관없음, 접근 제한자가 설정되있지 않기 때문에 생성자 내부에서만 사용할 수 있기 때문(생성자 매개변수 기본값 private) 2. 상속 관계를 고려한 구조가 같은 클래스의 경우1234567891011121314151617class Person &#123; public name: string;&#125;class Member extends Person &#123; public grade: number;&#125;class Admin extends Member &#123;&#125;class MemberCard &#123; public name: string; public grade: number;&#125;let admin: Admin = new Admin();admin = new MemberCard(); // 타입 호환이 가능 admin과 MemberCard는 아무런 관계가 없지만, 완전히 동일하지는 않지만 같은 구조의 멤버 변수를 소유하고 있으나 타입 호환이 가능 3. 구조가 같은 클래스와 인터페이스 간의 구조 타이핑클래스와 인터페이스의 구조 같으면 타입 호환이 가능 12345678910interface Person &#123; name: string;&#125;class Employee &#123; name: string;&#125;let person: Person;person = new Employee(); // 타입 호환이 가능 구조 서브타이핑타입 구조가 같아야지만 타입 호환이 이뤄지지만, 구조 서브타이핑은 구조가 부분적으로 같더라도 타입 호환을 지원 구조 서브타이핑의 조건하위 타입이 상위 타입으로만 호환 123456789101112// 상위 타입interface TypeA &#123; a: string; b: string;&#125;// 하위 타입interface TypeB &#123; a: string; b: string; c: string;&#125; 1. 타입이 없지만 구조가 일부 같은 변수 간의 구조 서브타이핑123456789101112let infoUpper = &#123; name: &quot;taeuk&quot;, country: &quot;korea&quot;&#125;;let infoSub = &#123; name: &quot;taeuk&quot;, country: &quot;korea&quot;, status: &quot;happy&quot;&#125;infoUpper = infoSub; 2. 매개변수 개수가 다른 함수 타입간의 구조 서브타이핑123456let funcUpper = (a: string) =&gt; a;let funcSub = (a: string, b: string): string =&gt; a + b;funcSub = funcUpper; // 하위 타입 = 상위 타입console.log(funcSub(`hello`, `world`)); 3. 구조가 일부 같은 객체와 인터페이스 간의 구조 서브타이핑1234567891011interface GroupUpper &#123; name: string; &#125;let groupSub = &#123; name: `Typescrript Group`, id: 1,&#125;let groupUpper: GroupUpper;groupUpper = groupSub; 명목 타이핑명시적으로 지정된 타입 간에만 타입이 호환 123456789101112131415161718192021enum EastAsia1 &#123; korea = 88, china = 86, japan = 81,&#125;enum EastAsia2 &#123; korea = 88, china = 86, japan = 81,&#125;let east1: EastAsia1 = EastAsia1.china;let ease2: EastAsia2 = EastAsia2.korea;// 구조적으로는 같지만, 아래의 코드는 작동하지 않음// let east1: EastAsia1 = EastAsia2.china;// let east2: EastAsia2 = EastAsia1.korea;east1 = 1000;east2 = 2000;","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 9장 정리","date":"2020-04-12T09:39:05.000Z","path":"wiki/Typescript quick start -9장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 9장 고급 타입📝315p. 유니언 타입1const x: string | number; 📝317p. 타입 가드typeof123456789function myIndexOf(x: number | string, y: string) &#123; if (typeof x === `string`) &#123; return x.indexOf(y); &#125; return -1;&#125;console.log(myIndexOf(`hello`, `e`)) instanceof12345678function diff(x: Cat | Dog) &#123; if (x instanceof Dog) &#123; ... return; &#125; return;&#125; 📝320p. 고급 타입들문자열 리터럴 타입1234567let event; &#x27;keyup&#x27; = &#x27;keyup&#x27;; // Olet event: &#x27;keyup&#x27; = &#x27;keyup2&#x27;; // error// ortype EventType = &#x27;keyup&#x27; | &#x27;mouseover&#x27;;const myEvent: EventType = &#x27;keyup&#x27;; 룩업 타입 (= 인덱스 타입)keyof 명령어를 통해 타입 T의 하위 타입을 생성, 타입 T는 여러 타입으로 이뤄진 유니언이나 인터페이스 타입을 의미 확장성을 고려해 interface를 도입 12345interface Profile &#123; name: string; gender: string; age: number;&#125; 이 인터페이스를 keyof를 활용하여 룩업 타입으로 선언 1234567891011121314151617181920212223242526// # 1// 이렇게 선언된 변수는 name , gener, age 중 하나를 할당 받기 가능type Profile1 = keyof Profile;let pValue: Profile1 = &#x27;name&#x27;;// # 2// 배열 타입의 내장 속성인, length, push, pop, concat 등을 할당받아 사용 가능type Profile2 = keyof Profile[];let pValue2: Profile2 = &#x27;length&#x27;;let pValue3: Profile2 = &#x27;push&#x27;;// # 3// ??? 이해 안되는 부분// 어느 문자열이든 입력 가능한건가?type Profile3: keyof &#123; [x: string]: Profile &#125;;let pValue4: Profile3 = `hello`;// # 4// name의 string 타입을 전달, 타입이 string일 때 접근 가능한 내장 속성 이용 가능type Profile4 = keyof Profile[`name`];let pValue5: Profile4 = `length`;let pValue6: Profile4 = `abcd`; // error non-nullable 타입타입스크립트 2.0 이전에는 null 이나 undefined는 모든 타입의 변수에 할당할 수 있었음 그러나, tsconfig.json에 strictNullCheck을 true로 바꾸면, null과 undefined가 자동으로 모든 타입의 할당되지 않고 별도로 타입으올 관리해줘야함. never 타입never는 모든 타입의 하위 타입으로 사용할 수 있지만, any만 할당될 수 없다. 사용용도 함수에 닿을 수 없는 코드 영역이 있어 반환값이 존재하지 않을 때 함수에 throw객체가 반환되어, 오류가 발생할 때 1234567const neverFunc = (): never =&gt; &#123; while (true) &#123; &#125; // console.log(); &lt;- 닿을 수 없음&#125;let resultNever: never = neverFunc(); 123function error(message: string): never &#123; throw new Error(message);&#125; this 타입this 타입을 다형적 this 타입이라고도 함, 선언 위치에 따라 참조하는 대상이 달라지기 때문 인터페이스에 this 사용 예시1234interface ListItem &#123; getHead(): this; getTail(): this;&#125; 플루언트 인터페이스 패턴 (플루언트 패턴)그냥 자기자신 반환해서 체이닝하는 패턴 개인적으로 이런 형식으로 많이 사용했었음 123456789101112131415const Mycalc = () =&gt; &#123; return &#123; val: 0, plus(num) &#123; this.val += num; return this; &#125;, minus(num) &#123; this.val -= num; return this; &#125; &#125;&#125;Mycalc().plus(3).minus(2).val // 1","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 8장 정리","date":"2020-04-12T04:39:05.000Z","path":"wiki/Typescript quick start -8장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 8장 모듈📝253p. 모듈 필요성 유지보수 전역 스코프 오염 방지 재사용성 모듈러 프로그래밍 기반 과정 모듈 식별 모듈 분리 선언 외부 공개 📝254p. 내부 모듈, 외부 모듈 차이타입스크립트 1.5부터 Namespce라는 특징과 ES6 모듈 특지이 추가 ECMAScript 표준 용어집에 2가지 형태의 모듈 구분 내부 모듈 - namespace 외부 모듈 - export 내부모듈, namespace란 여러 파일에 걸쳐 하나의 이름을 공유, reference를 통해 참조 외부모듈은 파일마다 이름 공간이 정해짐, import를 통해 참조 그러므로, namespace는 프로젝트와 분리해 라이브러리 단위의 모듈을 구성할 때 좋음 @types 폴더에서 구분하여 타입선언 등 을 하는 듯 하다 📝259p. Namespace1namespace Hello &#123;&#125; namespace = module키워드는 다르지만, 역할과 기능상 차이가 없습니다 키워드 중복 이유ES2015에서 namespace 용어가 표준으로 채택되면서, 원래 Typescript 1.5에서 사용하던 module 용어가 자연스럽게 Deprecated됨 그런데, Typescript 타입 만드는 example code를 보면 아직은 module이라는 용어가 많이 쓰이는 듯 하다 참고링크 - chart.js 여기는 왜 module과 namespace를 동시에 사용한걸까? 123456789// namespace 사용 예시namespace Hello &#123; function print() &#123;&#125;&#125; // module 사용 예시module Hello &#123; function print() &#123;&#125;&#125; ES6 변환 결과 1234var Hello;(function: Hello) &#123; funtion print() &#123;&#125;&#125;(Hello || (Hello = &#123;&#125;)); // 모듈이 있으면 전달, 없으면 초기화 = 느슨한 확장 loose argument 📝261p. 한 파일에 여러 네임스페이스 선언네임스페이스마다 구분이 필요하게 되므로, export 선언 필요 12345678910111213141516namespace MyInfo1 &#123; export let name = `name1`; export function getName() &#123; return MyInfo2.name; &#125;&#125; namespace MyInfo2 &#123; export let name = `name2`; export function getName() &#123; return MyInfo1.name; &#125;&#125; console.log(MyInfo1.getName());console.log(MyInfo2.getName()); 변환시 var로 변환되어 호이스팅 특성때문에 순서와 상관없이 서로 호출 가능 📝263p. ★ 네임스페이스 여러 파일에 선언프로젝트 규모 커지면, 파일 단위로 모듈을 분할 tsc 명령시, 타입스크립트 컴파일러가 자동으로 네임스페이스간 참조 관계를 고려함 그러나, 개별 파일을 컴파일시에는 ///&lt;reference path=&quot;to/path&quot; /&gt;가 필요함 파일 상단의 표시하면 됨 그러나, 사실 tsc 명령어로도 같이 123ts-node car2.ts # undefined, undefined 출력tsc --out out.js car2.ts # 합쳐 컴파일 필요 ts-node car2.ts tsc -out out.js car2.ts 컴파일 후에도, 결과를 명시적으로 표시되게 하려면, 네임스페이스를 모듈로 선언하고 import를 선언 필요 (다음장에서 설명됨) 📝268p. 네임스페이스 모듈사용법12345678// car1.tsexport namespace Car &#123; export let auto: boolean = false; export interface ICar &#123; name: string; vendor: string; &#125;&#125; 12345678910111213import * as ns from &#x27;./car1&#x27;;// namespace를 한번 더 선언해서 사용? 이유가 있나?namespace Car &#123; console.log(ns.Car.auto); class Taxi implements ns.Car.ICar &#123; name: string; vendor: string; &#125;&#125; console.log(ns.Car.auto); 📝271p. 네임스페이스 이름 확장네임스페이스 이름은 .을 허용, 이름 계층 확장하는데 사용 사용 예시 123// 순서 바뀌어도 문제는 없지만, 상위에서 하위로 선언하는게 맞음namespace Animal&#123;&#125;namespace Animal.Pet&#123;&#125; 그러나 상속에 개념이 전혀 아니고, 서로 다른 네임스페이스이므로, 변수나 메소드 공유 X 📝274p. 브라우저에서 네임스페이스 모듈 호출 네임스페이스간 결국 js에는 없는 개념으로, 순서대로 js 스크립트 호출해서 사용해야한다는 것 같음 📝276p. 모듈 사용법개별 export12export interface ICar &#123;&#125;export function Test() &#123;&#125; 1import &#123; ICar, Test &#125; from &#x27;../to/path&#x27;; 함께 export1234let ver: string = `1.0`;let display = () =&gt; `hello`;export &#123; ver, display &#125;; 1import &#123; ver, display &#125; from &#x27;../to/path&#x27;; 모두 export12export let ver: string = `1.0`;export let display = () =&gt; `hello`; 1234import * as m from &#x27;./to/path&#x27;console.log(m.ver);console.log(m.display()); 모듈 재노출12export * from &#x27;../to/path&#x27;;export * from &#x27;../to/path&#x27;; 1import * as m from &#x27;./to/path&#x27;; 모듈 파일을 가져와서 다시 export 하는 예시, 최상위에 모듈에서 많이 사용됨 📝281p. ★네임스페이스로 감싸서 재노출 namepsace 간 class보다 상위의 개념이기 때문에 감싸서 노출하면 편한 것 같다 1234// car-info.module.ts &lt;- 모듈 파일 명명법export namespace CarInfo &#123; export function hello() &#123;&#125;&#125; 123import &#123; CarInfo &#125; from &#x27;./car-info.module&#x27;;CarInfo.hello(); 📝283p. 디폴트 무법export-equals, import-equals 문 default 이전에 사용됬던 방식인 것 같은데, 몰랐던 부분 - 가끔 다른 프로젝트에서 종종 보였는데 이런 의미였구나 123456export = Chart;// 동일export default Chart;export &#123; Chart as default &#125;; 212345import Validator from &#x27;./validator&#x27;;// 동일import &#123; default as Validator &#125; from &#x27;./validator&#x27;; 주의사항모듈 하나당 default는 하나만 선언 가능 📝289 ~ 313p. 모듈시스템 생략 모듈 시스템은 각 파트마다 다르기 때문에 웹개발자라면 ES2015모듈을, Node.js개발자라면 CommonJs 모듈 형식을 기본으로 알고, 나머지는 상황에 따라 알아야할 것 같다 참고링크 책은 이론적인 부분으로 많이 설명되어있어, 실제에서는 어떻게 사용되고, 더 추가적인 내용을 찾아봄 타입스크립트 컴파일러가 모듈 타입 선언을 참조하는 과정 d.ts 만들기 - 개인적으로 몇몇 부분이 잘못? 이해가 안되는 부분 존재 타입스크립트 전환 후기 - import, export - global로 선언하는건 맞는지 모르겠는 부분 Chart.js의 타입 정의 정적 타이핑 TypeScript - 남의 라이브러리 쓸 때 d.ts 파일이 없는 경우","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Vue JSX 사용법","date":"2020-04-08T11:39:05.000Z","path":"wiki/Vue에서의 JSX 사용법 정리/","text":"Vue에서의 JSX 사용법 정리 Vue 공식 홈페이지에서 JSX에 대한 사용법이 자세히 명시되어있지 않아 정리함 이 사이트를 중심으로 재정리함 (중국어를 하나도 몰라서, 번역은 아님) 개인적 코드 스타일1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;ChildElement &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script lang&#x3D;&quot;tsx&quot;&gt;import &#123; Vue, Component &#125; from &#39;vue-property-decorator&#39;;import &#123; VNode &#125; from &#39;vue&#39;;type ChildComponent &#x3D; any;&#x2F;&#x2F; # 메뉴바const ChildElement: ChildComponent &#x3D; &#123; render(): VNode &#123; return ( &lt;div&gt;Test&lt;&#x2F;div&gt; ); &#125;,&#125;;@Component(&#123; components: &#123; ChildComponent, &#125;,&#125;)export default class Test extends Vue &#123;&#125;&lt;style scoped&gt;&lt;&#x2F;style&gt; JSX에서의 데이터 교류12345&lt;span&gt;Message: &#123;this.messsage&#125;&lt;&#x2F;span&gt;&lt;!-- v-html --&gt;&lt;div domPropsInnerHTML&#x3D;&#123;this.dangerHtml&#125;&#x2F;&gt;&lt;!-- v-model --&gt;&lt;custom-input v-model&#x3D;&#123;this.vm.name&#125; &#x2F;&gt; 동적 지정이 가능1234567&lt;!-- 일반적인 형태 --&gt;&lt;div class&#x3D;&quot;btn btn-default&quot; style&#x3D;&quot;font-size: 12px;&quot;&gt;Button&lt;&#x2F;div&gt;&lt;!-- JSX에서의 형태(동적 지정 가능) --&gt;&lt;div class&#x3D;&#123;&#96;btn btn-$&#123;this.isDefault ? &#39;default&#39; : &#39;&#39;&#125;&#96;&#125;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&#123;&#123;&#39;btn-default&#39;: this.isDefault, &#39;btn-primary&#39;: this.isPrimary&#125;&#125;&gt;&lt;&#x2F;div&gt;&lt;div style&#x3D;&#123;&#123;color: &#39;red&#39;, fontSize: &#39;14px&#39;&#125;&#125;&gt;&lt;&#x2F;div&gt; 일반적인 Template 방식과 다름 사실 거의 javascript 위에서 HTML을 작성한다고 보면 됨 12345678910&#123;&#x2F;* v-if *&#x2F;&#125;&#123;this.withTitle &amp;&amp; &lt;Title &#x2F;&gt;&#125;&#123;&#x2F;* v-if 加 v-else *&#x2F;&#125;&#123;this.isSubTitle ? &lt;SubTitle &#x2F;&gt; : &lt;Title &#x2F;&gt;&#125;&#123;&#x2F;* v-for *&#x2F;&#125;&#123;this.options.map(option &#x3D;&gt; &#123; &lt;div&gt;&#123;option.title&#125;&lt;&#x2F;div&gt;&#125;)&#125; 이벤트123456&lt;!-- 일반 이벤트(@event와 동일) --&gt;&lt;custom-buton onClick&#x3D;&#123;this.handleClick&#125;&gt;Click me&lt;&#x2F;el-buton&gt;&lt;!-- 네이티브 이벤트 --&gt;&lt;custom-button nativeOnClick&#x3D;&#123;this.handleClick&#125;&gt;Native click&lt;&#x2F;el-button&gt;&lt;!-- 파라미터 이용시 --&gt;&lt;custom-button onClick&#x3D;&#123;e &#x3D;&gt; this.handleClick(this.id)&#125;&gt;Click and pass data&lt;&#x2F;el-button&gt; 작성법하나의 엘리먼트로 래핑하여 작성 123456const Demo &#x3D; () &#x3D;&gt; ( &lt;div&gt; &lt;li&gt;One&lt;&#x2F;li&gt; &lt;li&gt;Two&lt;&#x2F;li&gt; &lt;&#x2F;div&gt;) 여러개 작성해야할 필요가 있을 경우 1234const Demo &#x3D; () &#x3D;&gt; [ &lt;li&gt;One&lt;&#x2F;li&gt; &lt;li&gt;Two&lt;&#x2F;li&gt;] Map을 이용한 반복 작성 12345678910111213141516171819&#123; data() &#123; return &#123; options: [&#39;one&#39;, &#39;two&#39;] &#125; &#125;, render() &#123; const LiItem &#x3D; () &#x3D;&gt; this.options.map(option &#x3D;&gt; &lt;li&gt;&#123;option&#125;&lt;&#x2F;li&gt;) return ( &lt;div&gt; &lt;ul&gt; &lt;LiItem &#x2F;&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; ) &#125;&#125; 이벤트 capture, passive, once, … 이벤트 키워드 기호 .passive &amp; .capture ! .once ~ .capture.once ~! 12345&lt;el-button &#123;...&#123; &#39;!click&#39;: this.doThisInCapturingMode, &#39;!keyup&#39;: this.doThisOnce, &#39;~!mouseover&#39;: this.doThisOnceInCapturingMode&#125;&#125;&gt;Click Me!&lt;&#x2F;el-button&gt; 이벤트 전파 이벤트 키워드 설명 .stop event.stopPropagation() .prevent event.preventDeafult() .self if (event.target !== event.currentTarget) return .enter (.13) if (event.keyCode !== 13) return .ctrl .alt .shift .meta if (!event.ctrlKey) returnaltKey, shiftKey, metaKey 1234567891011121314151617methods: &#123; keyup(e) &#123; &#x2F;&#x2F; .self if (e.target !&#x3D;&#x3D; e.currentTarget) return &#x2F;&#x2F; .enter&#96; .13 if (!e.shiftKey || e.keyCode !&#x3D;&#x3D; 13) return &#x2F;&#x2F; .stop e.stopPropagation() &#x2F;&#x2F; .prevent e.preventDefault() &#x2F;&#x2F; ... &#125;&#125; v-for123const LiArray &#x3D; () &#x3D;&gt; this.options.map(option &#x3D;&gt; ( &lt;li ref&#x3D;&quot;li&quot; key&#x3D;&#123;option&#125;&gt;&#123;option&#125;&lt;&#x2F;li&gt;)) 123const LiArray &#x3D; () &#x3D;&gt; this.options.map(option &#x3D;&gt; ( &lt;li ref&#x3D;&quot;li&quot; refInFor&#x3D;&#123;true&#125; key&#x3D;&#123;option&#125;&gt;&#123;option&#125;&lt;&#x2F;li&gt;)) v-slot123&lt;div class&#x3D;&quot;page-header__title&quot;&gt; &#123;this.$slots.title ? this.$slots.title : this.title&#125;&lt;&#x2F;div&gt; (동일 기능) Template에서는 아래와 같다 123&lt;div class&#x3D;&quot;page-header__title&quot;&gt; &lt;slot name&#x3D;&quot;title&quot;&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt; JSX에서는 default상태의 슬롯은 허용되지 않는다. 1234&lt;!-- 에러! --&gt;&lt;current-user&gt; &#123;&#123; user.firstName &#125;&#125;&lt;&#x2F;current-user&gt; JSX에서는 스코프 슬롯을 사용해야함일반적인 Vue slot 형태부모 123456&lt;current-user&gt; &lt;template v-slot:default&#x3D;&quot;&#123; injectedProps &#125;&quot;&gt; &lt;div&gt;&#123;&#123; injectedProps.user.firstName &#125;&#125;&lt;&#x2F;div&gt; &lt;el-button @click&#x3D;&quot;injectedProps.logFullName&quot;&gt;Log Full Name&lt;&#x2F;el-button&gt; &lt;&#x2F;template&gt;&lt;&#x2F;current-user&gt; 자식 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;slot v-bind:injectedProps&#x3D;&quot;slotProps&quot;&gt; &#123;&#123; user.lastName &#125;&#125; &lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; user: &#123; firstName: &#39;snow&#39;, lastName: &#39;wolf&#39; &#125; &#125; &#125;, computed: &#123; slotProps() &#123; return &#123; user: this.user, logFullName: this.logFullName &#125; &#125; &#125;, methods: &#123; logFullName() &#123; console.log(&#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;) &#125; &#125; &#125;&lt;&#x2F;script&gt; JSX에서 slot 형태부모 12345678910&lt;current-user &#123;...&#123; scopedSlots: &#123; subTitle: (&#123; injectedProps &#125;) &#x3D;&gt; ( &lt;div&gt; &lt;h3&gt;injectedProps.user&lt;&#x2F;h3&gt; &lt;el-button onClick&#x3D;&#123;injectedProps.logFullName&#125;&gt;Log Full Name&lt;&#x2F;el-button&gt; &lt;&#x2F;div&gt; ) &#125;&#125;&#125;&gt;&lt;&#x2F;current-user&gt; 자식 1234567891011121314151617181920212223242526272829303132333435&#123; data() &#123; return &#123; user: &#123; firstName: &#39;snow&#39;, lastName: &#39;wolf&#39; &#125; &#125; &#125;, computed: &#123; slotProps() &#123; return &#123; user: this.user, logFullName: this.logFullName &#125; &#125; &#125;, methods: &#123; logFullName() &#123; console.log(&#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;) &#125; &#125;, render() &#123; return ( &lt;div&gt; &#123;this.$scopedSlots.subTitle(&#123; injectedProps: this.slotProps &#125;)&#125; &lt;&#x2F;div&gt; ) &#125;&#125; 중간 나중에 정리 (현재 불필요 내용) 이상적인 나누는 구조12345678910111213render() &#123; const TabHeader &#x3D; ( &lt;div class&#x3D;&quot;page-header page-header--tab&quot;&gt;&lt;&#x2F;div&gt; ) const Header &#x3D; () &#x3D;&gt; ( &lt;div class&#x3D;&quot;page-header&quot;&gt;&lt;&#x2F;div&gt; ) &lt;div class&#x3D;&quot;page-header&quot;&gt; &#123;this.withTab ? TabHeader : &lt;Header&#x2F;&gt;&#125; &lt;&#x2F;div&gt;&#125; VueComponent 구조12345678910111213children data attrs domProps on injections listeners: click ...parent props scopedSlots slots Props 이용법1234567891011121314151617181920212223render() &#123; const Demo &#x3D; props &#x3D;&gt; &#123; return ( &lt;div&gt; &lt;h3&gt;Jsx中的内部组件 &#123; props.data.title &#125;&lt;&#x2F;h3&gt; &#123; props.children &#125; &lt;br &#x2F;&gt; &#123; props.scopedSlots.bar() &#125; &lt;&#x2F;div&gt; ) &#125; return ( &lt;div&gt; &lt;Demo title&#x3D;&quot;test&quot; attrsA&#x3D;&quot;a&quot; domPropsB&#x3D;&quot;b&quot; onClick&#x3D;&#123;this.demo&#125;&gt; &lt;h3&gt;Children&lt;&#x2F;h3&gt; &lt;template slot&#x3D;&quot;bar&quot;&gt; &lt;p&gt;Slot&lt;&#x2F;p&gt; &lt;&#x2F;template&gt; &lt;&#x2F;Demo&gt; &lt;&#x2F;div&gt; )&#125;","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/categories/Vue-js/"}]},{"title":"Quick Start Typescript ~ 7장 정리","date":"2020-04-05T04:39:05.000Z","path":"wiki/Typescript quick start -7장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성 분량이 많아, 이미 아는 내용이나 자주 사용하는 부분은 생략함 7장 클래스와 인터페이스 목차📝183p. 타입스크립트의 객체지향 프로그래밍 지원객체지향의 목적은 코드 중복을 최소화 ES6에서 class 키워드가 추가되면서 부족한 점이 존재 객체지향 프로그래밍 요소 Js(ES6) Ts 클래스 class class 인터페이스 ★지원안함 interface 인터페이스 구현 ★지원안함 implements 상속 extends extends 생성자 constructor(){} constructor(){} 접근 제한자 ★지원안함 private, public, protected final 제한자 ★지원안함 readonly(Ts 2.0부터) static 키워드 static static super 키워드 super super 제한자의 경우, 실제 Js로 변환됬을 경우, 사라지는 부분으로 개발상에서만 제한의 의미가 있는 것이 아쉽다 📝p187. 기존Js(prototype) vs class 비교12345678910111213141516// 기존 Js Prototype 객체지향 프로그래밍var Rectangle = (function() &#123; function Rectangle(x, y) &#123; this.x = x; this.y = y; &#125; Rectangle.prototype.getArea = function() &#123; return this.x * this.y; &#125;; return Rectangle;&#125;)();var rectangle = new Rectangle(1, 5);var area = rectangle.getArea();console.log(area); 모듈 패턴은 클로저를 이용해 비공개된 내부 메소드를 캡슐화하여, 전역공간을 더럽히지 않는 장점 존재 123456789101112131415161718192021// class 객체지향 프로그래밍interface Rectangle &#123; x: number; y: number; getArea(): number;&#125;class Rectanlge &#123; x: numberl y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125; getArea(): number &#123; return this.x * this.y; &#125;&#125; 📝p188. 상속(extends), 포함(2) 관계상속 생략 포함 관계 합성(composition) - 강한관계 집합(aggregation) - 약한관계 합성12345678910class Engine&#123;&#125;class Car &#123; private Engine; constructor() &#123; this.engine = new Engine(); // 인스턴스 생성 &#125;&#125;let myCar = new Car();myCar = null; // null이 되면 포함된 클래스 함께 제거 집합12345678910class Engine&#123;&#125;class Car &#123; private engine: Engine; constructor(engine: Engine) &#123; this.engine = engine; // 인스턴스 생성 &#125;&#125;let engine = new Engine(); // engine 인스턴스 별도로 선언let car = new Car(engine); // 인스턴스 생성시, 포함되는 클래스를 같이 전달 위 코드(합성)과의 차이점은 집합은 car 객체가 제거되더라도,engine 객체는 외부에서 선언되었기 때문에 제거되지않음 (수명주기를 함께하지 않기때문에 약한관계) 실무에서는 어디에 주로 사용될까? 📝p192. 접근 제한자 접근 제한자 특징 상속 여부 외부 객체 접근 public 외부 또는 자식클래스에서 접근 가능 O O protected 자식 클래스에서 접근 가능 O X private 해당 클래스에서만 접근 가능 X X 📝p195. 축약 코딩기법챕터와 상관없지만, 관련 있는 변수 묶어서 선언하기 좋아보여서 기록 1let [cWidth, cLength, cHeight] = [1, 2, 3]; 📝p195. 접근 제한자 선언 &gt; 클래스 매개변수가 됨123456789class Cube &#123; constructor(public width: number) &#123;&#125; getWidth() &#123; return this.width; &#125;&#125;let cube = new Cube(6);console.log(cube.width); // 6 📝p197. get/set 코딩스타일 매개변수/getter/setter 한꺼번에 모아서 관리 123456789class PC &#123; ram = `0G`; get ramCapcity() &#123; return this.ram; &#125; set ramCapcity(value) &#123; this.ram = value; &#125;&#125; 📝p197. 부모 클래스 멤버 변수 이용super() 키워드와 this 사용 super는 부모 클래스의 공개 멤버(public)에만 접근 가능 this는 부모에게 상속받은 멤버와 현재 클래스 모두 접근 가능 📝p199. 기본 접근 제한자잘못 알고 있던 사항 constructor 매개변수에서 접근 제한자를 설정 안할시, default가 public일줄 알았는데 private 임 접근 제한자를 생략할 경우, 생성자 외부에서 매개변수에 접근할 수 없음! 📝p202. 추상 클래스를 이용한 공통 기능 정의 언제 사용될까? 실무에서 자주 사용되는 케이스가 궁금 구현 메소드는 실제 구현 내용을 포함 추상 메소드는 선언만된 메소드, 그러므로 자식 클래스에서 추상 메소드를 받아 별도 구현해야함 ! 추상 메서드나 추상 멤버 변수는 자식 클래스에서 사용(overriding)할 수 있게 public으로 선언해야함 추상 클래스에 기반은 둔 구현 방식은 템플릿 메서드 패턴으로 많이 알려짐 123456789101112131415161718192021222324abstract class AbstractBird &#123; abstract name: string; abstract flySound(sound: string); // 구현 메소드가 있어도 상관이 없나보네 fly(): void &#123; this.flySound(`$&#123;this.name&#125;: 파닥`); &#125; &#125;class RealBird extends AbstractBird &#123; constructor(public name: string) &#123; super(); &#125; // 오버라이딩 flySound(sound: string) &#123; console.log(`$&#123;this.name&#125; 날아감`); &#125;&#125;let dogBird = new RealBird(`새`);dogBird.fly(); // 새 날아감 📝 p205. Interface 다중 상속 몰랐던 부분 자식 인터페이스는 여러 부모 인터페이스를 다중 상속 가능 1234567891011interface Car &#123; speed: number &#125;interface SportsCar &#123; acceleration: number &#125;interface MyOptimizedCar extends Car, SportsCar &#123; waterproof: boolean;&#125;let myCar = &lt;MyOptimizedCar&gt;&#123;&#125;; // ?? 인터페이스만으로 인스턴스를 만들 수 있는건가?myCar.speed = 100;myCar.acceleration = 100;myCar.waterproof = true; ! 만약 다중 상속 받을 때, 같은 이름의 메소드를 상속받으면 재정의해야함 12345678910111213141516171819202122232425262728293031interface Dog &#123; run(): void; getStatus(): &#123; runningSpeed: number; &#125;;&#125;interface Bird &#123; fly(): void; getStatus(): &#123; flightSpeed: number; &#125;;&#125;interface DogBird extends Dog, Bird &#123; getStatus(): &#123; runningSpeed: number, flightSpeed: number; &#125;&#125;class NewAnimal implements DogBird &#123; run(): void &#123;&#125; fly(): void &#123;&#125; getStatus(): &#123; runningSpeed: number, flightSpeed: number; &#125; &#123; return &#123; runningSpeed: 10, flightSpeed: 20 &#125; &#125;&#125; 📝p212. 클래스를 배열 요소로 보고 배열 타입 선언 몰랐던 부분 클래스 자체를 타입 선언 부분에 넣을 수 있음 1234567891011class Person &#123; public full: string; constructor(public name: string, public city: string) &#123; this.full = name + `($&#123;city&#125;)`; &#125;&#125;let personArray: Person[] = [ new Person(`kim`, `name`), new Person(`kang`, `name`)]; 📝p215. 인터페이스에 함수 타입 정의익명 함수에 대한 함수 타입 정의 ()를 사용하면 정의 할 수 있음 ! 매개 변수 이름과 타입이 일치하지 않더라도 상관이 없음 (??? 이유가 뭘까) 1234567891011interface IFormat &#123; (data: string, toUpper?: boolean): string;&#125;let format: IFormat = function (data: string, toUpper: boolean) &#123; ...&#125; let format: IFormat = function (str: string, isUpper: boolean) &#123; ...&#125; 📝p216. 오버라이딩오버라이딩 = 부모에서 상속받아, 자식 클래스에서 새로 구현하는 방법 두 가지 조건 필요 조건1: 부모클래스의 매개변수 타입이 같거나 상위 타입이여야함 조건2: 부모클래스의 매개변수 개수가 같거나 많아야 함 📝p219. 오버로딩오버로딩 = 메서드의 이름은 같지만 매개변수의 타입과 개수가 다르게 정의하는 방법 12345678// 점점 상위의 타입으로 선언typeCheck(value: number);typeCheck(value: string);typeCheck(value: any): void &#123; if (typeof value === `number`) console.log(`this is number`); else if (typeof value === `string`) console.log(`this is string`); else console.log(`nothing`);&#125; 📝p222. 인터페이스를 클래스에서 구현하여 오버로딩123456789interface IPoint &#123; getX(x: any): any;&#125;class Point implements IPoint &#123; getX(x?: number | string): any &#123; ... &#125;&#125; ! 인터페이스를 이용하면 선언과 구현을 분리하고 구현부의 구조를 강제 이 점에서 로직과 구조가 섞여 있는 클래스를 상속해 오버로딩하는 것보다 구조만을 가지고 있는 인터페이스를 이용하는 것이 복잡고 낮습니다. 📝p224. 다형성종류 클래스의 다형성 인터페이스의 다형성 매개변수의 다형성 클래스의 다형성12345678910111213141516171819202122class Planet &#123; stopTransduction(): void &#123; console.log(`stop - planet`); &#125;&#125;class Earth extends Planet &#123; public features: string[] = [`soil`, `water`, `oxyzen`]; stopTransduction(): void &#123; console.log(`stop - earth`); &#125; earthStop(): void &#123; console.log(`stop2 - earth`); &#125;&#125;let earth: Planet = new Earth(); // ★ Earth 인스턴스를 생성했지만, 타입은 상위의 Planet임earth.stopTransduction(); // stop - earth, 인스턴스의 메소드를 사용console.log(earth.features); // Error, 접근 불가earth.earthStop(); // Error, 오버라이딩 되지 않은 메소드는 접근 불가 부모 클래스의 타입을 지정받은 인스턴스는 실제 동작은 부모 클래스 기준으로 실행됨 그래서 자식 클래스 멤버 변수(features)에 접근할 수 없음 그러나, 메소드 자체는 자식 인스턴스의 것이 실행됨 (런타임 다형성(runtime polymorphism)), ex. duck typing 인터페이스의 다형성 클래스와 다르지 않아 코드만 적고 생략 12345678910111213141516171819interface IPerson &#123; getAlias: () =&gt; string; getAge(): number;&#125;class PoliceMan implements IPerson &#123; getAlias = () =&gt; `happy`; getAge(): number &#123; return 10; &#125; hasClub() &#123; return true; &#125;&#125;let policeMan: IPerson = new PoliceMan();console.log(policeMan.hasClub()); // Error, 접근 불가 매개변수의 다형성 (유니언 타입)1display(data: string | number) &#123;&#125; 문제점타입 가드가 빡셈 12345678910class MonitorDisplay &#123; display(monitor: Led | Oled | Uhd) &#123; if (monitor instanceof Led) &#123;&#125; else if (monitor instanceof Oled) &#123;&#125; else if (monitor instanceof Uhd) &#123; let myMonitor: Uhd = &lt;Uhd&gt;monitor; return myMonitor.getName(); &#125; &#125;&#125; type 키워드시 축약은 가능하지만 근본적인 해결책은 될 수 없음(클래스 타입 추가시마다, 매번 업데이트 필요) 123456// 여긴 또 신기하게 대문자로 명명했네..type MultiTypes = Led | Oled | Uhd;class MonitorDisplay &#123; display(monitor: MultiTypes) &#123; ...(if들) &#125;&#125; ★★ 매개변수의 다형성 (인터페이스)123456789101112131415161718192021222324interface Monitor &#123; getName(): string;&#125;class Led implements Monitor &#123; constructor(private name: string) &#123;&#125; getName(): string &#123; return `LED: ` + this.name; &#125;&#125;class Oled implements Monitor &#123; constructor(private name: string) &#123;&#125; getName(): string &#123; return `Oled: ` + this.name; &#125;&#125;class MonitorDisplay &#123; display(monitor: Monitor) &#123; let myMonitor: Monitor = monitor; return myMonitor.getName(); &#125;&#125; if문 없이 코딩이 가능함 📝p236. getter/setter 사용 이유굳이 this.name = &#39;anything&#39; 처럼 멤버 변수를 사용하지 않고 get/set 키워드를 사용하는 이유 값을 설정하거나 읽을 때, 로직을 추가 가능(= 조건 추가 가능) 123456789get name(): string &#123; return this.studentName;&#125;set name(name: string) &#123; if (name.includes(`happy`)) &#123; this.studentName = name; &#125;&#125; ES5 변환시Object.defineProperty 참고 1234567891011121314Object.defineProperty(Student.prototype, `name`, &#123; get: function() &#123; return this.studentName; &#125;, set: function(name) &#123; if (name.includes(`happy`)) this.studentName = name; &#125;, enumerable: true, // true: 객체 키 열거 가능, default: false configurable: true // true: 이 속성 값 수정/삭제 가능, default: false&#125;)for (var prop in Student.prototype) &#123; console.log(prop); // 여기에 enumerable 하지 않으면 표시되지 않음&#125; 📝p240. staticstatic 키워드는 객체 생성 없이 접근 가능하므로 메모리 절약 효과 존재 객체 생성 없이 바로 접근 가능 static 멤버 변수는 인스턴스간 값 공유 12345678910111213class Circle &#123; static circleArea: number = 0; get area(): number &#123; return Circle.circleArea; // this가 아닌 Circle을 사용했음 &#125; static set area(pArea: number) &#123; Circle.circleArea = pArea; &#125;&#125;Circle.area = 100;let circle = new Circle();console.log(circle.area); // 100, 공유되는 것을 확인 📝p242. 싱글톤 패턴static 키워드를 활용하면 유일한 상태 정보 저장 가능 이렇게 하기위해서는 객체 생성을 막고, 클래스 변수, 메소드 등 모두를 static으로 선언 단일 상태 관리에는 좋지만, 인스턴스 생성은 불가능 생성법 부지런한 초기화 (eager initalization) - 클래스 선언시 초기화 게으른 초기화 (lazy initalization) - 메소드 호출시 초기화 Eager Initalization1234567891011class EagerLogger &#123; private static uniqueObj: EagerLogger = new EagerLogger(); // 내부에서 자체적 선언 // private를 붙여 인스턴스 생성 방지 private EagerLogger() &#123;&#125; // static으로 외부 접근 허용 public static getLogger(): EaggerLogger &#123; return this.uniqueObj; &#125;&#125; Lazy Initalization1234567891011121314class LazyLogger &#123; private static uniqueObj: LazyLogger; private LazyLogger() &#123;&#125; public static getLogger(): LazyLogger &#123; // 생성된 적이 없으면 새로 생성, 타입은 LazyLogger이므로 ==로 타입검사 피함 if (this.uniqueObj == null) &#123; this.uniqueObj = new LazyLogger(); &#125; return this.uniqueObj; &#125;&#125; 📝p247. readonly vs const const가 사용되는 곳은 readonly를 사용하지 못한다고 이해하면 편한 것 같다 특성 const readonly 상수 선언 가능 가능 초기화 강제성 필수 선택 값 재할당 불가능 가능(?) 선언 가능 대상 변수 멤버 변수객체 리터럴새타입 선언 불가능 대상 멤버 변수객체 리터럴새타입 변수 사용 용도 상수 읽기 전용 속성 컴파일 선언 유지 유지 사라짐 지원 표준 ES6 TS 2.0 📝p250. readonly 제거되는 경우type 에일리어싱시 사라짐 12345678910let emotion: &#123; readonly name: string &#125; = &#123; name: `sad` &#125;;function aliasing(pEmotion: &#123; name: string &#125;) &#123; pEmotion.name = `happy`;&#125;console.log(emotion.name); // sademotion.name = `happy`; // Erroraliasing(emotion);console.log(emotion.name); // happy, 변경됨","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 6장 정리","date":"2020-03-22T11:39:05.000Z","path":"wiki/Typescript quick start -6장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성했습니다. 6장 함수 목차 사용법 (Js vs Ts 비교) 매개변수 초기값 지정 ...rest 매개변수 선택 매개변수 지정 오버로드 익명 함수 화살표 함수 타입 선언 콜백 함수 📝p151. 함수 (Js vs Ts 비교)js의 경우12345678function max(x, y) &#123; return x &gt; y ? x : y;&#125;max(1, 10); // 10max(1, 10, 12); // 10, 이후 인자값은 무시당함max(`a`, `b`); // `b`max(`c`, `aaa`); //`c`, 으음... 문자열 첫번째값의 아스키 코드값인가? 결과 ts의 경우123456function max(x: number, y: number): number &#123; return x &gt; y ? x : y;&#125;max(1, 10); // 10max(1, 10, 12); // Error: 인자 개수 에러max(`a`, `b`); // Error: 인자 타입 에러 결과 📝p156. 매개변수 초기값ES6부터 매개변수의 값을 지정 받지 않아도, 초기값으로 값을 지정해줄 수 있게됨 코드도 간결해지고 complexity도 낮아짐 ES6 이전1234function test(param) &#123; param = param || `초기값`; console.log(param);&#125; ES6 이후123function test(param = `초기값`) &#123; console.log(param);&#125; 📝p159. 나머지 매개변수ES6부터 생긴 기능, 정의되지 않은 매개변수를 받기 편해짐 ES6 이전arguments는 잘 사용하지 않는 방식으로 알려짐 (보안) 123function test() &#123; console.log(arguments);&#125; ES6 이후123function test(...args) &#123; console.log(args);&#125; 나머지 매개변수 타입 지정법 나머지 매개변수도 타입 지정이 가능한 것을 처음 알았다 1234// 처음 1개 값을 지정하면, concat()같이 아무것도 받지않았을 때는 유효하지않음function concat(a: string, ...restStr: string[]): string &#123; return `$&#123;a&#125; $&#123;restStr.join(` `)&#125;`;&#125; 📝p162. 선택 매개변수js의 경우12345678function sum(a, b) &#123; console.log(arguments); return a + b;&#125;sum(1); // NaNsum(1, 2); // 3sum(1, 2, 3) // 3, 이후 파라미터를 사용되진 않지만, 받음 ts1234567function sum(a: number, b?: number): number &#123; return a + b;&#125;sum(1); // NaN, js와 결과는 동일sum(1, 2); // 3sum(1, 2, 3) // Error 인자 초과 📝p164. 함수 오버로드 잘 몰랐던 부분 함수명은 같지만, 매개변수와 반환 타입이 다른 여러개의 함수를 선언 가능, 런타임 비용이 별도 추가되지 않음 가장 일반적인 타입을 가장 아래에 선언(ex. any가 가장 아래), 위일 수록 구체적 (순서 중요!) 12345678function add(a: string, b: string);function add(a: number, b: number);function add(a: any, b: any): any &#123; return a + b;&#125;console.log(add(1, 2)); // 3console.log(add(`test1`, `test2`)); // test1test2 📝p170. 화살표 함수 유의점12345// bad caseconst test = x =&gt; &#123; x; &#125;; // block&#123;&#125;을 사용할 경우, 무조건 return이 필요함!// good caseconst test = x =&gt; &#123; return x; &#125;; 📝p171. filter, reduce filter MDN reduce MDN 📝p173. 객체 리터럴 선언 개인적으로 객체 지향적으로 짤 때 좋은 코딩 스타일이라고 생각되는 문법 12345678let person = &#123; name: `Taeuk`, hello: function (yourName) &#123; console.log(`Hello $&#123;yourName&#125;, I&#x27;m $&#123;this.name&#125;`); &#125;&#125;person.hello(`minsu`); 주의사항 function을 사용했기 때문에 this.name을 사용할 수 있었던 부분 만약 화살표 함수를 사용한다면 이렇게 뜰 것 이다. (현재는 this값이 window(최상위)로 잡은 케이스) Typescript에서 this 타입 선언 잘 몰랐던 부분 1234interface PersonType &#123; name: string; hello(this: PersonType, yourName: string): string;&#125; 📝p177. type 명명법 type는 대문자로 시작, 책은 소문자로 시작되서 이상해서 레퍼런스를 찾아봄 대문자로 시작하는게 표준 케이스인 것 같음 1type calcType = (a: number, b: number) =&gt; number; 📝p179. jquery -&gt; VanillaJS 음… 왜 굳이 예시를 Jquery로 들었는지 몰라서 작성 Jquery123$(`#myButton`).click(function() &#123; alert(`버튼`);&#125;) js123document.querySelector(`#myButton`).addEventListener(`click`, () =&gt; &#123; window.alert(`버튼`); &#125;); 📝 180. 콜백함수의 다른 예시(ex. Chrome API) Promise, async/ await 으로 바뀌는 추세이지만, 아직도 많은 부분에 callback 함수가 남아있다.","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Quick Start Typescript ~ 5장 정리","date":"2020-03-15T03:39:05.000Z","path":"wiki/Typescript quick start -5장/","text":"📖 Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성했습니다. Typescript 학습하는 목적으로 이해도가 높지 못해, 작성시 참고한 링크를 작성했습니다. 📝p134. 산술 연산자ES7의 지수 연산자(Math.pow)를 지원, **를 이용 사용 예시 1console.log(10 ** 3); // 1000 📝p136. 비교 연산자 다른 언어와 다르게, 자바스크립트는 === 등호 3개가 존재, ==와 다른 점은 ==은 값만 비교한다면 ===은 값과 타입을 비교하는 것이 다름 12&#x27;1&#x27; == 1; // true&#x27;1&#x27; === 1; // false 위 사항은 자바스크립트 또한 마찬가지지만, 타입스크립트는 같은 타입과의 비교만 지원한다. 📝p137. 논리 연산자 논리 연산자는 주로 변수 선언과 함께 함수 초기값 선언에 많이 사용된다. 사용 예시 12345678// 이런식으로 기본값이 없으면, default를 만든다. 라는 것으로 선언 가능const value: string = value || &#x27;default&#x27;;// 부정 연산자는 depth를 깊게하지 않기 위한, if문에 많이 사용됨if (!isLogin) &#123; console.error(`no login!`); location.href = `/login`; // login 라우팅으로 이동&#125; 📝p139 디스트럭처링종류 객체 디스트럭처링 배열 디스트럭처링 1. 객체 디스트럭처링1234let &#123; id, country = 88 &#125; = &#123; id: `happy` &#125;;console.log(id); // happyconsole.log(country); // 88 rename12345let &#123; id: newName1, country: newName2 &#125; = &#123; id: `happy`, country: 88 &#125;;console.log(newName1); // happyconsole.log(newName2); // 88console.log(id, country); // error Not defined 함수 파라미터 초기값 설정12345test(&#123; name: `happy` &#125;); // happy, none 출력function test(&#123; name, country = `none` &#125;) &#123; console.log(name, country);&#125; type 키워드 활용12345678type C = &#123; a: string, b?: number &#125;;fruit(&#123; a: `apple`, b: 10 &#125;); // apple 10fruit(&#123; a: `apple`&#125;); // apple undefinedfunction fruit(&#123; a, b &#125;: C) &#123; console.log(a, b);&#125; 2. 배열 디스트럭처링123456789101112131415161718192021222324let numbers = [`one`, `two`, `three`, `four`, `five`];// 이전 방식let num1 = numbers[0]; // onelet num2 = numbers[1]; // two// 이후 방식let [num1, num2] = numbers; // one, two// 결과 동일console.log(num1, num2); // one, two// 중간 빼오기let [, , num3, num4, ] = numbers;console.log(num3, num4); // three, four// 교체[num4, num3] = [num3, num4];console.log(num3, num4); // four, three// 초기값 지정let [color1, color2 = `blue`] = [`black`];console.log(color1, color2); // black blue 📝p146. 전개 연산자배열123let [first, ...second] = [1, 2, 3];console.log(first, second); // 1 2, 3 객체123let numGroup = &#123; n1: 1, n2: 2, n3: 3&#125;;let &#123; n2, ...n13 &#125; = numGroup;console.log(n2, n13); // 2 &#123; n1: 1, n3: 3&#125;;","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"즐겨찾기 정리 - 작성 중...","date":"2020-03-10T03:39:05.000Z","path":"wiki/즐겨찾기 정리/","text":"저의 개인적인 기준의 이야기, 틀린 내용이 무조건 존재할 수 있습니다. (댓글을 통하여 알려주세요) 레이아웃레이아웃은 현재 grid, flex 두 종류로 보통 구현한다. 이전에는 float을 활용하여 많이 짜긴했지만 큰틀은 이 두가지 종류를 통해 구현하는 것이 빠르고 유지보수가 쉽다. 그렇다면 무엇을 사용할까? 차이점이 무엇일까? 라고 생각이 들 것이다. 간단히 설명하면 flex는 width만 고려한 레이아웃이고, grid는 화면의 width, height을 고려한 레이아웃이다. 필요하다면 2가지 모두 다 사용해도 상관 없다. 그리고 height을 생각하여 어떤 것을 사용할지 고려도 해야겠지만, grid는 IE에서 부분 지원한다. 이 뜻은 css 속성으로 안먹는 값들이 많다. 아래의 출처 사이트 , 그러므로 당신의 사이트가 IE를 지원해야한다면, 마음 편히 flex를 이용하여 구현하라. autoprefixer을 이용하여 IE에서도 grid를 지원할 수 있지만, 실제 구현하는데 많은 이슈가 발생할 것이다. flex를 이용하여 구현하는 것이 훨씬 마음이 편할 것이다. (IE를 지원하지 않는게 사실 가장 마음 편함) 전부 읽지말고, 필요한 것만 읽기 관련 링크 To Grid or to Flex? flex flexbox로 만들 수 있는 10가지 레이아웃 CSS Flex(Flexible Box) 완벽 가이드 flex mdn flex - css trick grid IE에서 CSS 그리드 사용하기: CSS 그리드와 Autoprefixer 더 나은, 간단한 그리드 시스템 CSS Grid in IE: CSS Grid and the New Autoprefixer Box alignment in CSS Grid Layout Grid template areas CSS 그리드 레이아웃 grid MDN Grid layout을 만드는 몇 가지 기술들 CSS 그리드 레이아웃을 지금 사용해도 정말 괜찮을까 일어나고나니, 생각보다 즐겨찾기를 거의 저장해놓고 검색으로 들어간다는 사실을 깨달음 북마크 정리해줄 수 있는 기능을 만들어야겠는데… 필요기능 List 북마크 저장될 때마다, 최근 날짜 순으로 History 폴더 쌓기 단축키로 빠른 즐겨찾기 저장 강력한 검색 기능 빠른 즐겨찾기 파일 위치 바꾸기 (드래그) 즐겨찾기 폴더 만들기/ 삭제 정렬 기능이 필요함 (폴더별/ 전체 파일) 브라우저 화면에서 바로할 수 있어야함 깃허브, 비트버켓 이슈 연동이 같이 되면 좋겠음 즐겨찾기 이슈폴더 &lt;&gt; 이슈 코멘트 내용(참고링크) 양방향 바인딩 접기/펴기 마지막 상태 저장 +부가기능: 크롬과 웨일 같이 연동될 수 있으면 좋겠음 +부가기능: 깃허브 프로젝트 기능이 있었으면 좋겠음 CSS 단위기타 참고사항","tags":[{"name":"즐겨찾기","slug":"즐겨찾기","permalink":"https://taeuk-gang.github.io/tags/%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0/"}],"categories":[{"name":"즐겨찾기","slug":"즐겨찾기","permalink":"https://taeuk-gang.github.io/categories/%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0/"}]},{"title":"Quick Start Typescript ~ 4장 정리","date":"2020-03-08T03:39:05.000Z","path":"wiki/Typescript quick start -4장/","text":":book: Quick Start Typescript 을 읽고, 간단히 몰랐던 부분이나 중요하다고 생각되는 부분을 작성했습니다. Typescript 학습하는 목적으로 이해도가 높지 못해, 작성시 참고한 링크를 작성했습니다. 📝p39. package.json프론트엔드에서 가장 먼저 살펴보는 파일 package.json 번들러: webpack.config.js or vue.config.js JS 로더: tsconfig.json, babel.config.js or .babelrc CSS 로더: postcss.config.js index.html - JS/CSS/Font 삽입 보기 그외 Lint(코딩 컨벤션): eslintrc.js package.json 작성 개인적으로 중요하다고 생각되는 부분이나 몰랐던 부분만 정리 이 사이트 (공식)에서 자세히 설명되어있다. +한글 사이트 name주의사항: name에는 대문자를 포함해서는 안된다. version버전 관리는 아래와 같은 Rule이 존재 모르고 있던 부분 scripts 개인적으로 가장 package.json 파일을 열었을 때, 가장 먼저 보는 항목 참고링크 참고: npm-scripts 참고: npm-run-scripts 개발자가 설정해둔 커맨드 라인 명령어를 alias처럼 npm run &lt;key값&gt;으로 사용할 수 있다. 12345// package.json&quot;scripts&quot;: &#123; &quot;test:make&quot;: &quot;mkdir make-test-folder&quot;&#125; 123npm run test:make# mkdir make-test-folder 명령어가 실행되고, 현재 경로에 make-test-folder 디렉토리가 생긴다. dependencies실제 배포될 때 포함되는 패키지들 npm install or npm install --save 로 저장된 패키지들 devDependencies개발용으로 필요한 패키지들 (lint, test, bundle etc) npm install -D or npm install --save-dev로 저장된 패키지들 📝p40. npm 주요 명령어npm 주요 명령어를 짧게 칠 수 있다. (기본 aliases) 자주 사용하는 명령어라서 짧게 치면 편하다. 123456789101112131415# 이전npm install &lt;패키지명&gt;# 축약npm i &lt;패키지명&gt;# 여러 축약## 글로벌 설치npm i -g &lt;패키지명&gt;## devDependency 설치npm i -D &lt;패키지명&gt;## 삭제npm rm &lt;패키지명&gt; 그 외 명령어들 📝p48. tsconfig.json 설정타입스크립트 컴파일 옵션 정의된 파일 공식 홈페이지 참고: 간단히 정리된 블로그 removeComments의 경우 주석을 제거하여 컴파일 해주지만, 주석을 이용하여 webpack에서 번들링하는 경우가 존재하는 점을 유의 ex. /router/index.ts 1const DashboardView = () =&gt; import(/* webpackChunkName: &quot;dashboard&quot; */ &#x27;@/views/admin/dashboard/DashBoardView.vue&#x27;); 위와 같이 URL 라우팅별로, code split하여 특정 JS만 불러오게 하는 기능을 주석으로 처리할 수도 있다. *해당 라우팅으로 들어갔을 때, dashboard.js 파일만 불러오게하는 기능이다. 📝p76. 변수 선언 기존 JS(ES5) var 과 ES6에서 생긴 let, const 차이점이 중요 현재는 var은 잘 사용하지않는 편, 실제로 ESLint에서도 no-var option을 사용하여 사용 못하게 설정됨 var vs let, const 차이점 호이스팅 함수 레벨 스코프(var) vs 블록 레벨 스코프(const, let) 호이스팅 차이선언이 유효범위에서 최상단으로 이동하는 것 JS에서 대표적으로 호이스팅(끌어올림)으로 되는 것이 function과 var이 있다. 안되는 것으로는 class, const, let이 있다. 실질적으로는 const, let은 호이스팅은 된다. 선언은 되지만, 초기화가 필요해서 Error가 뜨는 것일 뿐이다. V8 엔진에 관심을 갖고 글을 읽던 중 알게 되었다. 참고 블로그 var의 경우12345678910// 개발 작성 코드var test = `global`; // 이렇게 할당된 변수는 window.test 객체로 할당된다.console.log(window.test); // `global`func();function func() &#123; console.log(test); // (A) 여기 표시값? var test = `local`; console.log(test); // (B) 여기 표시값? &#125; 1234567891011121314// 실제 실행되는 코드var test; test = `global`;console.log(window.test); // `global`function func() &#123; // 함수도 호이스팅 되는 것을 알 수 있다. var test; console.log(test); // (A) undefined test = `local`; console.log(test); // (B) `local` &#125;func(); (A) 부분에서 func내에서 지역변수로 test 변수가 호이스팅 했기 때문에 글로벌 변수 test를 가져오지 못하는 것을 알 수 있다. const, let의 경우1234567891011121314151617const testConst = `global-const`;let testLet = `global-let`;console.log(window.testConst); // undefined constconsole.log(window.testLet); // undefined let var과 다르게 window 객체에 할당되지 않는다.// func(); // Error, 아직 선언되지 않음const func = () =&gt; &#123;// console.log(testConst); // Error, 아직 선언되지 않음// console.log(testLet); // Error, 아직 선언되지 않음 const testConst = `local-const`; let testLet = `local-let`; console.log(testConst); // `local-const` console.log(testLet); // `local-let`&#125;func(); 함수 레벨 스코프(var) vs 블록 레벨 스코프(const, let)var의 경우12345678func();function func() &#123; // 변수 범위 = 함수 안 if (true) &#123; var test = `any`; &#125; console.log(test); // `any`&#125; const, let의 경우12345678910func();function func() &#123; if (true) &#123; // 변수 범위 = &#123;&#125; 블록 안 const testConst = `const`; let testLet = `let`; &#125; console.log(testConst); // Error, not defined console.log(testLet); // Error, not defined&#125; 📝p86. 타입 계층도 참고하면 좋은 링크 타입 체크가 Javascript에서 없던 부분이라 아직 많이 부족한 부분 any가장 상위에 있는 타입 primitive type string, number, boolean symbol enum 문자열 리터럴 Object Array Tuple Functopn 생성자 &lt;- ? Class Interface Union2개 이상의 타입 하나의 타입으로 지정 1const x: string | number; intersection두 타입을 합쳐 하나의 타입으로 만듦 12345678910interface Dog &#123; leg: number;&#125;interface Bird &#123; wing: number;&#125;let dogBird: Dog &amp; Brid = &#123; leg: number; wing: number;&#125; Primitive type(생략) string, number, booleansymbol유일하고 불변적인 식별자 (자세한 사항) ES6 이상에서부터 지원 1234let test = Symbol(`test`);let test2 = Symbol(`test`);console.log(test === test2); // false 사용처 12345const RED = Symbol();const YELLOW = Symbol();const ORANGE = Symbol();// 그 자체로 식별자 역할을 함 실제 개발상에서 사용해본 적이 없어서 아직 잘 모르겠다. 사용 사례에 대한 링크 type특정 문자열만 허용하는 타입 1type EventType = &quot;keyup&quot; | &quot;mouseover&quot;; enum123enum Color &#123; Red = 1, Green, Blue &#125;;let color: Color.Green;console.log(color); // 2 Object와의 차이점? (여기참고) object는 속성 자유롭게 변경 가능, enum은 그렇지 않음 enum은 항상 리터럴 타입 사용 enum의 속성값으로는 문자열 또는 숫자만 허용됨 사용 이유 123456789101112131415161718const korean = `ko`const english = `en`// 코드 중복type Language = `ko` | `en`// 코드기 길어짐type Language = typeof korean | typeof englishconst code: Language = korean// enum 사용시 가독성이 증가함enum Language &#123; korean = `ko`, english = `en`&#125;const code: Language = Language.korean Object TypeArrayarray type1let array; string[] = [`a`, `b`, `c`]; generic array type &lt;&gt;1let array: Array&lt;string&gt; = [`a`, `b`, `c`]; 차이점: primitive 타입 외에 object 타입도 받을 수 있다. 1let array: Array&lt;() =&gt; string&gt; = [() =&gt; `a`, () =&gt; `b`, () =&gt; `c`]; Tuplen개에 대한 배열 타입 1234let array: [string, number] = [`text`, 10];array = [1, `t`]; // error - 각 index에 대한 타입이 안맞음array = [`t`, 10, `e`, 1]; // error - index를 초과하여 받음 이번 장에서 다루지 않는 것들 생략 (생략) Function(생략) 생성자(생략) Class(생략) Interface📝p114 undefined !== nullundefined는 선언은 됬지만, 값이 할당되지 않은 상태 null은 선언과 값이 없다고 할당된 상태 12undefined === null; // falseundefined == null; // true === 비교 연산자는 type까지 값은지 체크해주지만, ==는 값만 체크 ex. 121 == `1`; // true1 === `1`; // false 📝p123 for … in 문 주의사항 이전에 이슈 걸렸던 사항으로 작성 for ... in 문은 없는 인덱스는 출력하지 않는다. ex. 123for (i in [1,,,4]) &#123; console.log(i);&#125; for ... of문은 출력","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"Javascript 성능 최적화","date":"2020-03-02T17:04:47.000Z","path":"wiki/Javascript 성능 최적화/","text":"목적이번 프로젝트에서 체감 성능은 느리지 않지만, Audit - Performance 가 좋지 않았다. 체감상으로 작업 기준을 맞추기는 힘드므로, Performance의 수치 중 하나가 일정 이상일까지는 성능 최적화를 하기로 결심했다. 쿠팡에서는 TTI가 2초를 넘기지 않게 노력한다고 한다. 그래서 나도 TTI 2초 미만으로 떨어질 때까지 최적화를 해보기로 결심했다. 진행사항node_modules 제거 후, 재설치고려사항 polyfill.js 파일 IE에 따른 선택적 삽입 (라우팅 쪽을 봐야하나?) 참고링크 프론트엔드 성능 최적화 구글 - 자바스크립트 성능 최적화 TOAST UI - 성능 최적화 구글 - TTI 관련 문서 Audit - web.dev Chrome - lighthouse Eliminate render-blocking resources Extract critical CSS","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"Optimize","slug":"Optimize","permalink":"https://taeuk-gang.github.io/tags/Optimize/"}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"}]},{"title":"Keycloak을 사용한 로그인 구현","date":"2020-03-01T17:04:47.000Z","path":"wiki/Keycloak을 사용한 로그인/","text":"목적Keycloak을 사용한 Client 관점의 로그인 구현 개발 일지 개인 학습 용도로, 틀린 요소가 있을 수 있음 참고 링크 백엔드 설치그래도 백엔드가 없으면, Client에서 되는지 안되는지 모르므로 간단하게 도커를 이용해 환경설정을 해준다. 1docker pull jboss/keycloak 1docker run -d -e KEYCLOAK_USER=&lt;USERNAME&gt; -e KEYCLOAK_PASSWORD=&lt;PASSWORD&gt; -p 8081:8080 jboss/keycloak 환경구성 끝 (세상이 좋아졌다…) 백엔드 설정설정 화면 들어가기 1. 버튼 클릭하기 2. 로그인 하기 1.realm 만들기 realm이 뭐지? 인증, 인가가 작동하는 범위SSO를 예로 들면 특정 클라이언트들이 공통적으로 속한 Realm에 한정되며, 기본적 으로 삭제가 불가능한 Master라는 Realm을 제공받음 Keycloak에서 Client Keycloack에게인증을 맡길 애플리케이션Web or REST API Service Keycloak에서 User Client에 로그인할 사용자하나의 Realm은 종속된 n개의 User를 관리기본적으로 User 개체는 Username, Email, First Name, Last Name 항목을 가짐 + Custom Attr 가능 Add realm (1) Add realm (2) 2. Client 추가 Client protocol 종류? openid-connect : 2014년에 개발된 더 새로운 표준 인증 서비스, Oauth 위에 놓임 saml : 인증 및 권한 부여 서비스를 제공하는 방법을 정의, Oauth 는 권한 부여만 처리, 멀티 도메인 위주? *Oauth와의 차이점 : 오쓰(OAuth)는 2006년부터 구글과 트위터에서 공동으로 개발한 SAML보다 다소 새로운 표준, 모바일에서의 SAML의 결함을 보완 / XML이 아닌 JSON 기반 으음 가볍게 openid-connect를 써주면 될 듯 반드시 Valid Redirect URIs를 http://localhost:8080/*로 할 것! 3. Client 설정2가지 키값이 중요하다. (Valid Redirect Url / Web Origin) 4. Realm settings - Login 설정 프론트엔드 설치기본 vue init 1vue create vue-keycloak keycloak-js 설치 (공식 라이브러리) 1npm i keycloak-js --save 프론트엔드 코드 작성src/main.js 작성 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import * as Keycloak from &#x27;keycloak-js&#x27;Vue.config.productionTip = false/* url: keycloak auth 도메인 realm: keycloak realm 이름, clientId: keycloak client 이름, onLoad: login-required 말고 다른 속성이 뭐가 있을까?*/let initOptions = &#123; url: `http://127.0.0.1:8081/auth`, realm: `accordion-keycloak`, clientId: `keycloak-client`, onLoad: `login-required`,&#125;;let keycloak = Keycloak(initOptions);init();function init() &#123; keycloak.init(&#123; onLoad: initOptions.onLoad, &#125;).success(auth =&gt; &#123; const ONE_MINUTE = 60000; if (!auth) &#123; window.location.reload(); &#125; else &#123; console.info(`Auth ok`); &#125; new Vue(&#123; render: h =&gt; h(App), &#125;).$mount(`#app`); localStorage.setItem(`vue-token`, keycloak.token); localStorage.setItem(`vue-refresh-token`, keycloak.refreshToken); window.setTimeout(refreshToken.bind(null, keycloak), ONE_MINUTE); &#125;).error(() =&gt; &#123; console.error(`Auth Fail`); &#125;)&#125;function refreshToken() &#123; keycloak.updateToken(70).success(refreshed =&gt; &#123; if (refreshed) &#123; successRefresh(refreshed); &#125; else &#123; warnRefresh(); &#125; &#125;).error(errorRefresh);&#125;function successRefresh(refreshed) &#123; console.debug(`Token refreshed $&#123;refreshed&#125;`);&#125;function warnRefresh() &#123; console.warn(`Token not refreshed, valid for $&#123;Math.round(keycloak.tokenParsed.exp + keycloak.timeSkew - new Date().getTime() / 1000)&#125; seconds`);&#125;function errorRefresh() &#123; console.error(&#x27;Failed to refresh token&#x27;);&#125; 결론FE에서 Vue.js를 사용하긴 했지만 별도 Vue 의존성이 있는건 아니라서, VanilaJS 또는 React에서도 바로 사용할 수 있을 것 같다. 또한, Client에서 사용이 어렵지않아, 쉽게 사용할 수 있을 것 같다. 그렇지만, Keycloak 객체에 어떤 메소드들이 있는지 정리할 필요성이 있다.(라이브러리를 사용함에는 그 기능을 완벽히 파악하는 것이 중요하기 때문에…) Javascript docs 참고링크Secure Vue.js app with Keycloak Vue + Keycloak github Keycloak을 이용한 SSO 구축 keyclaok github","tags":[{"name":"Keycloak","slug":"Keycloak","permalink":"https://taeuk-gang.github.io/tags/Keycloak/"},{"name":"Auth","slug":"Auth","permalink":"https://taeuk-gang.github.io/tags/Auth/"}],"categories":[{"name":"Auth","slug":"Auth","permalink":"https://taeuk-gang.github.io/categories/Auth/"},{"name":"Login","slug":"Auth/Login","permalink":"https://taeuk-gang.github.io/categories/Auth/Login/"}]},{"title":"Typora 신기능 - 이미지 자동 업로드","date":"2020-02-20T17:04:47.000Z","path":"wiki/Typora 신기능 - 이미지 자동 업로드/","text":"기능 설명Typora - Winodow 버전에 신기능이 업데이트됬다. 이전부터 Mac은 있던 기능인데 Window만 없었다.이미지를 삽입시, 자동으로 웹 서버에 올려주고 링크를 연결해주는 기능이다. Typora에서 사용 영상(GIF) 설정법1. Typora 메뉴 서식 - 이미지 - 전역 이미지 설정 으로 들어가기아래 Image Upload Setting 부분이 새로 추가된 기능 메뉴이다. 현재는 이미 셋팅된 상태이지만, 하기 전에는 Install 버튼을 따로 눌러 설치를 해야한다. 그리고 Uploader를 PicGo-Core로 설정 2. Open Config File 버튼을 누르고, config.json 설정그럼 config.json 파일이 뜰텐데, 현재 아무것도 설정되있지 않은 상태이다. 이미지를 업로드하기 좋은 곳이 어디있을까 생각하다가, github가 제일 좋을 것 같아 아래와 같이 설정할 수 있다. (* github repo 만드는 법은 생략) Github용 config.json 템플릿1234567891011121314151617181920&#123; &quot;picBed&quot;: &#123; &quot;current&quot;: &quot;github&quot;, &quot;github&quot;: &#123; &quot;repo&quot;: &quot;&lt;GITHUB USER_ID/REPO NAME&gt;&quot;, &quot;token&quot;: &quot;&lt;사용자 토큰 - 생성 법은 별도로 아래의 작성해뒀어요~&gt;&quot;, &quot;path&quot;: &quot;img/&quot;, &quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/&lt;GITHUB USER_ID&gt;/&lt;REPO NAME&gt;/image&quot;, &quot;branch&quot;: &quot;master&quot; &#125; &#125;, &quot;settings&quot;: &#123; &quot;showUpdateTip&quot;: true, &quot;autoStart&quot;: true, &quot;uploadNotification&quot;: true, &quot;miniWindowOntop&quot;: true &#125;, &quot;needReload&quot;: false, &quot;picgoPlugins&quot;: &#123;&#125;&#125; 예시 config.json1234567891011121314151617181920&#123; &quot;picBed&quot;: &#123; &quot;current&quot;: &quot;github&quot;, &quot;github&quot;: &#123; &quot;repo&quot;: &quot;taeuk-gang/save-image-repo&quot;, &quot;token&quot;: &quot;&lt;사용자 토큰 - 생성 법은 별도 아래에 작성&gt;&quot;, &quot;path&quot;: &quot;img/&quot;, &quot;customUrl&quot;: &quot;https://raw.githubusercontent.com/taeuk-gang/save-image-repo/image&quot;, &quot;branch&quot;: &quot;image &lt;마스터 커밋에 올리고 싶지않은 사람은 별도 브랜치를 생성&gt;&quot; &#125; &#125;, &quot;settings&quot;: &#123; &quot;showUpdateTip&quot;: true, &quot;autoStart&quot;: true, &quot;uploadNotification&quot;: true, &quot;miniWindowOntop&quot;: true &#125;, &quot;needReload&quot;: false, &quot;picgoPlugins&quot;: &#123;&#125;&#125; 이후, config.json 저장한 뒤 Typora에서 이미지를 삽입하면 Upload Image 버튼이 생긴 것을 확인 할 수 있다! (기타) Github 사용자 토큰 생성법1. Github setting 들어가기 2. Developer settings 들어가기 3. Personal access tokens 들어가기 4. Generate new token 버튼 클릭하여 토큰 생성! 설정은 아래와 같이 진행 (P.S 필요없는 권한이 있을 수 있음)","tags":[{"name":"문서화","slug":"문서화","permalink":"https://taeuk-gang.github.io/tags/%EB%AC%B8%EC%84%9C%ED%99%94/"},{"name":"Typora","slug":"Typora","permalink":"https://taeuk-gang.github.io/tags/Typora/"}],"categories":[{"name":"문서화","slug":"문서화","permalink":"https://taeuk-gang.github.io/categories/%EB%AC%B8%EC%84%9C%ED%99%94/"}]},{"title":"Vuex + Typescript 구성","date":"2020-02-20T17:04:47.000Z","path":"wiki/Vuex + Typescript/","text":"이 문서는 “타입스크립트, AWS 서버리스로 들어올리다” 책을 기반으로 작성되었습니다. 개요vuex는 vue 애플리케이션 상태관리 패턴 라이브러리이다. 부모 &lt;&gt; 자식 간 컴포넌트 통신(props, emit)으로, 모든 것을 처리하기에는 힘들기 때문에 만들어졌다. 구조 용어 설명 state: 변수 조회 getter: 변수 조회 (computed적 역할을 함) action: 변수 내용 변경, async같은 비동기적 처리가 가능 mutation: 변수 내용 변경, 동기적으로 이루어짐, state는 mutate를 통해서만 변경될 수 있다. dispatch: action 실행 commit: mutate 실행 mutate: state 변경 render: 컴포넌트 View 수정 Example Codesrc/store/Counter.ts1234567891011121314151617181920212223242526272829303132333435363738import &#123; Module, GetterTree, MutationTree, ActionTree, ActionContext &#125; from &#x27;vuex&#x27;;// state로 사용할 클래스export class Counter &#123; public count: number = 0;&#125;// state를 출력하면서, 표시를 다르게 하기위해 설정(state를 동시에 컴포넌트 이용시)const getters: GetterTree&lt;Counter, any&gt; = &#123; doubleCount(state: Counter): number &#123; return state.count; &#125;,&#125;;// state를 바로 변경할 수 없게함. 꼭 mutate를 통해 변경 가능const mutations: MutationTree&lt;Counter&gt; = &#123; increment(state: Counter, step: number) &#123; state.count = state.count + step; &#125;,&#125;// action은 지연된 상태 변경이 가능하다(비동기적 처리)const actions: ActionTree&lt;Counter, any&gt; = &#123; inc(state: ActionContext&lt;Counter, any&gt;, step: number) &#123; state.commit(`increment`, step); &#125;,&#125;// module간 state, getters, mutations, actions 따로 관리 가능하다.const Counter: Module&lt;Counter, any&gt; = &#123; namespaced: true, // &lt;- false일 경우, getters, mutations, actions의 이름을 공용으로 사용 state: new Counter(), getters, mutations, actions,&#125;;export default Counter; src/store.ts123456789101112131415import Vue from &#x27;vue&#x27;;import Vuex, &#123; Module &#125; from &#x27;vuex&#x27;;import Counter from &#x27;./store/Counter&#x27;; // &lt;- module importVue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123;&#125;, modules: &#123; // &lt;- module 등록 Counter, &#125;,&#125;);export default store; src/App.html (컴포넌트 - Template 부분)1234567891011121314&lt;h1&gt;Counter&lt;/h1&gt;&lt;p&gt;&#123;&#123; $store.state.Counter.count &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; $store.getters[`Counter/doubleCount`] &#125;&#125;&lt;/p&gt;&lt;p&gt; &lt;input type=&quot;button&quot; @click=&quot;$store.commit(&#x27;Counter/increment&#x27;, 1)&quot; value=&quot;+1 증가(Mutate)&quot; /&gt;&lt;/p&gt;&lt;p&gt; &lt;input type=&quot;button&quot; @click=&quot;$store.dispatch(&#x27;Counter/inc&#x27;, 2)&quot; value&lt;/p&gt; vuex는 $store을 통해 전역 사용 state 바로 접근법1$store.state.Counter.count getters 호출1$store.getters[&#96;Counter&#x2F;doubleCount&#96;] namepsaced가 설정되어있기 때문에, &lt;모듈이름&gt;/&lt;뮤테이션이름&gt;으로 구분한다. commit (mutations 호출)1$store.commit(`Counter/increment`, &#123;name: `Kang`, age: 26&#125;); commit 을 통해 mutations 호출 dispatch (actions 호출)1$store.dispatch(`Counter/inc`, 2); mapper컴포넌트에서 vuex가 많이 사용될 경우, 축약해서 사용할 수 있는 방법 그래도 위의 기본은 알고가자 src/App.ts123456789101112131415161718192021222324252627import Vue from &#x27;vue&#x27;;import Component from &#x27;vue-class-component&#x27;;import WithRender from &#x27;./App.html&#x27;;import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &#x27;vuex&#x27;;import &#x27;./App.scss&#x27;;@WithRender@Component(&#123; computed: &#123; // &lt;- state, gettes 등록 ...mapState(&#123; count: (state: any) =&gt; state.Counter.count, &#125;), ...mapGettes(&#123; doubleCount: `Counter/doubleCount`, &#125;), &#125;, methods: &#123; // &lt;- mutations, actions 등록 ...mapMuations(&#123; increment: `Counter/increment`, &#125;), ...mapActions(&#123; inc: `Counter/inc`, &#125;), &#125;,&#125;)export default Class App extends Vue &#123;&#125; src/App.html123456789&lt;h2&gt;Mapper&lt;/h2&gt;&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; doubleCount&#125;&#125;&lt;/p&gt;&lt;p&gt; &lt;input type=&quot;button&quot; @click=&quot;increment(1)&quot; value=&quot;+1 증가(mutation)&quot; /&gt;&lt;/p&gt;&lt;p&gt; &lt;input type=&quot;button&quot; @click=&quot;inc(2)&quot; value=&quot;+2 증가(action)&quot;&lt;/p&gt; mapper 장단점vuex를 간략하게 사용할 수 있지만, 직접적인 호출이 아니기 때문에 모르는 사람이 본다면 가독성, 이해도가 떨어질 수 있다. (고인물 생성) vue-property-decorators를 이용한 사용설치1npm i vuex-module-decorators src/store/Counter.ts12345678910111213141516171819202122232425import &#123; VuexModlue, Module, Mutation, Action &#125; from &#x27;vuex-module-decorators&#x27;;@Module(&#123; // &lt;- Module 데코레이터, 이 클래스 vuex 모듈로 사용가능 namespaced: true,&#125;)class Counter extends VuexModule &#123; // &lt;- VuexModule 상속 public count: number = 0; // &lt;- state로 매핑 get doubleCount(): number &#123; // &lt;- getters로 매핑 return this.count + 2; &#125; @Muation // &lt;- mutation public increment(step: number) &#123; this.count += step; &#125; @Action // &lt;- action public inc(step: number) &#123; return step; // &lt;- return값을 commit을 통해 전달함 &#125;&#125;export default Counter; 이것 또한 데코레이터를 다 외워야 함은 있지만, mapper보다 훨씬 가독성이 뛰어난 편으로 보여 사용성이 좋아보인다. Action 부분이 특이한데, return 값이 payload로 자동으로 commit으로 전달된다. Action내에서 다른 mutation 실행법 1this.context.commit(`increment`, step);","tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"},{"name":"Vue","slug":"Vue","permalink":"https://taeuk-gang.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://taeuk-gang.github.io/tags/Vuex/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"https://taeuk-gang.github.io/categories/Vue/"},{"name":"Vuex","slug":"Vue/Vuex","permalink":"https://taeuk-gang.github.io/categories/Vue/Vuex/"}]},{"title":"VS Code에서 서버 내 파일 작업하기","date":"2020-02-09T17:04:47.000Z","path":"wiki/Remote vscode 사용/","text":"VS Code에서 서버 내 파일 작업하기요약 VSCODE에서 플러그인 Remote Vscode 설치 연결할 서버에 서버용 모듈 설치 ssh 커맨더 명령어 입력 후 연결 rmate 명령어 사용 1. VSCODE에서 플러그인 Remote Vscode 설치 2. 연결할 서버에 서버용 모듈 설치서버 접속 (SSH)1ssh &lt;유저명&gt;@&lt;서버IP&gt; 설치123sudo wget -O /usr/local/bin/rmate https://raw.githubusercontent.com/aurora/rmate/master/rmatesudo chmod a+x /usr/local/bin/rmate 서버 연결 종료3. ssh 커맨더 명령어 입력후 연결12345# 구조ssh -L &lt;포트포워딩&gt; -R 52698:127.0.0.1:52698 &lt;유저명&gt;@&lt;서버IP&gt; -i &lt;GCP의 경우, 퍼블릭키&gt;# 예시ssh -L 80:0.0.0.0:8080 -R 52698:127.0.0.1:52698 taeuk1kang@34.84.202.87 -i ./taeuk1kang 4. rmate 명령어 사용이후, 접속된 서버 터미널에서 커맨드 사용 1234rmate &lt;파일경로&gt;# 예시rmate ./file.txt TIP. 가끔식 rmate 명령어 안될 때1234567# 52698 포트 사용 확인lsof -i tcp:52698# 포트 제거fuser -k -n tcp 52698# 이후, 서버 ssh 재접속","tags":[{"name":"SSH","slug":"SSH","permalink":"https://taeuk-gang.github.io/tags/SSH/"},{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/tags/Server/"},{"name":"Vscode","slug":"Vscode","permalink":"https://taeuk-gang.github.io/tags/Vscode/"}],"categories":[{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/categories/Server/"},{"name":"Vscode","slug":"Server/Vscode","permalink":"https://taeuk-gang.github.io/categories/Server/Vscode/"}]},{"title":"Vue Router 사용","date":"2020-01-28T10:04:47.000Z","path":"wiki/Vue-Router 사용/","text":"Vue RouterInstallCDN 또는 npm install을 통해 설치 CDN12&lt;script src&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;&#x2F;path&#x2F;to&#x2F;vue-router.js&quot;&gt;&lt;&#x2F;script&gt; NPM1npm install vue-router 123// main.tsimport router from &#x27;./router&#x27;; 123456// router/index.tsimport Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter) UseHtml1234567&lt;p&gt; &lt;!-- `&lt;router-link&gt;`는 `&lt;a&gt;` 태그로 렌더링--&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;&lt;/p&gt;&lt;!-- 렌더링 되는 장소 --&gt;&lt;router-view&gt;&lt;/router-view&gt; Typescript1234567891011121314151617181920212223242526272829// File: router/index.ts// 1. 모듈과 Home 템플릿 불러오기import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;import Home from &#x27;../views/Home.vue&#x27;;Vue.use(VueRouter)// 2. 라우트 정의const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: Home, &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;about&#x27;, component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;), &#125;,];// 3. VueRouter 만들기const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, routes,&#125;); 12345// File: main.ts// 4. mount 하기 (router 옵션을 전체 앱에 주입)const app = new Vue(&#123; router&#125;).$mount(`#app`) 12345678910111213141516171819&lt;!-- File: Home.vue --&gt;&lt;template&gt; &lt;div class&#x3D;&quot;home&quot;&gt; &lt;img alt&#x3D;&quot;Vue logo&quot; src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot;&gt; &lt;HelloWorld msg&#x3D;&quot;Welcome to Your Vue.js + TypeScript App&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; @ is an alias to &#x2F;srcimport HelloWorld from &#39;@&#x2F;components&#x2F;HelloWorld.vue&#39;;export default &#123; name: &#39;home&#39;, components: &#123; HelloWorld, &#125;,&#125;;&lt;&#x2F;script&gt; &lt;router-link&gt;는 현재 라우트와 일치할 때 자동으로 .router-link-active 클래스가 추가","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/categories/Vue-js/"}]},{"title":"Vue Init Template 구조 파악","date":"2020-01-28T06:26:47.000Z","path":"wiki/Vue-template/","text":"구조12345678910111213141516171819202122232425262728293031📦vue-pwa-tree ┣ 📂docker # Ngnix 환경에서 돌려질 도커 이미지 환경설정 ┣ 📂public # &#39;&#x2F;&#39; 경로 ┃ ┣ 📂img ┃ ┃ ┗ 📂icons # PWA Icon 폴더 ┃ ┣ 📜index.html # 시작 파일 ┣ 📂src # 작업 폴더 ┃ ┣ 📂assets # 리소스 ┃ ┣ 📂components # 공용 컴포넌트 ┃ ┣ 📂router # 라우터 ┃ ┣ 📂store # 상태관리 ┃ ┣ 📂views # 페이지 ┃ ┣ 📜App.vue # 시작 파일 ┃ ┣ 📜main.ts # 메인 ┃ ┣ 📜registerServiceWorker.ts # 서비스워커 ┃ ┣ 📜shims-tsx.d.ts # ? ┃ ┗ 📜shims-vue.d.ts # ? ┣ 📂tests # 테스트 코드 ┃ ┣ 📂e2e # e2e ┃ ┗ 📂unit # 유닛 테스트 ┣ 📜.dockerignore ┣ 📜.gitignore ┣ 📜babel.config.js ┣ 📜cypress.json ┣ 📜devspace.yaml ┣ 📜Dockerfile ┣ 📜Jenkinsfile ┣ 📜package-lock.json ┣ 📜package.json ┣ 📜README.md ┗ 📜tsconfig.json # 이건 좀 봐두자 흐름","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/categories/Vue-js/"}]},{"title":"Typescript 정리","date":"2020-01-21T05:54:56.000Z","path":"wiki/Book-Typescript-Serverless/","text":"책 읽고 도움될만한 것 정리 타입스크립트 Bash 명령어12345678# 설치npm i -g typescript# 컴파일tsc helloworld.ts# ts 컴파일 없이, 바로 실행 패키지 설치(ts-node)npm i -g ts-node# ts-node 실행ts-node helloworld.ts 타입스크립트 TypeBoolean, Number, String, Array, [Tuple], Enum, Any, Void, Never, (Object) Boolean1let isRun: boolean = false; Number12let decimal: number = 5;let hex: number = 0xff; String123let fullName: string = `Kang Taeuk`;let age: number = 11;let profile = `Full Name: $&#123;fullName&#125;, Age: $&#123;age&#125;` Array123let list: Number[] = [1,2,3];// orlet list: Array&lt;number&gt; = [1,2,3]; Tuple = 다양한, 섞여있는123let point: [string, number];point = [`x`, 10];point = [10, `x`]; // Error! 순서 상관있음 Enum123enum Color &#123; Red = 1, Green, Blue &#125;;let color: Color.Green;console.log(color); // 2 Enum은 C++, C#에서 많이 사용되는 개념 여기 자세하게 설명되어있어 좋았다 Object와의 차이점 object는 속성 자유롭게 변경 가능, enum은 그렇지 않음 enum은 항상 리터럴 타입 사용 enum의 속성값으로는 문자열 또는 숫자만 허용됨 enum 사용 이유 살펴보기123456789101112131415161718192021222324const korean = `ko`const english = `en`// 코드 중복type Language = `ko` | `en`// 코드기 길어짐type Language = typeof korean | typeof englishconst code: Language = korean// enum 사용시 가독성이 증가함enum Language &#123; korean = `ko`, english = `en`&#125;const code: Language = Language.korean// object도 이렇게하면 속성 변경시 컴파일 에러가 뜨긴함 (read-only가 되기 때문에)const language = &#123; korean: `ko`, english: `en`&#125; as const Any123let sure: any = 1;sure = `String`;sure = true; Void123function log(msg): void &#123; console.log(`Log: $&#123;msg&#125;`);&#125; Null, Undefined1let a: number = null; 다른 모든 타입의 하위타입으로 지정될 수 있음 (모든 타입은 null과 undefined가 될 수 있음) 타입스크립트 설정 --stictNullChecks이 켜져있다면, null이 지정되면 오류가 발생한다. Never절대 발생하지않는 값의 유형. Ex. 절대 리턴이 발생하지 않는 경우, 항상 예외값 등 123456789function error(message: string): never &#123; throw new Error(message);&#125;function forever(): never &#123; while (true) &#123; &#125;&#125; Object12let user: &#123; name: string; age: number; &#125; = &#123; name: `taeuk`, age: 12&#125;;console.log(user.name) Type alias이미 존재하는 타입에 다른 이름을 붙여 사용할 수 있게하는 기능이 존재 12345678910111213type UNIQID = string | nullfunction getUserID(id: UNIQID) &#123; console.log(id)&#125;getUserID(`id-abcd`)getUserID(null)getUserID(12) // error!// 특정값만 받게도 가능type USER_TYPE = `TESTER` | `ADMIN`let userType: USER_TYPE = `TESTER`userType = `asdf` // error! Function12345678910function sum(x: number = 10, y: number = 5, z?: number): number &#123; return x + y;&#125;function cites(name: string, ...rest:string[]) &#123; return name + `,$&#123;rest.join(`,`)&#125;`;&#125;let ourCites = cites(`seoul`, `busan`, `deagu`);console.log(ourCites); Interface컴파일할 때 타입을 체크하고 삭제됨 1234567891011121314151617181920212223interface Size &#123; width: number; height: number; version?: string;&#125;interface Label &#123; title: string; size: Size;&#125;function labelPrint(label: Label): void &#123; console.log(label);&#125;let myLabel = &lt;Label&gt;&#123; title: `Typescript Book`, size: &#123; width: 20, height: 30 &#125;&#125;labelPrint(myLabel); Class12345678910111213141516class Animal &#123; name: string; leges: number; constructor(name: string, legs: number = 4) &#123; this.name = name; this.legs = 4; &#125; info(): string &#123; return `$&#123;this.name&#125; has $&#123;this.legs&#125; legs`; &#125;&#125;let dog: Animal = new Animal(`Happy`);console.log(dog.info()); 접근제한자 public, private, protected, readonly자바스크립트에는 접근제한자 지원X, 그래서 실질적으로 컴파일 단계에서만 막아짐 publicpublic으로 선언된 멤버 변수나 메서드는 어느 곳에서나 접근이 가능 (명시하지 않았을 경우 default값이 public)클래스 인스턴스에서 홀로 접근이 가능하다. 12345678910111213141516class Test &#123; public test0: number; private test1: number; protected test2: number; constructor(test0: number, test1: number, test2: number) &#123; this.test0 = test0 this.test1 = test1 this.test2 = test2 &#125;&#125;const test = new Test(1,2,3)console.log(test.test0)console.log(test.test1) // compile err!console.log(test.test2) // compile err! privateprivate 해당 클래스 내부에서만 접근 가능 protected해당 클래스와 서브클래스에서만 접근이 가능 readonly읽기전용 속성자, getter/setter로만 생성, 설정 가능 123456789101112class Test &#123; readonly val: number = 5; readonly val2: number; constructor(val2: number) &#123; this.val2 = val2 &#125; public addVal() &#123; this.val2++ // error &#125;&#125; Getter/ Setter123456789101112131415class Test &#123; private _val: number = 5 get val() &#123; return this._val &#125; set val(value: number) &#123; this._val = value &#125;&#125;const test = new Test()test.val = 10console.log(test.val); static별도의 인스턴스가 아닌 클래스 전체에서 공유하는 값 1234567891011class Counter &#123; static count: number = 0 static increase() &#123; this.count++ &#125;&#125;console.log(Counter.count)Counter.increase()console.log(Counter.count)","tags":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/tags/Book/"},{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/tags/Vue-js/"}],"categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"}]},{"title":"쿠버네티스 + 젠킨스 설치해보기","date":"2020-01-16T08:15:23.000Z","path":"wiki/Kubernetes-jenkins/","text":"목표 쿠버네티스 환경에 젠킨스 설치하기 젠킨스 + Bitbucket 환경 구성하기 쿠버네티스 + 젠킨스 설치해보기예제 따라 진행 1. Kubernetes 클러스터 만들기GCP에서 쉽게 GUI로 클러스터 만들기 가능 2. cloud shell 활성화윈도우에서 진행하기에 어려움이 많아, gcp에서 제공하는 cloud shell을 사용하여 진행 항상 연결 명령어와 gcloud components update를 이용하여 최신 동기화할 것 config1gcloud container clusters get-credentials your-first-cluster-1 --zone us-central1-a --project taeuk-project 1git clone https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes.git 3. 클러스터 실행 확인 (확인할 것!)12345# 실행 확인gcloud container clusters list# 연결 가능한지 확인kubectl cluster-info 4. Helm 설치Helm 바이너리 파일 다운로드1wget https://storage.googleapis.com/kubernetes-helm/helm-v2.14.1-linux-amd64.tar.gz 압축풀기12tar zxfv helm-v2.14.1-linux-amd64.tar.gzcp linux-amd64/helm . 젠킨스 클러스터 관리자 추가12kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin \\ --user=$(gcloud config get-value account) 서버 Tiller에 cluster-admin 역할 부여123kubectl create serviceaccount tiller --namespace kube-systemkubectl create clusterrolebinding tiller-admin-binding --clusterrole=cluster-admin \\ --serviceaccount=kube-system:tiller Helm 초기화 &amp; 업데이트12./helm init --service-account=tiller./helm repo update 설치 확인1./helm version 5. Jenkins 설치Helm을 이용하여 설치1./helm install -n cd stable/jenkins -f jenkins/values.yaml --version 1.2.2 --wait 실행 확인1kubectl get pods Jenkins UI 포트 설정(8080 포트로 연결)123export POD_NAME=$(kubectl get pods --namespace default -l &quot;app.kubernetes.io/component=jenkins-master&quot; -l &quot;app.kubernetes.io/instance=cd&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)kubectl port-forward $POD_NAME 8080:8080 &gt;&gt; /dev/null &amp; Jenkins 서비스 생성 확인1kubectl get svc Jenkins 연결관리자 비밀번호 검색1printf $(kubectl get secret cd-jenkins -o jsonpath=&quot;&#123;.data.jenkins-admin-password&#125;&quot; | base64 --decode);echo 웹 미리보기를 통해, 젠킨스 출력 확인 6. Jenkins + Bitbucket 연결1. 블루오션 접속 후, 파이프라인 생성 버튼 클릭2. 소스관리를 BitBucket으로 설정 후 연결 7. JenkinsFile 작성Secret 생성 https://arisu1000.tistory.com/27844 이 곳 참고하여 작성 JenkinsFile을 작성하기에 앞서, docker login 커맨드를 사용하기 위해 username과 userpassword를 쿠버네티스 시크릿으로 생성해줘야 한다. 1kubectl create secret generic docker-hub-password --from-literal DOCKER_HUB_PASSWORD=&#x27;&lt;비밀번호&gt;&#x27; Secret 생성 확인1kubectl get secret user-pass-secret -o yaml 원래 값으로 확인하는 방법1echo &lt;bash64코드&gt; | base64 --decode JenkinsFile 작성12345678910111213141516171819202122232425262728293031323334353637podTemplate( label: &#39;mypod&#39;, volumes: [ emptyDirVolume(mountPath: &#39;&#x2F;etc&#x2F;gitrepo&#39;, memory: false), hostPathVolume(mountPath: &#39;&#x2F;var&#x2F;run&#x2F;docker.sock&#39;, hostPath: &#39;&#x2F;var&#x2F;run&#x2F;docker.sock&#39;) ], containers: [ containerTemplate(name: &#39;git&#39;, image: &#39;alpine&#x2F;git&#39;, ttyEnabled: true, command: &#39;cat&#39;), containerTemplate(name: &#39;docker&#39;, image: &#39;docker&#39;, command: &#39;cat&#39;, ttyEnabled: true, envVars: [secretEnvVar(key: &#39;DOCKER_HUB_PASSWORD&#39;, secretName: &#39;docker-hub-password&#39;, secretKey: &#39;DOCKER_HUB_PASSWORD&#39;)] ), containerTemplate(name: &#39;node&#39;, image: &#39;node:10-alpine&#39;, command: &#39;cat&#39;, ttyEnabled: true) ])&#123; node(&#39;mypod&#39;) &#123; stage(&#39;Clone repository&#39;) &#123; container(&#39;git&#39;) &#123; sh &#39;git clone -b master https:&#x2F;&#x2F;taeuk-gang@bitbucket.org&#x2F;taeuk-gang&#x2F;vue-template.git &#x2F;etc&#x2F;gitrepo&#39; &#125; &#125; stage(&#39;Unit Test source codes&#39;) &#123; container(&#39;node&#39;) &#123; sh &#39;cd &#x2F;etc&#x2F;gitrepo &amp;&amp; npm install&#39; sh &#39;cd &#x2F;etc&#x2F;gitrepo &amp;&amp; npm run test:unit&#39; &#125; &#125; stage(&#39;Build and push docker image&#39;)&#123; container(&#39;docker&#39;) &#123; sh &#39;docker login -u kangtaeuk -p $DOCKER_HUB_PASSWORD&#39; sh &#39;docker build &#x2F;etc&#x2F;gitrepo&#x2F; -t kangtaeuk&#x2F;vuepwa --no-cache&#39; sh &#39;docker push kangtaeuk&#x2F;vuepwa&#39; &#125; &#125; &#125;&#125; CronJob 설정 해당 프로젝트 설정으로 들어가 10분마다 빌드되게 구성 어째서인지 적용이 안된다. 그냥 Jenkinsfile에 추가해주자 123properties([ pipelineTriggers([cron(&#39;H&#x2F;15 * * * *&#39;)]),]) 전체 Jenkinsfile1234567891011121314151617181920212223242526272829303132333435363738394041properties([ pipelineTriggers([cron(&#39;H&#x2F;15 * * * *&#39;)]),])podTemplate( label: &#39;mypod&#39;, volumes: [ emptyDirVolume(mountPath: &#39;&#x2F;etc&#x2F;gitrepo&#39;, memory: false), hostPathVolume(mountPath: &#39;&#x2F;var&#x2F;run&#x2F;docker.sock&#39;, hostPath: &#39;&#x2F;var&#x2F;run&#x2F;docker.sock&#39;) ], containers: [ containerTemplate(name: &#39;git&#39;, image: &#39;alpine&#x2F;git&#39;, ttyEnabled: true, command: &#39;cat&#39;), containerTemplate(name: &#39;docker&#39;, image: &#39;docker&#39;, command: &#39;cat&#39;, ttyEnabled: true, envVars: [secretEnvVar(key: &#39;DOCKER_HUB_PASSWORD&#39;, secretName: &#39;docker-hub-password&#39;, secretKey: &#39;DOCKER_HUB_PASSWORD&#39;)] ), containerTemplate(name: &#39;node&#39;, image: &#39;node:10-alpine&#39;, command: &#39;cat&#39;, ttyEnabled: true) ])&#123; node(&#39;mypod&#39;) &#123; stage(&#39;Clone repository&#39;) &#123; container(&#39;git&#39;) &#123; sh &#39;git clone -b master https:&#x2F;&#x2F;taeuk-gang@bitbucket.org&#x2F;taeuk-gang&#x2F;vue-template.git &#x2F;etc&#x2F;gitrepo&#39; &#125; &#125; stage(&#39;Unit Test source codes&#39;) &#123; container(&#39;node&#39;) &#123; sh &#39;cd &#x2F;etc&#x2F;gitrepo &amp;&amp; npm install&#39; sh &#39;cd &#x2F;etc&#x2F;gitrepo &amp;&amp; npm run test:unit&#39; &#125; &#125; stage(&#39;Build and push docker image&#39;)&#123; container(&#39;docker&#39;) &#123; sh &#39;docker login -u kangtaeuk -p $DOCKER_HUB_PASSWORD&#39; sh &#39;docker build &#x2F;etc&#x2F;gitrepo&#x2F; -t kangtaeuk&#x2F;vuepwa --no-cache&#39; sh &#39;docker push kangtaeuk&#x2F;vuepwa&#39; &#125; &#125; &#125;&#125; 끝 지속적으로 테스트 및 배포를 하는 것을 알 수 있다. 참고링크Jenkins를 사용하여 Google Kubernetes Engine에 지속적으로 배포 Kubernetes Engine에서 Jenkins 사용 Google Kubernetes Engine에서 Jenkins 설정 174. [Kubernetes] 쿠버네티스에서 Jenkins CI와 Github Webhook를 이용한 도커 이미지 빌드 파이프라인 구축","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"}],"categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/"}]},{"title":"Vue.js 환경 구축 기록일지","date":"2019-12-28T09:23:12.000Z","path":"wiki/Vue-PWA/","text":"잠깐 여행을 다녀와서 해봐야겠다… Vue.js 환경 구축 기록일지목표 Vue.js 템플릿 사용 기본 문법 정리 Typescript 사용 Typescript 문법 정리 vue-cli 내용 정리 Vuex 라우팅 구축 nuxt.js 서버 사이드 렌더링 짜기 SCSS 환경 구축 Kubernetes 위에서 작동하기 (이해 필요) 외부 클러스터 연결 &amp; 사용하기 Git + Jenkins 연동 (쿠버 이후) 세부 목표: 젠킨스를 구축하면, Bitbucket으로 push시 테스트를 자동 검사 해야함. Jenkins pipeline 내용 정리 Progressive Web App 으로 작성 Mocha + StoryBook + Cypress 테스트 모듈 사용 ESLint Rule 짜기 스타일 가이드 정리 Vue.js 스타일 가이드 정리 TOAST FE 가이드 정리 Clean code 가이드 라인 정리 Kubernetes 이해개념 이해 없이 구축하려다보니, 뭔가 꼬이네… Kubernetes 구축1. GCP 프로젝트 생성2. 구글 클라우드 SDK(gcloud) 설치3. 쿠버네티스 클러스터 생성4. DB 구축5. API 구축6. 웹 어플리케이션 구축7. 웹 어플리케이션 노출8. * 클라우드없이 쿠버네티스 구축 (kuberspray)Kubernetes 사용법1.Vue 템플릿 사용설치123npm i -g @vue/clinpm update -g @vue/cli 프로젝트 생성1vue create vue-pwa-template Result: 생성 내 모듈 리스트1234567891011121314151617181920212223242526&quot;dependencies&quot;: &#123; &quot;core-js&quot;: &quot;^3.4.3&quot;, &quot;register-service-worker&quot;: &quot;^1.6.2&quot;, &quot;vue&quot;: &quot;^2.6.10&quot;, &quot;vue-router&quot;: &quot;^3.1.3&quot;, &quot;vuex&quot;: &quot;^3.1.2&quot; &#125;,&quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;^4.1.0&quot;, &quot;@vue/cli-plugin-e2e-cypress&quot;: &quot;^4.1.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;^4.1.0&quot;, &quot;@vue/cli-plugin-pwa&quot;: &quot;^4.1.0&quot;, &quot;@vue/cli-plugin-router&quot;: &quot;^4.1.0&quot;, &quot;@vue/cli-plugin-unit-mocha&quot;: &quot;^4.1.0&quot;, &quot;@vue/cli-plugin-vuex&quot;: &quot;^4.1.0&quot;, &quot;@vue/cli-service&quot;: &quot;^4.1.0&quot;, &quot;@vue/eslint-config-airbnb&quot;: &quot;^4.0.0&quot;, &quot;@vue/test-utils&quot;: &quot;1.0.0-beta.29&quot;, &quot;babel-eslint&quot;: &quot;^10.0.3&quot;, &quot;chai&quot;: &quot;^4.1.2&quot;, &quot;eslint&quot;: &quot;^5.16.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;, &quot;node-sass&quot;: &quot;^4.12.0&quot;, &quot;sass-loader&quot;: &quot;^8.0.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.6.10&quot;&#125;, Vue.js + Nginx Dockerfile 작성설치https://hub.docker.com/ 공식 홈페이지 참고 DockerFile 작성1234567891011121314151617# BuildFROM node:lts-alpine as build-stageWORKDIR /vue-pwa-projectCOPY package*.json ./RUN npm installCOPY . .RUN npm run build# ProductionFROM nginx:stable-alpine as production-stageRUN rm /etc/nginx/conf.d/default.confCOPY ./docker/nginx.conf /etc/nginx/conf.d/nginx.confCOPY --from=build-stage ./vue-pwa-project/dist /usr/share/nginx/htmlEXPOSE 80CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] *별도 nginx.conf12345678server &#123; listen 80; location / &#123; alias /usr/share/nginx/html/; try_files $uri $uri/ /index.html; &#125;&#125; docker build1docker build -t kangtaeuk/vue-template . 1docker run -it -p 8080:80 --rm kangtaeuk/vue-template Jenkins 환경 구축도커로 표준 젠킨스 서버 생성목표: jenkins/jenkins 이미지를 이용하여 컨테이너 생성 및 실행 1. 젠킨스 도커 이미지 가져오기123docker pull jenkins/jenkins# ordocker pull jenkins/jenkins:&lt;tag&gt; 2. 도커 볼륨 생성1docker volume create jenkins_home_classic 이후, 볼륨이 생성됬는지 확인하기 123docker volume lsdocker volume inspect jenkins_home_classic 3. 도커 실행1234docker run -d --name jenkins_classic \\-p 8081:8080 -p 50001:50000 \\-v jenkins_home_classic:/var/jenkins_home \\jenkins/jenkins 4. 브라우저 접속1http:&#x2F;&#x2F;&lt;docker IP&gt;:8081 블루오션이 없는 최신 버전 표준 젠킨스가 실행이 된다. 번외: VSCODE에서 Docker 플러그인을 사용하면 더 편하게 설치가 가능하다. 기존 젠킨스에 블루오션 설정하기1. Jenkins 관리 &gt; 플러그인 관리 &gt; 설치 가능에서 블루오션 설치 재시작 없이 설치하기 클릭 Tip. 젠킨스 재시작법http://&lt;젠킨스 URL:PORT&gt;/restart를 들어가면 재시작된다. Result 젠킨스 Ngnix 구성하기배경 젠킨스는 Ngnix 또는 Apache 같은 리버스 프록시 서버에서 운영하는 것이 일반적이다. 젠킨스 스레드를 차단하지 않고도 느린 클라이언트에 정적 파일을 전송 가능 젠킨스의 부하를 낮추기위해 정적 파일 캐싱, 서빙 수행 가능 Ngnix는 SSL 자원에 매우 효율적, 기본 제공되는 윈스턴 서블릿 컨테이너보다 더 좋음 실행법1. proxy_pass를 젠킨스의 IP와 포트로 직접 연결1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# ngnix *.conf 파일upstream jenkins &#123; keepalive 32; server 127.0.0.1:8080;&#125;server &#123; listen 80; server_name jenkins.example.com; root &#x2F;var&#x2F;run&#x2F;jenkins&#x2F;war&#x2F;; access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;jenkins&#x2F;access.log; error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;jenkins&#x2F;error.log; ignore_invalid_headers off; &#125;location &#x2F;userContent &#123; root &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;; if (!-f $request_filename) &#123; rewrite (.*) &#x2F;$1 last; break; &#125; sendfile on;&#125;location @jenkins &#123; sendfile off; proxy_pass http:&#x2F;&#x2F;jenkins; if ($request_uri ~* &quot;&#x2F;blue(&#x2F;.*)&quot;) &#123; proxy_pass http:&#x2F;&#x2F;jenkins&#x2F;blue$1; break; &#125; proxy_redirect default; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_max_temp_file_size 0; client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffering off; proxy_request_buffering off; proxy_set_header Connection &quot;&quot;;&#125;location &#x2F; &#123; if ($http_user_agent ~* &#39;(iPhone|iPad)&#39;) &#123; rewrite ^&#x2F;$ &#x2F;view&#x2F;iphone&#x2F; redirect; &#125; try_files $uri @jenkins;&#125; Nginx에서 젠킨스 블루오션 운영하기1. jenkins 컨테이너 실행1docker run -d --name jenkins -v jenkins_home:/var/jenkins_home jenkinsci/blueocean 젠킨스를 호스트 IP에 노출시키지 않음 2. Ngnix 도커 이미지 다운1docker pull nginx 3. Ngnix 도커 이미지 생성1docker run -d --name nginx -p 80:80 --link jenkins nginx --link 옵션을 통해 nginx 컨테이너를 젠킨스 컨테이너에 연결 4. docker exec 명령어 실행1docker exec -it nginx /bin/bash 5. 우분투 패키지 업데이트1apt-get update 6. /etc/ngnix/conf.d 백업 후 수정1cp etc/nginx/conf.d/default.conf etc/nginx/conf.d/default.conf.backup 12345678910111213141516upstream jenkins &#123; server jenkins:8080;&#125;server &#123; listen 80; server_name jenkins.example.com;&#125;location / &#123; proxy_pass http://jenkins; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme;&#125; 7. 컨테이너 재실행12exitdocker restart nginx 8. 젠킨스 접속http://&lt;도커 호스트 IP&gt; 로 접속 (http://&lt;도커 호스트 IP&gt;:8080으로 접속되선 안된다.) 기존 젠킨스 화면이 당신을 반겨준다면 성공! Jenkins Credentials 생성1. Jenkins Docker Image에 접속해서 ssh키 등록1234567891011# ssh 폴더 생성mkdir -p /var/lib/jenkins/.ssh# 이동cd /var/lib/jenkins/.ssh# ssh key 생성ssh-keygen -t rsa -f /var/lib/jenkins/.ssh/ssh_key# ssh_key.pub 복사cat ssh_key.pub 2. 복사한 ssh key를 젠킨스에 등록Jenkins 관리 &gt; Credentials &gt; global &gt; Add Credentials 버튼 클릭 Jenkins에 Docker 플러그인 설치Jenkins 관리 &gt; 플러그인 관리 &gt; 설치 가능 에서 Docker를 검색하여 설치 Docker 플러그인 설정 1. Cloud Tab에서 Docker 를 추가 2. Docker Host URI 알아내기3. Docker Cloud Details 버튼을 클릭 후 설정 이부분에 대한 이해가 완벽하지 않다. Jenkins + Bitbucket 연결1. 블루오션 접속 후, 파이프라인 생성 버튼 클릭2. 소스관리를 BitBucket으로 설정 후 연결","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/categories/Vue-js/"}]},{"title":"잠깐 Vue.js 문법 정리","date":"2019-12-24T14:57:07.000Z","path":"wiki/Vue-study/","text":"Vue.js 사용 안한지 오래되서, 한번 문법 정리하는 시간을 갖음. 한번 문법 정리 후, Codepen을 이용하여 예제 샘플 나열해서 정리해둬야겠다… 필수요소Link : https://kr.vuejs.org/v2/guide/installation.html 링크 학습 설치방법npm12# 최신 안정화 버전npm i vue cliLink: https://cli.vuejs.org/ 번들러번들러는 Vue.js + Webpack 템플릿 보면 알 수 있을 듯 시작하기선언적 렌더링템플릿 안 변수 삽입1&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: `#app`, data: &#123; message: `Hello, World` &#125;&#125;) v-bind = 단방향 바인딩 (v-dom -&gt; dom)12345&lt;div id=&quot;app-2&quot;&gt; &lt;span v-bind:title=&quot;message&quot;&gt; 텍스트 &lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: `#app-2`, data: &#123; message: `데이터: $&#123;new Date()&#125;` &#125;&#125;) 조건문 / 반복문조건문 v-if12345&lt;div id=&quot;app-3&quot;&gt; &lt;p v-if=&quot;seen&quot;&gt; seen의 bool값에 따라 보일지 결정됨 &lt;/p&gt;&lt;/div&gt; 123456var app = new Vue(&#123; el: `#app-3`, data: &#123; seen: true &#125;&#125;) 반복문 v-for1234567&lt;div id=&quot;app-4&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;todo in tods&quot;&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; 12345678910111213var app4 = new Vue(&#123; el: `#app-4`, data: &#123; todos: [ &#123;text: `Text1`&#125;, &#123;text: `Text2`&#125;, &#123;text: `Text3`&#125; ] &#125;&#125;)// 리스트 추가법// app4.todos.push(&#123;text: `Text4`&#125;) 사용자 입력 핸들링 v-on:event, v-modelv-on123456&lt;div id=&quot;app-5&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;onclickBtn&quot;&gt; 버튼 &lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: `#app-5`, data: &#123; message: `First Message.` &#125;, methods: &#123; onclickBtn: function () &#123; this.message = `Message Change!` &#125; &#125;&#125;) v-model = 양방향 바인딩1234&lt;div id=&quot;app-6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: `#app-6`, data: &#123; message: `Hello` &#125;&#125;) 컴포넌트 이용법123456Vue.component(`todo-item`, &#123; props: [`todo`] template: `&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;`&#125;)var app = new Vue(...) 123456789&lt;div id=&quot;app-7&quot;&gt; &lt;ol&gt; &lt;todo-item v-for=&quot;item in list&quot; v-bind:todo=&quot;item&quot; v-bind:key=&quot;item.id&quot; &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 123456789101112131415Vue.component(`todo-item`, &#123; props: [`todo`], template: `&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;`&#125;)var app7 = new Vue(&#123; el: `#app-7`, data: &#123; list: [ &#123;id: 0, text: `text1`&#125;, &#123;id: 1, text: `text2`&#125;, &#123;id: 2, text: `text3`&#125; ] &#125;&#125;) Vue 인스턴스vue 인스턴스 만들기1var vm = new Vue(&#123;&#125;) 속성과 메소드12345678910111213var data = &#123;a: 1&#125;var vm = new Vue(&#123; data: data&#125;)vm.a === data.a // truevm.a = 2data.a // =&gt; 2 (참조 복사임, swallow)data.a = 3vm.a // =&gt; 3 양방향임 Object.freeze()1234567891011var obj = &#123; foo: `bar`&#125;// obj가 변경되도 반영되지 않음Object.freeze(obj)new Vue(&#123; el: `#app`, data: obj&#125;) 123456&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;foo = &#x27;baz&#x27;&quot;&gt; Change &lt;/button&gt;&lt;/div&gt; $ 유용한 속성 및 메소드123456789101112var data = &#123;a: 1&#125;var vm = new Vue(&#123; el: `#example`, data: data&#125;)vm.$data === data // truevm.$el === document.querySelector(`#example`) // truevm.$watch(`a`, (newVal, oldVal) =&gt; &#123; // vm.a 메소드가 변경되면 호출됨&#125;) 인스턴스 라이프사이클 훅12345678910new Vue(&#123; data: &#123; a: 1 &#125;, created: function() &#123; // this는 vm 인스턴스를 가르킴 console.log(`a = $&#123;this.a&#125;`) &#125;, &#125;) beforeCreate가장 먼저 실행되는 훅 data, events(vm.$on, $once, $off, $emit) 세팅되지 않음 createddata와 events가 활성화된 시점 ~ 템플릿과 가상돔은 마운트·렌더링 되지 않음 beforeMount렌더링 일어나기 직전 mounted컴포넌트, 템플릿, 돔에 접근가능한 시점, 모든 하위 컴포넌트 마운트를 보장하지는 않음자식부터 차근차근 생성 후 부모가 생성되기 때문에 주의 (무조건, 순서대로 되지 않을 수도 있음) beforeUpdatedom이 새로 업데이트되기 직전 시점 updated재 렌더링 이후, 실행된다. 잘못 작성한다면 무한루프에 빠질 수 있음 beforeDestroy뷰 인스턴스 제거되기 직전 시점, 컴포넌트의 원래 형태를 그대로 유지된 상태이벤트 리스너를 제거하기 좋은 시점 destroyed인스턴스 제거 후 시점, vue의 모든 디렉티브 바인딩과 리스너가 제거 템플릿 문법interpolationv-once1&lt;span v-once&gt;한번 이후, 변경되지 않음 &#123;&#123; msg &#125;&#125;&lt;/span&gt; v-html12# rawHtml = `&lt;span style=&quot;color:red&quot;&gt;HTML&lt;/span&gt;`&lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt; 데이터 바인딩이 무시됨, Vue는 문자열 기반 템플릿 엔진은 아니여서, v-html을 이용한 템플릿을 사용할 수는 없음또한 XSS 취약점이 존재하기 때문에, 사용자 폼에서는 금지 v-bind:1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 1&lt;button v-bind:disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt; isButtonDisabled가 null, undefined, false면 속성으로 표시되지 않음 Javascript 표현식123456// 여러 표현식 사용 가능, 대신 구문은 작성 불가능(ex. 선언/if문은 작동하지 않음)&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(``).reserve().join(``) &#125;&#125; 1&lt;div v-bind:id=&quot;&#x27;last-&#x27; + id&quot;&gt;&lt;/div&gt; 디렉티브동적 전달인자 (2.6.0+부터 생김)123&lt;a v-bind:[attribueName]=&quot;url&quot;&gt;...&lt;/a&gt;&lt;a v-on:[attribueName]=&quot;function&quot;&gt;...&lt;/a&gt; 대신 스페이스나 따옴표를 쓰지말 것, 또한 소문자만 쓰는 것이 좋음 12&lt;!-- 컴파일러 경고를 불러옵니다 --&gt;&lt;a v-bind:[&#x27;foo&#x27; + bar]=&quot;value&quot;&gt; ... &lt;/a&gt; preventDefault()1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; 약어v-bind 약어12345678&lt;!-- 전체 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 약어 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 동적 --&gt;&lt;a :[key]=&quot;url&quot;&gt;...&lt;/a&gt; v-on 약어12345678&lt;!-- 전체 --&gt;&lt;a v-on:click=&quot;function&quot;&gt;...&lt;/a&gt;&lt;!-- 약어 --&gt;&lt;a @click=&quot;function&quot;&gt;...&lt;/a&gt;&lt;!-- 동적 --&gt;&lt;a @[event]=&quot;function&quot;&gt;...&lt;/a&gt; computed와 watchcomputed 배경너무 많은 템플릿 내 표현식은 유지보수가 힘듬 1234&lt;!-- 어려움 --&gt;&lt;div id=&quot;example&quot;&gt; &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;/div&gt; computed 예제1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;원본: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;역순: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt; &lt;/div&gt; 1234567891011var vm = new Vue(&#123; el: `#example`, data: &#123; message: `안녕` &#125;, computed: &#123; reversedMessage: function() &#123; return this.message.split(``).reverse().join(``) &#125; &#125;&#125;) computed vs method차이점: computed는 종속 대상이 변경될 때만 함수를 실행하고, 변경되지 않으면 그 이전 계산했던 값을 돌려줌Date.now()처럼 아무곳에 의존되지 않은 값은 업데이트 되지 않음 이것과 비교하여 method는 항상 함수를 재실행함 computed vs watch1&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; 비교(watch) 12345678910111213141516var vm = new Vue(&#123; el: `#demo`, data: &#123; firstName: `TAEUK`, lastName: `KANG`, fullName: `TAEUK KANG` &#125;, watch: &#123; firstName: function(val) &#123; this.fullName = val + ` ` + this.lastName &#125;, lastName: function(val) &#123; this.fullName = this.firstName + ` ` + val &#125; &#125;&#125;) computed 123456789101112var vm = new Vue(&#123; el: `#demo`, data: &#123; firstName: `TAEUK`, lastName: `KANG` &#125;, computed: &#123; fullName: function() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;` &#125; &#125;&#125;) computed(setter)computed는 기본적으로 getter함수이지만, setter로 지정하여 만들 수 있음 1234567891011121314computed: &#123; fullName: &#123; // getter get: function() &#123; return `$&#123;this.firstName&#125; $&#123;this.lastName&#125;` &#125;, // setter set: function(newValue) &#123; var names = newValue.split(` `) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; vm.fullName = TAEUK KANG 실행하면, 업데이트가 되는 것을 볼 수 있음 watch비동기식 또는 시간이 많이 소요되는 조작을 수행하려는 경우에 가장 유용 1234567&lt;div id=&quot;watch-example&quot;&gt; &lt;p&gt; yes/no ? &lt;input v-model=&quot;question&quot;&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435// axios, lodash 사용 예제var watchExampleVM = new Vue(&#123; el: `#watch-example`, data: &#123; question: ``, answer: `대답 미입력` &#125;, watch: &#123; question: function(newQuestion) &#123; this.answer = `입력 대기 중...` this.getAnswer() &#125; &#125;, methods: &#123; // _.debounce는 lodash가 제공하는 기능, 시간이 많이 소요되는 작업에 실행 빈도를 제한 getAnswer: _.debounce( function() &#123; if (this.question.indexOf(`?`) === -1) &#123; this.answer = `질문에 물음표를 넣어줘` return &#125; this.answer = `생각 중...` var vm = this axios.get(`api url`).then(res =&gt; &#123; vm.answer = _.capitalize(res.data.answer) &#125;).catch(err =&gt; &#123; vm.answer = `Err! $&#123;err&#125;` &#125;) &#125;, // 사용자가 기다리는 시간(ms) 500 ) &#125;&#125;) 클래스와 스타일 바인딩클래스 동적 토글1&lt;div v-bind:class=&quot;&#123; active isActive &#125;&quot;&gt;&lt;/div&gt; 1234&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; active: isActive, &#x27;test-danger&#x27;: hasError&#125;&quot;&gt;&lt;/div&gt; 1234data: [ isActive: true, hasError: false] 결과값: 1&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt; 굳이 인라인 스크립트를 쓰지 않아도 됨 1&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, &#x27;text-danger&#x27;: false &#125;&#125; 12345678910111213// computed도 가능data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function () &#123; return &#123; active: this.is Active &amp;&amp; !this.error, &#x27;text-danger&#x27;: this.error &amp;&amp; this.error.type === &#x27;fatal&#x27; &#125; &#125;&#125; 배열1&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt; 1234data: &#123; activeClass: `active`, errorClass: `text-danger`&#125; Result:1&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt; 삼항연산자1&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt; 1&lt;div v-bind:class=&quot;[&#123;active: isActive&#125;, errorClass]&quot; 컴포넌트Vue 컴포넌트의 기존 클래스가 덮어쓰기 되지않고, 추가됨. 바인딩도 마찬가지 123Vue.component(`my-component`, &#123; template: `&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;`&#125;) 1&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt; Result:1&lt;p class=&quot;foo bar baz boo&quot;&gt;&lt;/p&gt; 인라인 스타일 바인딩b-bind:style속성 이름에 camelCase와 kebab-case (따옴표를 함께 사용해야 합니다)를 사용 1&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27;&#125;&quot;&gt;&lt;/div&gt; 1234data: &#123; activeColor: `red`, fontSize: 30&#125; 데이터 밑 객체를 삽입하여 간결하게 1&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: `red`, fontSize: `13px` &#125;&#125; 12&lt;!-- 여러 스타일시트 사용 가능 --&gt;&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt; 자동 접두사1&lt;div v-bind:style=&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;&gt;&lt;/div&gt; 그런데 그냥 PostCSS의 autoPrefixer을 쓰는게 편해보임. 조건부 렌더링v-if, v-else1234567&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt;&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;B&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;C&lt;/div&gt;&lt;div v-else&gt;Not A/B/C&lt;/div&gt; v-else 엘리먼트는 v-if 엘리먼트 또는 v-else-if 엘리먼트 바로 뒤에 있어야 합니다. 그렇지 않으면 인식할 수 없습니다. &lt;template&gt;의 v-if123456789101112&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt;&lt;/template&gt;&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt; &lt;label&gt;사용자 이름&lt;/label&gt; &lt;input placeholder=&quot;사용자 이름을 입력하세요&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;이메일&lt;/label&gt; &lt;input placeholder=&quot;이메일 주소를 입력하세요&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; key 속성이란, “이 두 엘리먼트는 완전히 별개이므로 다시 사용하지 마십시오.”라고 알리는 행위 없으면 input 엘리먼트를 재사용함 v-show1&lt;h1 v-show=&quot;ok&quot;&gt;안녕하세요!&lt;/h1&gt; v-if와 다른 점은 항상 DOM에 남겨져 있고, css의 display 상태로만 감춰져있음그러므로, 매우 자주 바뀌는 렌더링 비용은 v-show를 이용하는 것을 권장 주의사항 v-for우선순위v-for가 v-if보다 높은 우선순위 권을 갖기 때문에 사용에 주의할 것 리스트 렌더링123&lt;ul id+&quot;example-1&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt;&#123;&#123; index &#125;&#125;: &#123;&#123; item.message &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 12345678var example1 = new Vue(&#123; data: &#123; items: [ &#123; message: `item1`&#125;, &#123; message: `item2`&#125; ] &#125;&#125;) in 대신 of 반복문도 사용 가능 (차이점은 일반적인 JS문법과 동일: in은 key값을 순회, of는 value값을 순회) v-for와 객체123&lt;ul id&#x3D;&quot;v-for-object&quot; class&#x3D;&quot;demo&quot;&gt; &lt;li v-for&#x3D;&quot;(value, key, index) in object&quot;&gt;&#123;&#123;index&#125;&#125;. &#123;&#123;key&#125;&#125;: &#123;&#123;value&#125;&#125;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; 12345678910new Vue(&#123; el: `#v-for-object`, data: &#123; object: &#123; title: `제목`, author: `저자`, publishedAt: `2019-12-29` &#125; &#125;&#125;) Result1230. title: 제목1. author: 저자2. publishedAt: 2019-12-29 주의점객체 순서가 일관적이지 않음. Object.keys()의 결과에 따름. Maintaining State이벤트 핸들링폼 입력 바인딩컴포넌트컴포넌트 모아보기컴포넌트 등록Props커스텀 이벤트슬롯(slots)동적 &amp; 비동기 컴포넌트Handling Edge Cases트랜지션 &amp; 애니메이션진입/진출? 봐야알 듯상태 트랜지션재사용 &amp; 컴포지션믹스인사용자 지정 디렉티브Render Functions &amp; JSX플러그인사용법12345Vue.use(MyPlugin)new Vue(&#123; &#x2F;&#x2F; ...options&#125;) Vue.use는 자동으로 같은 플러그인 중복사용을 방지함 (한번만 설치됨) 작성법 추후 작성 필터도구싱글 파일 컴포넌트단위 테스팅Typescript배포스케일링 업라우팅상태 관리서버사이드 렌더링Security내부반응형","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/tags/Vue-js/"}],"categories":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/categories/Vue-js/"}]},{"title":"PWA-Starter-Kit 요약","date":"2019-10-25T12:16:18.000Z","path":"wiki/Js-pwa-starter-kit/","text":"PWA-Starter-Kit 감상문router.js12345// IMPORTimport &#123; installRouter &#125; from &#x27;pwa-helpers/router.js&#x27;;// ROUTINGinstallRouter((location) =&gt; handleNavigation(location)); 123456// IMPORTimport &#123; installRouter &#125; from &#x27;pwa-helpers/router.js&#x27;;import &#123; navigate &#125; from &#x27;../actions/app.js&#x27;;// ROUTINGinstallRouter((location) =&gt; store.dispatch(navigate(location))); 12window.history.pushState(&#123;&#125;, &#x27;&#x27;, &#x27;/new-route&#x27;);handleNavigation(window.location); 1234567installRouter((location, event) =&gt; &#123; // Only scroll to top on link clicks, not popstate events. if (event &amp;&amp; event.type === &#x27;click&#x27;) &#123; window.scrollTo(0, 0); &#125; handleNavigation(location);&#125;); network.js12345import &#123; installOfflineWatcher &#125; from &#x27;pwa-helpers/network.js&#x27;;installOfflineWatcher((offline) =&gt; &#123; console.log(&#x27;You are &#x27; + offline ? &#x27; offline&#x27; : &#x27;online&#x27;);&#125;); 네트워크 이벤트 리스너가 있지만, 굳이 쓰는 이유는 모르겠넴하지만 좋은게 좋은거니 쓴다. metadata.js12345678import &#123; updateMetadata &#125; from &#x27;pwa-helpers/metadata.js&#x27;;updateMetadata(&#123; title: &#x27;My App - view 1&#x27;, description: &#x27;This is my sample app&#x27;, url: window.location.href, image: &#x27;/assets/view1-hero.png&#x27;&#125;); 메타데이터 수정, 유용하네 media-query.js12345import &#123; installMediaQueryWatcher &#125; from &#x27;pwa-helpers/media-query.js&#x27;;installMediaQueryWatcher(`(min-width: 600px)`, (matches) =&gt; &#123; console.log(matches ? &#x27;wide screen&#x27; : &#x27;narrow sreen&#x27;);&#125;); 오, 미디어 쿼리에 따른 자바스크립트 사용은 정말 좋다 axe-report.js12345678910import &#x27;axe-core/axe.min.js&#x27;;import &#123; axeReport &#125; from &#x27;pwa-helpers/axe-report.js&#x27;;describe(&#x27;button&#x27;, function() &#123; it(&#x27;is accessible&#x27;, function() &#123; const button = document.createElement(&#x27;button&#x27;); button.textContent = &#x27;click this&#x27;; // Test should fail without this line. return axeReport(button); &#125;);&#125;); Test Code 작성법이구만… connect-mixin.js1234567import &#123; connect &#125; from &#x27;pwa-helpers/connect-mixin.js&#x27;;class MyElement extends connect(store)(HTMLElement or LitElement) &#123; stateChanged(state) &#123; this.textContent = state.data.count.toString(); &#125;&#125; 엘리먼트에 걸어둔 this.value값을 리덕스값과 연동하는 것이 좋네 lazy-reducer-enhancer.js12345678import &#123; combineReducers &#125; from &#x27;redux&#x27;;import &#123; lazyReducerEnhancer &#125; from &#x27;pwa-helpers/lazy-reducer-enhancer.js&#x27;;import someReducer from &#x27;./reducers/someReducer.js&#x27;;export const store = createStore( (state, action) =&gt; state, compose(lazyReducerEnhancer(combineReducers))); 123store.addReducers(&#123; someReducer&#125;);","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"}]},{"title":"서비스 워커 학습 일지","date":"2019-09-27T13:51:30.000Z","path":"wiki/Js-serviceWorker/","text":"서비스 워커 학습 일지오프라인, 주기적 백그라운드 동기화, 푸쉬알람 등이 웹에서 지원이 됨서비스 워커는 이런 기능들의 기반을 제공 정의서비스 워커 = 백그라운드에서 실행되는 스크립트 웹페이지와 별개로 작동 사용자 상호작용이 필요하지 않은 기능에 대해 서비스 제공 유의 사항 DOM에 직접 액세스할 수 없음대신 postMessage 방식으로 메시지 응답 네트워크 프록시, 페이지의 네트워크 요청 처리 방법을 제어 가능 onfetch, onmessage 핸들러를 통해, 사용하지 않을 때는 종료하고 필요할 때 실행 가능 재사용 정보의 경우, indexedDB를 통해 사용 프라미스가 많이 사용됨 HTTPS를 사용해야함 수명 주기수명주기 또한, 웹 페이지와 별개임 서비스 워커를 사이트에 설치하려면, 페이지에서 자바스크립트를 등록 123456789101112131415161718192021&lt;script&gt; if (&#x27;serviceWorker&#x27; in navigator) &#123; navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;); &#125;&lt;/script&gt;or&lt;script&gt;if (&#x27;serviceWorker&#x27; in navigator) &#123; window.addEventListener(&#x27;load&#x27;, function() &#123; navigator.serviceWorker.register(&#x27;/sw.js&#x27;).then(function(registration) &#123; // Registration was successful console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope); &#125;, function(err) &#123; // registration failed :( console.log(&#x27;ServiceWorker registration failed: &#x27;, err); &#125;); &#125;);&#125;&lt;/script&gt; register()페이지를 로드할 때마다, register() 호출 가능 주의점서비스 워커가 위치한 파일 위치를 root로 fetch가 작동함 ex. /example/sw.js에 위치를 등록하면, /example/ URL에서만 fetch이벤트를 처리 확인chrome://inspect/#service-workers에서 확인 가능 설치123self.addEventListener(&#x27;install&#x27;, function(event) &#123; // Perform install steps&#125;); install 콜백 안에서 다음 절차를 수행해야 합니다. 캐시를 엽니다. 파일을 캐시합니다. 필요한 모든 자산이 캐시되었는지 확인합니다. 1234567891011121314151617var CACHE_NAME = &#x27;my-site-cache-v1&#x27;;var urlsToCache = [ &#x27;/&#x27;, &#x27;/styles/main.css&#x27;, &#x27;/script/main.js&#x27;];self.addEventListener(&#x27;install&#x27;, function(event) &#123; // Perform install steps event.waitUntil( caches.open(CACHE_NAME) .then(function(cache) &#123; console.log(&#x27;Opened cache&#x27;); return cache.addAll(urlsToCache); &#125;) );&#125;); 흐음… 이건 사용해봐야 알겠는데? 원하는 캐시 이름을 사용 caches.open()을 호출하여, cache.addAll()을 호출하여 파일 배열 전달 event.waitUntil()메서드는 설치 소요 시간 및 설치 성공여부를 확인 모든 파일이 성공적으로 캐시되면 서비스 워커가 설치됩니다.어느 파일 하나라도 다운로드하지 못하면 설치 단계가 실패합니다. 으음… 지금 문서 요약은 가능해도, 실제 코딩과 결합해봐야 알겠는데… 서비스 워커로 js 파일을 관리하는 웹사이트가 있어서 공부해볼려 했는데, 그 사이트부터 분석해봐야겠다. 서비스 워커 이용 사이트 요청 캐시 및 반환서비스 워커 업데이트이슈","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"ServiceWorker","slug":"ServiceWorker","permalink":"https://taeuk-gang.github.io/tags/ServiceWorker/"}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"}]},{"title":"lit-element 요약본","date":"2019-09-07T03:15:22.000Z","path":"wiki/Js-lit-element-summary/","text":"실제 써먹을 것 Code만 간략히 적기 lit-element 개발환경lit-element 모듈 설치1npm install lit-element Javascript 작성123456789101112131415import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; // lit-element관련 및 이벤트핸들러 입력 영역 render()&#123; return html` &lt;p&gt;A paragraph&lt;/p&gt; `; &#125; // 커스텀 함수 입력 영역&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 불러오기HTML1&lt;script type=&quot;module&quot; src=&quot;/path/to/my-element.js&quot;&gt;&lt;/script&gt; Javascript1import &#x27;./my-element.js&#x27;; babel 설정설치123npm install --save-dev @babel/corenpm install --save-dev @babel/plugin-proposal-class-propertiesnpm install --save-dev @babel/plugin-proposal-decorators babel.config.js 설정123456const plugins = [ &#x27;@babel/plugin-proposal-class-properties&#x27;, [&#x27;@babel/plugin-proposal-decorators&#x27;, &#123; decoratorsBeforeExport: true &#125; ],];module.exports = &#123; plugins &#125;; 주의사항 lit-element은 virtual Dom과 다르지만, Dom을 완전히 직접 조작하는 것은 비효율적이다.(가변형 데이터는 prop으로 관리하라) 사용하기prop12345static get properties() &#123; return &#123; myProp: String // converter, type, attribute, reflect, noAccessor, hasChanged; &#125;;&#125; converter12345678910prop1: &#123; converter: &#123; fromAttribute: (value, type) =&gt; &#123; // attr 변경시 실행 &#125;, toAttribute: (value, type) =&gt; &#123; // prop 변경시 실행 &#125; &#125;&#125; type1234567static get properties() &#123; return &#123; prop1: &#123; type: String &#125;, prop2: &#123; type: Number &#125;, prop3: &#123; type: Boolean &#125; &#125;&#125; attribute (attr -&gt; prop)12345678// Observed attribute will be called my-propmyProp: &#123; attribute: &#x27;my-prop&#x27; &#125;// No observed attribute for this propertymyProp: &#123; attribute: false &#125;// observed attribute for this property (default)myProp: &#123; attribute: true &#125; reflect (prop -&gt; attr)1myProp: &#123; reflect: true &#125; noAccessor123static get properties() &#123; return &#123; myProp: &#123; type: Number, noAccessor: true &#125; &#125;; &#125; noAccessor가 true면, prop이 getter와 setter 접근자에 의해 변경된다.noAccessor가 false면 getter와 setter가 사용되지 않는다. hasChanged1myProp: &#123; hasChanged: true &#125; true가 반환되면, update를 실행한다.false가 반환되면, 변화가 없다는 뜻이다. 12345678910111213myProp: &#123; type: Number, hasChanged(newVal, oldVal) &#123; if (newVal &gt; oldVal) &#123; console.log(`$&#123;newVal&#125; &gt; $&#123;oldVal&#125;. hasChanged: true.`); return true; &#125; else &#123; console.log(`$&#123;newVal&#125; &lt;= $&#123;oldVal&#125;. hasChanged: false.`); return false; &#125; &#125;&#125;&#125;; loop123html`&lt;ul&gt; $&#123;this.myArray.map(i =&gt; html`&lt;li&gt;$&#123;i&#125;&lt;/li&gt;`)&#125;&lt;/ul&gt;`; conditionals12345html` $&#123;this.myBool? html`&lt;p&gt;Render some HTML if myBool is true&lt;/p&gt;`: html`&lt;p&gt;Render some other HTML if myBool is false&lt;/p&gt;`&#125;`; 바인딩 textContent: &lt;p&gt;$&#123;...&#125;&lt;/p&gt; attribute: &lt;p id=&quot;$&#123;...&#125;&quot;&gt;&lt;/p&gt; boolean attribute: ?checked=&quot;$&#123;...&#125;&quot; property: .value=&quot;$&#123;...&#125;&quot; event handler: @event=&quot;$&#123;...&#125;&quot; textContent 바인딩1html`&lt;div&gt;$&#123;this.prop1&#125;&lt;/div&gt;` attribute 바인딩1html`&lt;div id=&quot;$&#123;this.prop2&#125;&quot;&gt;&lt;/div&gt;` 속성 값은 항상 문자열 또는 문자열로 반환될 수 있는 값이여야 한다. boolean attribute 바인딩1html`&lt;input type=&quot;checkbox&quot; ?checked=&quot;$&#123;this.prop3&#125;&gt;i like pie&lt;/input&gt;&quot;` true면 attribute로 추가되고, false면 사라진다. property 바인딩1html`&lt;input type=&quot;checkbox&quot; .value=&quot;$&#123;this.prop4&#125;&quot; /&gt;` event handler 바인딩1html`&lt;button @click=&quot;$&#123;this.clickHandler&#125;&quot;&gt;pie?&lt;/button&gt;` &lt;slot&gt;&lt;/slot&gt; light Dom 렌더링설정(일반)1234567render() &#123; return html` &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `;&#125; 설정(네이밍)1234567render() &#123; return html` &lt;div&gt; &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt; &lt;/div&gt; `;&#125; 사용(일반)12345&lt;my-element&gt; &lt;p&gt;Render me&lt;/p&gt; &lt;p&gt;Me too&lt;/p&gt; &lt;p&gt;Me three&lt;/p&gt;&lt;/my-element&gt; 사용(네이밍)123&lt;my-element&gt; &lt;p slot=&quot;one&quot;&gt;slot one&lt;/p&gt;&lt;/my-element&gt; 일반적인 엘리먼트 태그 사용하기예를 들면, &lt;header&gt;, &lt;article&gt;, &lt;footer&gt; 을 이용해 템플릿 구성하는 방법커스텀 엘리먼트 특정 define 명령어와 HTML에서 is attr로도 구현 가능한 걸로 앎. 123456789101112131415161718192021class MyPage extends LitElement &#123; render() &#123; return html` $&#123;this.headerTemplate&#125; $&#123;this.articleTemplate&#125; $&#123;this.footerTemplate&#125; ` &#125; get headerTemplate() &#123; return html`&lt;header&gt;Header&lt;/header&gt;` &#125; get articleTemplate() &#123; return html`&lt;article&gt;Article&lt;/article&gt;` &#125; get footerTemplate() &#123; return html `&lt;footer&gt;Footer&lt;/footer&gt;` &#125;&#125; import 이용시12345678910import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyArticle extends LitElement &#123; render() &#123; return html` &lt;article&gt;article&lt;/article&gt; `; &#125;&#125;customElements.define(&#x27;my-article&#x27;, MyArticle); 12345678910111213import &#x27;./my-header.js&#x27;;import &#x27;./my-article.js&#x27;;import &#x27;./my-footer.js&#x27;;class MyPage extends LitElement &#123; render() &#123; return html` &lt;my-header&gt;&lt;/my-header&gt; &lt;my-article&gt;&lt;/my-article&gt; &lt;my-footer&gt;&lt;/my-footer&gt; `; &#125;&#125; CSS 사용 ★추천★: css``를 이용한 선언 (static styles property) render 안에 &lt;style&gt; 태그를 이용한 방법 외부 스타일 시트를 이용한 방법 &lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot; /&gt; css``12345678910111213141516171819202122class myElement extends LitElement &#123; static get styles() &#123; const mainColor = css`red` const unSafeStr = `red` return css` :host &#123; display: block; color: $&#123;mainColor&#125;; background-color: $&#123;unsafeCSS(unSafeStr)&#125;; &#125; ` &#125;&#125;// or 여러개의 CSS 선언시class MyElement extends LitElement &#123; static get styles() &#123; return [ css`:host &#123; display: block; &#125;`, ...] &#125;&#125; &lt;style&gt;태그 사용123456789101112131415import &#123;LitElement, property&#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; const mainColor = css`blue`; render() &#123; return html` &lt;style&gt; :host &#123; color: $&#123;this.mainColor&#125;; &#125; &lt;/style&gt; `; &#125;&#125; 외부 스타일시트 사용123456789import &#123;LitElement&#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; render() &#123; return html` &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt; `; &#125;&#125; shadow Dom에서의 CSS 작성법:host(...)123456789:host &#123; display: block; color: blue;&#125;:host(.important) &#123; color: red; font-weight: bold;&#125; ::slot12::slotted(*) &#123; font-family: Roboto; &#125;::slotted(span) &#123; color: blue; &#125; 커스텀 엘리먼트명으로 CSS 작성12345my-element &#123; font-family: Roboto; font-size: 20; color: blue;&#125; :host보다 우선순위가 높다. CSS Value 적용123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;/node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js&quot;&gt;&lt;/script&gt; &lt;title&gt;lit-element code sample&lt;/title&gt; &lt;style&gt; body &#123; --theme-primary: green; --theme-secondary: aliceblue; --theme-warning: red; --theme-font-family: Roboto; &#125; my-element &#123; --my-element-text-color: var(--theme-primary); --my-element-background-color: var(--theme-secondary); --my-element-font-family: var(--theme-font-family); &#125; my-element.warning &#123; --my-element-text-color: var(--theme-warning); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;my-element&gt;&lt;/my-element&gt; &lt;my-element class=&quot;warning&quot;&gt;&lt;/my-element&gt; &lt;/body&gt;&lt;/html&gt; Event@이벤트명을 이용123render() &#123; return html`&lt;button @click=&quot;$&#123;this.handleClick&#125;&quot;&gt;`;&#125; Dom으로 추가되기 전에 받는 이벤트는 constructor()에서 선언1234constructor() &#123; super(); this.addEventListener(&#x27;DOMContentLoaded&#x27;, this.handleLoaded);&#125; firstUpdated()123firstUpdated(changedProperties) &#123; this.addEventListener(&#x27;click&#x27;, this.handleClick);&#125; connectedCallback()discconectedCallback()12345678connectedCallback() &#123; super.connectedCallback(); document.addEventListener(&#x27;readystatechange&#x27;, this.handleChange);&#125;disconnectedCallback() &#123; document.removeEventListener(&#x27;readystatechange&#x27;, this.handleChange); super.disconnectedCallback();&#125; custom event1&lt;my-element @my-event=&quot;$&#123;(e) =&gt; &#123; console.log(e.detail.message) &#125;&#125;&quot;&gt;&lt;/my-element&gt; 12345678910111213class MyElement extends LitElement &#123; render() &#123; return html`&lt;div&gt;Hello World&lt;/div&gt;`; &#125; firstUpdated(changedProperties) &#123; let event = new CustomEvent(&#x27;my-event&#x27;, &#123; detail: &#123; message: &#x27;Something important happened&#x27; &#125; &#125;); this.dispatchEvent(event); &#125;&#125; standard event123456789class MyElement extends LitElement &#123; render() &#123; return html`&lt;div&gt;Hello World&lt;/div&gt;`; &#125; updated(changedProperties) &#123; let click = new Event(&#x27;click&#x27;); this.dispatchEvent(click); &#125;&#125; 이벤트 버블링버블링 확인123handleEvent(e)&#123; console.log(e.bubbles);&#125; e.target1&lt;my-element onClick=&quot;(e) =&gt; console.log(e.target)&quot;&gt;&lt;/my-element&gt; 123456render() &#123; return html` &lt;button id=&quot;mybutton&quot; @click=&quot;$&#123;(e) =&gt; console.log(e.target)&#125;&quot;&gt; click me &lt;/button&gt;`;&#125; composedPath123handleMyEvent(event) &#123; console.log(&#x27;Origin: &#x27;, event.composedPath()[0]);&#125; shadow root 통과12345678firstUpdated(changedProperties) &#123; let myEvent = new CustomEvent(&#x27;my-event&#x27;, &#123; detail: &#123; message: &#x27;my-event happened.&#x27; &#125;, bubbles: true, composed: true // 이부분! &#125;); this.dispatchEvent(myEvent);&#125; LifeCyclerequestUpdate()12345// Manually start an updatethis.requestUpdate();// Call from within a custom property setterthis.requestUpdate(propertyName, oldValue); performUpdate()1234async performUpdate() &#123; await new Promise((resolve) =&gt; requestAnimationFrame(() =&gt; resolve())); super.performUpdate();&#125; shouldUpdate(changedProp)1234567shouldUpdate(changedProperties) &#123; changedProperties.forEach((oldValue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; changed. oldValue: $&#123;oldValue&#125;`); &#125;); // prop1이 바뀔 때만, update return changedProperties.has(&#x27;prop1&#x27;);&#125; update(changedProp)render()firstUpdated(changedProp)1234567firstUpdated(changedProperties) &#123; changedProperties.forEach((oldValue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; changed. oldValue: $&#123;oldValue&#125;`); &#125;); const textArea = this.shadowRoot.getElementById(this.textAreaId); textArea.focus();&#125; updated(changedProp)1234567updated(changedProperties) &#123; changedProperties.forEach((oldValue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; changed. oldValue: $&#123;oldValue&#125;`); &#125;); let b = this.shadowRoot.getElementById(&#x27;b&#x27;); b.focus();&#125; updateComplete()12345await this.updateComplete;// do stuff// orthis.updateComplete.then(() =&gt; &#123; /* do stuff */ &#125;); npm 모듈로 만들기npm packages 가이드에 따라 작성한글 가이드 블로그 글npm 모듈 사용하기 npm install 모듈명 1npm install some-package-name Javascript에서 사용 1import &#x27;some-package-name&#x27;; HTML에서 사용 123&lt;script type=&quot;module&quot;&gt;import &#x27;./path-to/some-package-name/some-component.js&#x27;;&lt;/script&gt; Or: 1&lt;script type=&quot;module&quot; src=&quot;./path-to/some-package-name/some-component.js&quot;&gt;&lt;/script&gt; 이후, READE에 따른 컴포넌트 사용 1&lt;some-component&gt;&lt;/some-component&gt; Polyfill npm install 1npm install --save-dev @webcomponents/webcomponentsjs HTML Script 추가 12345678910111213&lt;head&gt; &lt;!--script src&#x3D;&quot;.&#x2F;path-to&#x2F;custom-elements-es5-loader.js&quot;&gt;&lt;&#x2F;script--&gt; &lt;script src&#x3D;&quot;path-to&#x2F;webcomponents-loader.js&quot;defer&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;module&quot;&gt; window.WebComponents &#x3D; window.WebComponents || &#123; waitFor(cb)&#123; addEventListener(&#39;WebComponentsReady&#39;, cb) &#125; &#125; WebComponents.waitFor(async () &#x3D;&gt; &#123; import(&#39;.&#x2F;path-to&#x2F;some-element.js&#39;); &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt; 이유는 알 수 없는데 위 튜토리얼 사항대로 하면, ie11은 지원되지 않는다.아래와 같이하면 되는걸로 확인 1234&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.4.4/polyfill.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/@webcomponents/webcomponentsjs@2.2.10/bundles/webcomponents-sd-ce-pf.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/@webcomponents/webcomponentsjs@2.2.10/custom-elements-es5-adapter.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./main-bundle.js&quot;&gt;&lt;/script&gt;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"lit-element","slug":"lit-element","permalink":"https://taeuk-gang.github.io/tags/lit-element/"}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"}]},{"title":"코르도바 개발 일지 (1)","date":"2019-09-01T19:37:23.000Z","path":"wiki/Project-cordova-1/","text":"목적이번에 “스마트 관광 앱개발 공모전” 본선 진출을 하게 되어, 앱개발을 하게됬다.그런데 순수 안드로이드 개발 경험은 전무하여, 웹기술(폰갭 = 코르도바)을 통한 개발에 도전하고자 한다. 차례 개발 환경 구축 프로젝트 생성·관리 코드 작성 (코르도바 도입) 안드로이드 스토어 등록 개발환경 구축모든 사항은 코르도바 공식 DOCS 에 더 상세히 작성되어있다. 1. Node.js 및 NPM 설치1234# 설치 확인node -vnpm -v 설치 방법은 공식 사이트 참고 (사이트) 2. 코르도바 커맨드라인 인터페이스 설치1npm install -g cordova 3. 안드로이드 스튜디오 설치코르도바는 안드로이드 SDK를 내부에서 이용하므로 설치할 필요가 있다. 마찬가지로 공식 사이트 참고 4. 환경변수 설정SDK 폴더 내, tools, platform-tools 폴더 2개를 시스템 환경변수에 추가해준다.정상적으로 설정되었다면 다음 명령어를 통해 확인 1adb version 5. Gradle 설치코르도바 빌드를 위해서는 gradle이 필요하다. 참고 사이트 에 따라, 설치를 완료한다. 6. 안드로이드 스튜디오 설정안드로이드 스튜디오에서 각 안드로이드 API버전을 설치하고, 예뮬레이터를 추가해야한다.테스트 기기에 따른 API 다운 및 Virtual Device 설정 프로젝트 생성123cordova create hello com.example.hello HelloCordova -d# cordova create 폴더명 앱-식별자 프로젝트명 생성과정옵션 현재 디렉토리에 hello 폴더를 생성하고, 앱 식별자로 com.example.hello를 가진 HelloCordova 이름의 프로젝트를 생성한다. 라는 의미. -d는 프로젝트의 생성과정을 표시해주는 옵션이다. 플랫폼 추가1234cd hellocordova platform add ioscordova platform add android ios와 android용 프로젝트 파일을 생성하는 명령이다. 플랫폼 확인1cordova platform ls 플랫폼 제거12cordova platform remove ioscordova platform remove android 디렉토리 구조1234567📦hello┣ 📂hooks # 사용자 스크립트┣ 📂platforms # 각 플랫폼 고유 프로젝트 파일(ios, android)┣ 📂plugins # 플러그인┣ ┗ 📂www # HTML5 리소스, 앱 설정┣ 📂(merges) # 각 플랫폼 고유 리소스 (자동생성되지는 않는다)┣ 📜config.xml # 프로젝트 설정 파일 config.xml은 빌드시에 platforms 하위 디렉토리로 각 플랫폼별로 복사된다. merges 폴더는 3.5버전부터는 자동생성되지않지만, 폴더를 만들고 그 아래 원하는 플랫폼 디렉토리를 만들면 된다. ex. merges/android plugins 아래는 플러그인과 그 설정 파일을 저장하는 장소이다. CLI 명령어를 통해 관리하기 때문에 수동으로 폴더를 관리하는 일은 적다. 안드로이드 시뮬레이터 이용12# 바로 실행시cordova emulate android -d 실제 디바이스에서 프로젝트 실행디바이스 개발자 옵션 - USB 디버깅 ON 12# 연결된 디바이스가 없으면, 예뮬레이터 자동 실행cordova run android -d","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"Project","slug":"Project","permalink":"https://taeuk-gang.github.io/tags/Project/"},{"name":"Cordova","slug":"Cordova","permalink":"https://taeuk-gang.github.io/tags/Cordova/"}],"categories":[{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/categories/Projects/"},{"name":"mac-tour","slug":"Projects/mac-tour","permalink":"https://taeuk-gang.github.io/categories/Projects/mac-tour/"}]},{"title":"lit-element 학습 일지","date":"2019-08-29T14:16:48.000Z","path":"wiki/Js-lit-element/","text":"개인이 학습한 내용으로, 틀린 내용이 존재할 수 있습니다. TypeScript 부분은 생략 소개목차 LitElement란 무엇인가? 다음 단계 LitElement란 무엇인가?LitElement는 어떤 프레임워크로든 모든 웹 페이지에서 작동하는빠르고 가벼운 웹 구성요소를 만들기 위한 간단한 기본 클래스다. LitElement는 lit-html를 사용하여 shadow-dom으로 렌더링하는 방식이다. 그리고 API를 추가하여, 속성을 관리한다.속성은 기본적으로 관찰되며, 엘리멘트들은 이러한 속성들이 바뀔때마다 비동기적으로 업데이트된다. LitElement를 이용하여 앱을 구성하려면, PWA Starter kit을 확인해봐라. PWA Starter Kit이 뭐지? Progressive web application을 쉽게 만들 수 있는 샘플 프로젝트 (템플릿) PWA Starter Kit은 PWA 앱 개발을 쉽게 시작할 수 있도록 제공되는 샘플 프로젝트다. 환경 구성과 페이지 구성(디자인, 반응형 레이아웃, 등)이 포함돼 있다. PWA Starter Kit을 활용하는 예제는 Google I/O 2018의 “PWA starter kit: build fast, scalable, modern apps with Web Components“ 세션을 참고한다. 출저: 2018년과 이후 JavaScript의 동향](https://d2.naver.com/helloworld/5644368) 으음… 프로젝트 구조 및 필요해보이는 모듈들을 분석이 필요해보임 다음 단계 시작하기: 개발환경 구축과 컴포넌트 생성 템플릿: lit-html을 이용한 템플릿 작성 속성: properties와 attributes 관리 라이프사이클: lifecycle API를 이용한 LitElement 작동 시작하기목차 설치 LitElement 컴포넌트 생성 LitElement TypeScript Decorators 사용 컴포넌트 불러오기 너만의 컴포넌트 불러오기 서드파티 LitElement 컴포넌트 불러오기 설치npm과 Node.js 가 필요 (설치: instructions on NodeJS.org)npm을 이용한 Polymer CLI 설치1npm install -g polymer-cli 로컬에서 서버 띄우기1polymer server Polymer CLI 자세히 - Polymer CLI documentation 간단히 생성히 보기 - sample LitElement project. sample Litelement project 예제는 firebase를 이용한 템플릿이다. 프로젝트에 서비스워커도 사용하고, polyfill도 넣고, 구조를 약간 살펴볼 필요성이 있어보임 살펴본 결과, polymer에 의존된 부분이 많아 템플릿으로 쓰기 부적절하다 생각됬다. polymer.json을 webpack.config.json으로 바꾸는 등 표준적인 스펙으로 변경해야겠다. LitElement 컴포넌트 생성1npm install lit-element LitElement 모듈 불러오기(import) LitElement를 상속받는 class 생성 render 부분 선언 define을 통한 커스텀 엘리먼트화 예시123456789101112// my-element.jsimport &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; render()&#123; return html` &lt;p&gt;A paragraph&lt;/p&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 여기까지는 lit-html과 다를게 없음 lit-element 불러오기123456&lt;head&gt; &lt;script type=&quot;module&quot; src=&quot;/path/to/my-element.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;my-element&gt;&lt;/my-element&gt;&lt;/body&gt; 다른 모듈 불러오기12345678910import &#x27;./my-element.js&#x27;;class MyOtherElement extends LitElement&#123; render()&#123; return html` &lt;my-element&gt;&lt;/my-element&gt; `; &#125;&#125;customElements.define(&#x27;my-other-element&#x27;, MyOtherElement); 서드파티 LitElement 불러오기 서드파티가 뭐지? 서드 파티 개발자(3rd party developer)또는 써드 파티는 일반적으로 하드웨어 생산자와 소프트웨어 개발자의 관계를 나타내는 용어로 사용된다. 하드웨어 생산자는 퍼스트 파티(first party)로, 소프트웨어 개발자는 서드 파티(third party)로 불리기도 한다. 하드웨어 생산자인 모기업과 자사간의 관계 또는 하청관계등 전혀 관련없는 소프트웨어 개발자를 써드 파티라고 부르고 제품의 사용자를 세컨드 파티(2nd party) 그리고 하드웨어 생산자인 모기업과 자사간의 관계 또는 하청관계등 여타의 관계하에 소프트웨어를 개발하는 업체를 퍼스트파티라고 표현하는등 업체별 분야별로 약간씩 서로 다른 사례나 관례를 가지고 있다. 출저: 위키피디아 다운받기1234cd my-project-folder# 서드파티 모듈 불러오기npm install package-name HTML에서 사용하기123456&lt;head&gt; &lt;script type=&quot;module&quot; src=&quot;node_modules/package-name/existing-element.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;existing-element&gt;&lt;/existing-element&gt;&lt;/body&gt; Javascript에서 사용하기12345678910import &#x27;package-name/existing-element.js&#x27;;class MyElement extends LitElement&#123; render()&#123; return html` &lt;existing-element&gt;&lt;/existing-element&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 템플릿목차 템플릿 정의 및 렌더링 템플릿의 성능 설계 properties, loop, conditionals 문법 사용 child-element 속성 바인딩 slot-element 사용하기 다른 템플릿과 함께 사용하기 shadow-dom 사용하기 템플릿 치트시트 더 읽을거리 템플릿 정의 및 렌더링12345class MyElement extends LitElement &#123; render() &#123; return html`&lt;p&gt;template content&lt;/p&gt;`; &#125;&#125; html``(백틱)을 이용한 정의 템플릿 성능 설계render 함수 설명 element의 state가 바뀌지 않음 사이드 이펙트가 없다 (?) 오직 element properties에만 의존한다 같은 property value면 같은 결과를 가진다 비효율적인 DOM 렌더링 예시12345678910111213// class 내부 코드constructor() &#123; super(); this.addEventListener(&#x27;stuff-loaded&#x27;, (e) =&gt; &#123; this.shadowRoot.getElementById(&#x27;message&#x27;).innerHTML=e.detail; &#125;); this.loadStuff();&#125;render() &#123; return html` &lt;p id=&quot;message&quot;&gt;Loading&lt;/p&gt; `;&#125; 개선된 효율적인 코드1234567891011constructor() &#123; super(); this.message = &#x27;Loading&#x27;; this.addEventListener(&#x27;stuff-loaded&#x27;, (e) =&gt; &#123; this.message = e.detail &#125; ); this.loadStuff();&#125;render() &#123; return html` &lt;p&gt;$&#123;this.message&#125;&lt;/p&gt; `;&#125; 위 두 차이를 보면 알 수 있는 것은, DOM을 직접 조작하지마라! 이다. Properties, loop, conditionals 사용properties1234567static get properties() &#123; return &#123; myProp: String &#125;; // 선언방식 = 속성: 타입&#125;...render() &#123; return html`&lt;p&gt;$&#123;this.myProp&#125;&lt;/p&gt;`; &#125; loop123html`&lt;ul&gt; $&#123;this.myArray.map(i =&gt; html`&lt;li&gt;$&#123;i&#125;&lt;/li&gt;`)&#125;&lt;/ul&gt;`; map을 이용한 반복 정의 conditionals12345html` $&#123;this.myBool? html`&lt;p&gt;Render some HTML if myBool is true&lt;/p&gt;`: html`&lt;p&gt;Render some other HTML if myBool is false&lt;/p&gt;`&#125;`; React와 비슷하게 사용되네 전체 code example123456789101112131415161718192021222324252627282930import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; myString: &#123; type: String &#125;, myArray: &#123; type: Array &#125;, myBool: &#123; type: Boolean &#125; &#125;; &#125; constructor() &#123; super(); this.myString = &#x27;Hello World&#x27;; this.myArray = [&#x27;an&#x27;,&#x27;array&#x27;,&#x27;of&#x27;,&#x27;test&#x27;,&#x27;data&#x27;]; this.myBool = true; &#125; render() &#123; return html` &lt;p&gt;$&#123;this.myString&#125;&lt;/p&gt; &lt;ul&gt; $&#123;this.myArray.map(i =&gt; html`&lt;li&gt;$&#123;i&#125;&lt;/li&gt;`)&#125; &lt;/ul&gt; $&#123;this.myBool? html`&lt;p&gt;Render some HTML if myBool is true&lt;/p&gt;`: html`&lt;p&gt;Render some other HTML if myBool is false&lt;/p&gt;`&#125; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 자식 엘리멘트 바인딩html``을 이용할 때, textContent, attributes, boolean, properties, event handler 등을 간편하게 받을 수 있는 문법이 있다. textContent: &lt;p&gt;$&#123;...&#125;&lt;/p&gt; attribute: &lt;p id=&quot;$&#123;...&#125;&quot;&gt;&lt;/p&gt; boolean attribute: ?checked=&quot;$&#123;...&#125;&quot; property: .value=&quot;$&#123;...&#125;&quot; event handler: @event=&quot;$&#123;...&#125;&quot; 요소의 속성이 포함될 수 있고, LitElement는 속성 변경을 관찰하고 이에 자동으로 템플릿을 업데이트를 한다. 데이터바인딩은 항상 단방향 textContent 바인딩1html`&lt;div&gt;$&#123;this.prop1&#125;&lt;/div&gt;` attribute 바인딩1html`&lt;div id=&quot;$&#123;this.prop2&#125;&quot;&gt;&lt;/div&gt;` 속성 값은 항상 문자열 또는 문자열로 반환될 수 있는 값이여야 한다. boolean attribute 바인딩1html`&lt;input type=&quot;checkbox&quot; ?checked=&quot;$&#123;this.prop3&#125;&gt;i like pie&lt;/input&gt;&quot;` true면 attribute로 추가되고, false면 사라진다. property 바인딩1html`&lt;input type=&quot;checkbox&quot; .value=&quot;$&#123;this.prop4&#125;&quot; /&gt;` event handler 바인딩1html`&lt;button @click=&quot;$&#123;this.clickHandler&#125;&quot;&gt;pie?&lt;/button&gt;` 전체 code example1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop1: String, prop2: String, prop3: Boolean, prop4: String &#125;; &#125; constructor() &#123; super(); this.prop1 = &#x27;text binding&#x27;; this.prop2 = &#x27;mydiv&#x27;; this.prop3 = true; this.prop4 = &#x27;pie&#x27;; &#125; render() &#123; return html` &lt;!-- text binding --&gt; &lt;div&gt;$&#123;this.prop1&#125;&lt;/div&gt; &lt;!-- attribute binding --&gt; &lt;div id=&quot;$&#123;this.prop2&#125;&quot;&gt;attribute binding&lt;/div&gt; &lt;!-- boolean attribute binding --&gt; &lt;div&gt; boolean attribute binding &lt;input type=&quot;checkbox&quot; ?checked=&quot;$&#123;this.prop3&#125;&quot;/&gt; &lt;/div&gt; &lt;!-- property binding --&gt; &lt;div&gt; property binding &lt;input type=&quot;checkbox&quot; .value=&quot;$&#123;this.prop4&#125;&quot;/&gt; &lt;/div&gt; &lt;!-- event handler binding --&gt; &lt;div&gt;event handler binding &lt;button @click=&quot;$&#123;this.clickHandler&#125;&quot;&gt;click&lt;/button&gt; &lt;/div&gt; `; &#125; clickHandler(e) &#123; console.log(e.target); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); slot-element를 이용한 light Dom 렌더링shadow Dom vs light Domshadow Dom을 소개하기 때문에 그것과 비교하기 위해 light Dom이라는 별도 용어를 사용 기본적으로 모든 부분을 렌더링하진 않는다. (부분 렌더링) 123&lt;my-element&gt; &lt;p&gt;I won&#x27;t render&lt;/p&gt;&lt;/my-element&gt; slot-element 사용1234567render() &#123; return html` &lt;div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `;&#125; Light Dom의 자식 엘리멘트는 이제 slot부분을 렌더링할 수 있다. 12345&lt;my-element&gt; &lt;p&gt;Render me&lt;/p&gt; &lt;p&gt;Me too&lt;/p&gt; &lt;p&gt;Me three&lt;/p&gt;&lt;/my-element&gt; 간단히 요약하면, 자바스크립트에서 &lt;slot&gt;&lt;/slot&gt;이라고 표시를 하고,HTML에서 여러 자식 엘리멘트를 삽입할 수 있구나 slot에 이름 붙이기1234567render() &#123; return html` &lt;div&gt; &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt; &lt;/div&gt; `;&#125; index.html 123&lt;my-element&gt; &lt;p slot=&quot;one&quot;&gt;slot one&lt;/p&gt;&lt;/my-element&gt; 자바스크립트에서 name으로 선언된 슬롯명과 HTML에서 slot attribute 선언된 문자열이 같은 것만 허용 ex. &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt;은 &lt;p slot=&quot;one&quot;&gt;&lt;/p&gt;만 허용, 거꾸로도 마찬가지임 전체 code examplemy-element.js 12345678910111213import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; render()&#123; return html` &lt;div&gt; &lt;slot name=&quot;one&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;two&quot;&gt;&lt;/slot&gt; &lt;/div&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); index.html 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;script src=&quot;/node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;module&quot; src=&quot;./my-element.js&quot;&gt;&lt;/script&gt; &lt;title&gt;lit-element code sample&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Assign light DOM child to a specific slot --&gt; &lt;my-element&gt; &lt;p slot=&quot;two&quot;&gt;Include me in slot &quot;two&quot;.&lt;/p&gt; &lt;/my-element&gt; &lt;!-- Named slots only accept light DOM children with a matching `slot` attribute. Light DOM children with a `slot` attribute can only go into a slot with a matching name. --&gt; &lt;my-element&gt; &lt;p slot=&quot;one&quot;&gt;Include me in slot &quot;one&quot;.&lt;/p&gt; &lt;p slot=&quot;nope&quot;&gt;This one will not render at all.&lt;/p&gt; &lt;p&gt;No default slot, so this one won&#x27;t render either.&lt;/p&gt; &lt;/my-element&gt;&lt;/body&gt;&lt;/html&gt; name을 사용하라! id는 아무 영향이 없다.my-element.js 1234567render()&#123; return html` &lt;div&gt; &lt;slot id=&quot;one&quot;&gt;&lt;/slot&gt; &lt;/div&gt; `;&#125; index.html 1234&lt;my-element&gt; &lt;p slot=&quot;one&quot;&gt;nope.&lt;/p&gt; &lt;p&gt;ohai..&lt;/p&gt;&lt;/my-element&gt; 아무런 영향이 없음 다른 엘리멘트 템플릿으로 템플릿 구성하기예를 들면, &lt;header&gt;, &lt;article&gt;, &lt;footer&gt; 을 이용해 템플릿 구성하는 방법 123456789101112131415161718192021class MyPage extends LitElement &#123; render() &#123; return html` $&#123;this.headerTemplate&#125; $&#123;this.articleTemplate&#125; $&#123;this.footerTemplate&#125; ` &#125; get headerTemplate() &#123; return html`&lt;header&gt;Header&lt;/header&gt;` &#125; get articleTemplate() &#123; return html`&lt;article&gt;Article&lt;/article&gt;` &#125; get footerTemplate() &#123; return html `&lt;footer&gt;Footer&lt;/footer&gt;` &#125;&#125; import를 이용한 구성방법my-article.js 12345678910import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyArticle extends LitElement &#123; render() &#123; return html` &lt;article&gt;article&lt;/article&gt; `; &#125;&#125;customElements.define(&#x27;my-article&#x27;, MyArticle); my-page.js 12345678910111213import &#x27;./my-header.js&#x27;;import &#x27;./my-article.js&#x27;;import &#x27;./my-footer.js&#x27;;class MyPage extends LitElement &#123; render() &#123; return html` &lt;my-header&gt;&lt;/my-header&gt; &lt;my-article&gt;&lt;/my-article&gt; &lt;my-footer&gt;&lt;/my-footer&gt; `; &#125;&#125; lit-html과 공통사항이 많음 Specify the render root기본적으로, LitElement는 open 상태인 shadowRoot를 생성하고 그 아래에 Dom 구조를 형성한다. 12345&lt;!-- 형태 --&gt;&lt;my-element&gt; #shadow-root &lt;p&gt;child 1&lt;/p&gt; &lt;p&gt;child 2&lt;/p&gt; 1234567891011class LightDom extends LitElement &#123; render() &#123;; return html` &lt;p&gt;light DOM&lt;/p&gt; `; &#125; createRenderRoot() &#123; return this; &#125;&#125; cheat sheetRender12345render() &#123; return html` &lt;p&gt;template&lt;/p&gt; `&#125; Properties, loops, conditionals12345678// Propertyhtml`&lt;p&gt;$&#123;this.prop&#125;&lt;/p&gt;`// Loophtml`$&#123;this.array.map(i =&gt; html`&lt;li&gt;$&#123;i&#125;&lt;/li&gt;`)&#125;`// Conditionalhtml`$&#123;this.bool ? html`&lt;p&gt;foo&lt;/p&gt;` : html`&lt;p&gt;bar&lt;/p&gt;`&#125;` Data binding1234567891011// Attributehtml`&lt;p id=&quot;$&#123;...&#125;&quot;`// Boolean attributehtml`&lt;input type=&quot;checkbox&quot; ?checked=&quot;$&#123;...&#125;&quot;&gt;`// Propertyhtml`&lt;input .value=&quot;$&#123;...&#125;&quot;&gt;`// Event handlerhtml`&lt;button @click=&quot;$&#123;this.do&#125;&quot;&gt;&lt;/button&gt;` Composition1234567891011// From multiple templates on same classrender() &#123; return html` $&#123;this.headerTemplate&#125; &lt;article&gt;Article&lt;/article&gt; ` get headerTemplate() &#123; return html`&lt;header&gt;Header&lt;/header&gt;` &#125;&#125; 1234567891011// By importing elementsimport &#x27;./my-header.js&#x27;class MyPage extends LitElement &#123; render() &#123; return html` &lt;my-header&gt;&lt;/my-header&gt; &lt;article&gt;Article&lt;/article&gt; ` &#125;&#125; slots12345render() &#123; return html` &lt;slot name=&quot;thing&quot;&gt;&lt;/slot&gt; `&#125; 123&lt;my-element&gt; &lt;p slot=&quot;thing&quot;&gt;stuff&lt;/p&gt;&lt;/my-element&gt; Futher readingLitElement는 lit-html의 html, render 기능을 사용한다. on the lit-html homepage in the Template Reference 스타일목차 컴포넌트 개발을 위한 스타일 옵션 정의 위치 static styles property style element external stylesheet host element와 shadow Dom에서의 css 작성 컴포넌트 사용자를 위한 스타일 옵션 (import) 테마 작업 CSS 상속과 shadow Dom Custom CSS properties example theme 만약, Shady Css polyfill을 사용한다면, 일부 제한사항이 발생함자세한 사항은 Shady CSS를 참조 Styling options for component developers정의하는 방법 3가지 ★추천★: css``를 이용한 선언 (static styles property) render 안에 &lt;style&gt; 태그를 이용한 방법 외부 스타일 시트를 이용한 방법 &lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot; /&gt; css``이용: Define styles in a static styles property추천되는 이유는 정적 스타일이 최적화 성능이 잘되있어서 인 듯 상세사항: We recommend using static styles for optimal performance. LitElement uses Constructable Stylesheets in browsers that support it, with a fallback for browsers that don’t. Constructable Stylesheets allow the browser to parse styles exactly once and reuse the resulting Stylesheet object for maximum efficiency. 컴포넌트 개발자는 shadow Dom 안에서 CSS 스타일을 정의한다. import로 사용하는 이용자는 shadow Dom 밖에서 host 엘리멘트에 CSS 상속을 통해 CSS를 정의한다. 사용법 css helper 함수를 import 1import &#123;LitElement, css&#125; from &#x27;lit-element&#x27;; styels를 LitElement가 상속된 클래스에서 static을 이용해 정의함 123456789class myElement extends LitElement &#123; static get styles() &#123; return css` :host &#123; display: block; &#125; ` &#125;&#125; 또는, 배열을 이용해 정의도 가능 12345class MyElement extends LitElement &#123; static get styles() &#123; return [ css`:host &#123; display: block; &#125;`, ...] &#125;&#125; 변수 사용악의적인 코드 삽입을 방지하기위해, css``를 사용하여 삽입 123456789static get styles() &#123; const mainColor = css`red` return css` :host &#123; color: $&#123;mainColor&#125;; &#125; `&#125; 그래도 정 문자열을 사용하고 싶다면 아래와 같이 사용 12345678910111213import &#123; LitElement, css, unsafeCSS &#125; from &#x27;lit-element&#x27;class MyElement extends LitElement &#123; static get styles() &#123; const mainColor = `red` return css` :host &#123; color: $&#123;unsafeCSS(mainColor)&#125;; &#125; ` &#125;&#125; 다른 예제 1234567891011121314import &#123; LitElement, css, unsafeCSS &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get styles() &#123; const mainWidth = 800; const padding = 20; return css` :host &#123; width: $&#123;unsafeCSS(mainWidth + padding)&#125;px; &#125; `; &#125; &#125; Only use the unsafeCSS tag with trusted input. To prevent LitElement-based components from evaluating potentially malicious code, the css tag only accepts literal strings. unsafeCSS circumvents this safeguard. &lt;style&gt; 태그를 이용한 방법 Expressions inside a &lt;style&gt; element won’t update per instance in ShadyCSS. Due to limitations of the ShadyCSS polyfill, you can’t use element properties in CSS rules as the expressions won’t be evaluated. 스타일 태그를 이용한 방법은 ShadyCSS에서 인스턴스당 업데이트를 하지 않는다는 의미가 잘 와닿지가 않네.ShadyCSS polyfill에 제한이 있을 수 있다는 뜻인가 사용법123456789101112131415import &#123;LitElement, property&#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; const mainColor = css`blue`; render() &#123; return html` &lt;style&gt; :host &#123; color: $&#123;this.mainColor&#125;; &#125; &lt;/style&gt; `; &#125;&#125; 외부 스타일시트 사용하기 We strongly recommend static styles, CSS custom properties, or lit-html’s classMap or styleMap directives if you’re styling non-host shadow root contents. 사용법123456789import &#123;LitElement&#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; render() &#123; return html` &lt;link rel=&quot;stylesheet&quot; href=&quot;./styles.css&quot;&gt; `; &#125;&#125; 이것은 SASS/LESS를 부를 때 좋은 방법이 될 수 있음그러나 몇가지 주의사항이 존재 이 사용법은 FOUC를 발생시킴 (잠깐 CSS가 변경되는 모습이 보여지는 것) 재사용 컴포넌트를 만들기에는 부적합할 수 있음 Write CSS styles for a host element and its shadow DOMhost(밖)와 shadow Dom(안)에서 CSS 스타일링 방식이 다름 host element에서 스타일링 방법 shadow Dom 안에서 스타일링 방법 slot-element의 스타일링 방법 Write CSS styles for a host element사용법:host selects the host element of the shadow root 1234:host &#123; display: block; color: blue;&#125; :host(...) selects the host element, (…)안에 셀렉터를 사용할 수 있음 1234:host(.important) &#123; color: red; font-weight: bold;&#125; Write CSS styles for elements in shadow DOM일반적인 css 사용과 같음그러나, shadow Dom 밖으로 CSS 전파가 되지 않기 때문에 범용성 있는 네이밍이나 *태그를 쉽게 사용 가능 123456789101112131415* &#123; color: black;&#125;h1 &#123; font-size: 4rem;&#125;#main &#123; padding: 16px;&#125;.important &#123; color: red;&#125; Write CSS styles for slotted children사용법 ::slotted(*) matches all slotted elements. ::slotted(p) matches slotted paragraphs. p ::slotted(*) matches slotted elements in a paragraph element. 전체 code example123456789101112131415161718import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; render() &#123; return html` &lt;style&gt; :host([hidden]) &#123; display: none; &#125; :host &#123; display: block; &#125; ::slotted(*) &#123; font-family: Roboto; &#125; ::slotted(span) &#123; color: blue; &#125; div ::slotted(*) &#123; color: red; &#125; &lt;/style&gt; &lt;slot&gt;&lt;/slot&gt; &lt;div&gt;&lt;slot name=&quot;hi&quot;&gt;&lt;/slot&gt;&lt;/div&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 컴포넌트 사용자를 위한 스타일 옵션 (import)import로 만들어진 컴포넌트를 불러와 스타일링 할 수 있다 123456789&lt;style&gt; my-element &#123; font-family: Roboto; font-size: 20; color: blue; &#125;&lt;/style&gt;...&lt;my-element&gt;&lt;/my-element&gt; 이렇게 엘리먼트로 선언된 CSS가 :host보다 우선순위가 높다. Styles set for a host element from outside its shadow DOM will override styles set with the :host or :host() pseudo-class selectors inside shadow DOM. See Inheritance. 대충 덮어쓰기를 한다는 뜻인가 ThemingCSS 상속을 어떻게 받고 커스텀할지 설명하는 부분 Custom CSS Propertiesindex.html 12345678&lt;style&gt; html &#123; --themeColor1: rgb(67, 156, 144); &#125; my-element &#123; --myBackground: var(--themeColor1); &#125;&lt;/style&gt; my-element.js 123456789101112131415161718import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; render() &#123; return html` &lt;style&gt; :host([hidden]) &#123; display: none; &#125; :host &#123; display: block; background-color: var(--myBackground, yellow); color: var(--myColor, black); padding: var(--myPadding, 8px); &#125; &lt;/style&gt; &lt;p&gt;Hello world&lt;/p&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 전체 code exampleindex.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&quot;/node_modules/@webcomponents/webcomponentsjs/custom-elements-es5-adapter.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/node_modules/@webcomponents/webcomponentsjs/webcomponents-bundle.js&quot;&gt;&lt;/script&gt; &lt;title&gt;lit-element code sample&lt;/title&gt; &lt;style&gt; body &#123; --theme-primary: green; --theme-secondary: aliceblue; --theme-warning: red; --theme-font-family: Roboto; &#125; my-element &#123; --my-element-text-color: var(--theme-primary); --my-element-background-color: var(--theme-secondary); --my-element-font-family: var(--theme-font-family); &#125; my-element.warning &#123; --my-element-text-color: var(--theme-warning); &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;my-element&gt;&lt;/my-element&gt; &lt;my-element class=&quot;warning&quot;&gt;&lt;/my-element&gt; &lt;/body&gt;&lt;/html&gt; my-element.js 123456789101112131415161718192021import &#123; LitElement, html, css &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static styles = css` :host &#123; display: block; color: var(--my-element-text-color); background: var(--my-element-background-color); font-family: var(--my-element-font-family); &#125; :host([hidden]) &#123; display: none; &#125; `; render() &#123; return html` &lt;div&gt;Hello from my-element&lt;/div&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); Properties목차 Overview Property options Declare properties Declare properties in a static properties getter Declare properties with decorators Initialize property values Initialize property values in the element constructor Initialize property values when using TypeScript decorators Initialize property values from attributes in markup Configure attributes Convert between properties and attributes Configure observed attributes Configure reflected attributes Configure property accessors Create your own property accessors Prevent LitElement from generating a property accessor Configure property changes 개요살펴볼 사항 선언된 속성이 변경될 때, 엘리멘트가 업데이트가 될지 결정 Capture instance values for declared properties. Apply any property values that are set before the browser registers a custom element definition. Set up an observed (not reflected) attribute with the lowercased name of each property. Property 설정 String, Number, Boolean, Array, and Object. Use direct comparison (oldValue !== newValue) to test for property changes. Apply any property options and accessors declared by a superclass. 아직 이해가 되지 않는 부분은 영어 처리 Remember to declare all of the properties that you want LitElement to manage.For the property features above to be applied, you must declare the property. lit-html와 다르게 type 선언 부분이 생김 ★★Property optionsThe following options are available: converter: Convert between properties and attributes. (수동 검사[to, from]) type: Use LitElement’s default attribute converter. (type) attribute: Configure observed attributes. (attr -&gt; prop) reflect: Configure reflected attributes. (prop -&gt; attr) noAccessor: Whether to set up a default property accessor. hasChanged: Specify what constitutes a property change. type 선언말고도 할 수 있는 부분이 많네 Declare properties12345678// properties getterstatic get properties() &#123; return &#123; prop1: &#123; type: String &#125;, prop2: &#123; type: Number &#125;, prop3: &#123; type: Boolean &#125; &#125;&#125; 12345// 만약, `constructor`를 이용해 초기화해주려면, 항상 `super()`를 처음에 작성한다constructor() &#123; super(); this.prop1 = &#x27;Hello&#x27;;&#125; code example1234567891011121314151617181920212223242526272829303132import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop1: &#123; type: String &#125;, prop2: &#123; type: Number &#125;, prop3: &#123; type: Boolean &#125;, prop4: &#123; type: Array &#125;, prop5: &#123; type: Object &#125; &#125;;&#125; constructor() &#123; super(); this.prop1 = &#x27;Hello World&#x27;; this.prop2 = 5; this.prop3 = false; this.prop4 = [1,2,3]; this.prop5 = &#123; subprop1: &#x27;prop 5 subprop1 value&#x27; &#125; &#125; render() &#123; return html` &lt;p&gt;prop1: $&#123;this.prop1&#125;&lt;/p&gt; &lt;p&gt;prop2: $&#123;this.prop2&#125;&lt;/p&gt; &lt;p&gt;prop3: $&#123;this.prop3&#125;&lt;/p&gt; &lt;p&gt;prop4[0]:&lt;/p&gt;$&#123;this.prop4[0]&#125;&lt;/p&gt; &lt;p&gt;prop5.subprop1: $&#123;this.prop5.subprop1&#125;&lt;/p&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); Initialize property12345678910static get properties() &#123; return &#123; prop1: &#123; type: String &#125; &#125; constructor() &#123; super() this.prop1 = &#x27;Hello&#x27; &#125;&#125; code example1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;class MyElement extends LitElement &#123; static get properties() &#123; prop1: &#123; type: String &#125;, prop2: &#123; type: Number &#125;, prop3: &#123; type: Boolean&#125;, prop4: &#123; type: Array &#125;, prop5: &#123; type: Object &#125; &#125; constructor() &#123; super() this.prop1 = &#x27;Hello&#x27; this.prop2 = 5 this.prop3 = true this.prop4 = [1,2,3] this.prop5 = &#123; stuff: `h1`, otherStuff: `wow` &#125; &#125; render() &#123; return html` &lt;p&gt;prop1: $&#123;this.prop1&#125;&lt;/p&gt; &lt;p&gt;prop2: $&#123;this.prop2&#125;&lt;/p&gt; &lt;p&gt;prop3: $&#123;this.prop3&#125;&lt;/p&gt; &lt;p&gt;prop4: $&#123;this.prop4.map((item, index) =&gt; html`&lt;span&gt;[$&#123;index&#125;]: $&#123;item&#125;&amp;nbsp;&lt;/span&gt;`)&#125; &lt;/p&gt; &lt;p&gt;prop5: $&#123;Object.keys(this.prop5).map(item =&gt; html`&lt;span&gt;$&#123;item&#125;: $&#123;this.prop5[item]&#125;$nbsp;&lt;/span&gt;`)&#125; &lt;/p&gt; ` &#125;&#125;customElements.define(`my-element`, MyElement) Initialize property values from attributes in markupindex.html 123456&lt;my-element mystring=&quot;hello world&quot; mynumber=&quot;5&quot; mybool myobj=&#x27;&#123;&quot;stuff&quot;:&quot;hi&quot;&#125;&#x27; myarray=&#x27;[1,2,3,4]&#x27;&gt;&lt;/my-element&gt; 이렇게 초기화한 값이 constructor()보다 우선순위로 적용됨 Configure attributesproperties와 attribute간 전환properties는 여러 타입을 가지지만, attribute는 항상 문자열이다.This impacts the observed attributes and reflected attributes of non-string properties attribue를 observe를 사용하여 관찰할 때, attribute는 항상 문자열에서 property type값으로 변환된다. attribute를 reflect, property는 문자열로 변환된다. General converter 사용하기123456// Use LitElement&#x27;s default converter prop1: &#123; type: String &#125;,prop2: &#123; type: Number &#125;,prop3: &#123; type: Boolean &#125;,prop4: &#123; type: Array &#125;,prop5: &#123; type: Object &#125; attribute -&gt; property String: 변화없음 Number: Number(attributeValue) 처리를 함 Boolean non-null: true null·undefined: false Object·Array: JSON.parse(attributeValue) property -&gt; attribute String null: remove attr undefined: don’t change attr non-null: change prop Number null: remove attr undefined: don’t change attr non-null: change prop Boolean true: create attr false: remove attr Object · Array null·undefined: remove attr non-null: JSON.stringify(prop) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop1: &#123; type: String, reflect: true &#125;, prop2: &#123; type: Number, reflect: true &#125;, prop3: &#123; type: Boolean, reflect: true &#125;, prop4: &#123; type: Array, reflect: true &#125;, prop5: &#123; type: Object, reflect: true &#125; &#125; &#125; constructor() &#123; super() this.prop1 = &#x27;&#x27; this.prop2 = 0 this.prop3 = false this.prop4 = [] this.prop5 = &#123;&#125; &#125; attributeChangedCallback(name, oldval, newval) &#123; console.log(`attr change: `, name, newval) super.attributeChangeCallback(name, oldval, newval) &#125; render() &#123; return html` &lt;p&gt;prop1 $&#123;this.prop1&#125;&lt;/p&gt; &lt;p&gt;prop2 $&#123;this.prop2&#125;&lt;/p&gt; &lt;p&gt;prop3 $&#123;this.prop3&#125;&lt;/p&gt; &lt;p&gt;prop4: $&#123;this.prop4.map((item, index) =&gt; html`&lt;span&gt;[$&#123;index&#125;]: $&#123;item&#125;&amp;nbsp;&lt;/span&gt;`)&#125; &lt;/p&gt; &lt;p&gt;prop5: $&#123;Object.keys(this.prop5).map(item =&gt; &#123; html`&lt;span&gt;$&#123;item&#125;: $&#123;this.prop5[item]&#125;&amp;nbsp;&lt;/span&gt;&#125;` &#125;)&#125; &lt;/p&gt; &lt;button @click=&quot;$&#123;this.changeProperties&#125;&quot;&gt;Change Prop&lt;/button&gt; &lt;button @click=&quot;$&#123;this.changeAttributes&#125;&quot;&gt;Change Attr&lt;/button&gt; ` &#125; changeAttributes() &#123; let randy = Math.floor(Math.random() * 10) let myBool = this.getAttributes(`prop3`) this.setAttribute(`prop1`, randy.toString) this.setAttribute(`prop2`, randy.toString) this.setAttribute(`prop3`, myBool ? `` : null) this.setAttribute(`prop4`, JSON.stringify([...this.prop4, randy])) this.setAttribute(`prop5`, JSON.stringify(Object.assign(&#123;&#125;, this.prop5, &#123;[randy]: randy&#125;))) this.requestUpdate() &#125; changeProperties() &#123; let randy = Math.floor(Math.random() * 10) let myBool = this.prop3 this.prop1 = randy.toString() this.prop2 = randy this.prop3 = !myBool this.prop4 = [...this.prop4, randy] this.prop5 = Object.assign(&#123;&#125;, this.prop5, &#123;[randy]: randy&#125;) &#125; updated(changedProperties) &#123; changedProperties.forEach((oldvalue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; change. oldValue: $&#123;oldValue&#125;`) &#125;) &#125;&#125;customElements.define(`my-element`, MyElement) Object.assign() 객체는 키값이 중복없이 객체를 반환함JSON.stringify(Object.assign(&#123;&#125;, this.prop5, &#123;[randy]: randy&#125;))); &#123;[randy]: randy&#125;로 키값에서 변수를 받네 12345678910const target = &#123; a: 1, b: 2 &#125;;const source = &#123; b: 4, c: 5 &#125;;const returnedTarget = Object.assign(target, source);console.log(target);// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;console.log(returnedTarget);// expected output: Object &#123; a: 1, b: 4, c: 5 &#125; Custom converter 사용하기12345678910prop1: &#123; converter: &#123; fromAttribute: (value, type) =&gt; &#123; &#125;, toAttribute: (value, type) =&gt; &#123; &#125; &#125;&#125; During an update: If toAttribute returns null, the attribute is removed. If toAttribute returns undefined, the attribute is not changed. example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; myProp: &#123; reflect: true, converter: &#123; toAttribute(value) &#123; console.log(&#x27;myProp\\&#x27;s toAttribute.&#x27;); console.log(&#x27;Processing:&#x27;, value, typeof(value)); let retVal = String(value); console.log(&#x27;Returning:&#x27;, retVal, typeof(retVal)); return retVal; &#125;, fromAttribute(value) &#123; console.log(&#x27;myProp\\&#x27;s fromAttribute.&#x27;); console.log(&#x27;Processing:&#x27;, value, typeof(value)); let retVal = Number(value); console.log(&#x27;Returning:&#x27;, retVal, typeof(retVal)); return retVal; &#125; &#125; &#125;, theProp: &#123; reflect: true, converter(value) &#123; console.log(&#x27;theProp\\&#x27;s converter.&#x27;); console.log(&#x27;Processing:&#x27;, value, typeof(value)); let retVal = Number(value); console.log(&#x27;Returning:&#x27;, retVal, typeof(retVal)); return retVal; &#125;&#125;, &#125;;&#125; constructor() &#123; super(); this.myProp = &#x27;myProp&#x27;; this.theProp = &#x27;theProp&#x27;; &#125; attributeChangedCallback(name, oldval, newval) &#123; // console.log(&#x27;attribute change: &#x27;, name, newval); super.attributeChangedCallback(name, oldval, newval); &#125; render() &#123; return html` &lt;p&gt;myProp $&#123;this.myProp&#125;&lt;/p&gt; &lt;p&gt;theProp $&#123;this.theProp&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;this.changeProperties&#125;&quot;&gt;change properties&lt;/button&gt; &lt;button @click=&quot;$&#123;this.changeAttributes&#125;&quot;&gt;change attributes&lt;/button&gt; `; &#125; changeAttributes() &#123; let randomString = Math.floor(Math.random()*100).toString(); this.setAttribute(&#x27;myprop&#x27;, &#x27;myprop &#x27; + randomString); this.setAttribute(&#x27;theprop&#x27;, &#x27;theprop &#x27; + randomString); this.requestUpdate(); &#125; changeProperties() &#123; let randomString = Math.floor(Math.random()*100).toString(); this.myProp=&#x27;myProp &#x27; + randomString; this.theProp=&#x27;theProp &#x27; + randomString; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 이 부분은 아직 자연스럽게 코딩할 수 없을 듯, 많은 프로젝트에서 사용해봐야 할 듯기능만 숙지하자 observeattr이 변경될 때마다, attributeChangedCallback 을 실행시킴 사용법12345678// Observed attribute will be called my-propmyProp: &#123; attribute: &#x27;my-prop&#x27; &#125;// No observed attribute for this propertymyProp: &#123; attribute: false &#125;// observed attribute for this property (default)myProp: &#123; attribute: true &#125; code example12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; myProp: &#123; attribute: true &#125;, theProp: &#123; attribute: false &#125;, otherProp: &#123; attribute: &#x27;other-prop&#x27; &#125;, &#125;;&#125; constructor() &#123; super(); this.myProp = &#x27;myProp&#x27;; this.theProp = &#x27;theProp&#x27;; this.otherProp = &#x27;otherProp&#x27;; &#125; attributeChangedCallback(name, oldval, newval) &#123; console.log(&#x27;attribute change: &#x27;, name, newval); super.attributeChangedCallback(name, oldval, newval); &#125; render() &#123; return html` &lt;p&gt;myProp $&#123;this.myProp&#125;&lt;/p&gt; &lt;p&gt;theProp $&#123;this.theProp&#125;&lt;/p&gt; &lt;p&gt;otherProp $&#123;this.otherProp&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;this.changeAttributes&#125;&quot;&gt;change attributes&lt;/button&gt; `; &#125; changeAttributes() &#123; let randomString = Math.floor(Math.random()*100).toString(); this.setAttribute(&#x27;myprop&#x27;, &#x27;myprop &#x27; + randomString); this.setAttribute(&#x27;theprop&#x27;, &#x27;theprop &#x27; + randomString); this.setAttribute(&#x27;other-prop&#x27;, &#x27;other-prop &#x27; + randomString); this.requestUpdate(); &#125; updated(changedProperties) &#123; changedProperties.forEach((oldValue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; changed. oldValue: $&#123;oldValue&#125;`); &#125;); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); reflectproperty가 변경될 때마다, attribute에 반영된다. 1myProp: &#123; reflect: true &#125; property가 수정되면, LitElement의 기능 중 하나인 toAttribute가 attribute를 수정한다. toAttribute가 null을 반환하면, attr은 제거된다. toAttribute가 undefined을 반환하면, attr은 수정되지 않는다. If toAttribute itself is undefined, the property value is set to the attribute value without conversion.(해봐야 알듯) code example1234567891011121314151617181920212223242526272829303132import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; myProp: &#123; reflect: true &#125; &#125;;&#125; constructor() &#123; super(); this.myProp=&#x27;myProp&#x27;; &#125; attributeChangedCallback(name, oldval, newval) &#123; console.log(&#x27;attribute change: &#x27;, newval); super.attributeChangedCallback(name, oldval, newval); &#125; render() &#123; return html` &lt;p&gt;$&#123;this.myProp&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;this.changeProperty&#125;&quot;&gt;change property&lt;/button&gt; `; &#125; changeProperty() &#123; let randomString = Math.floor(Math.random()*100).toString(); this.myProp=&#x27;myProp &#x27; + randomString; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); accessorsexample123456789101112131415161718192021222324252627282930import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop: &#123; type: Number &#125; &#125;; &#125; set prop(val) &#123; let oldVal = this._prop; this._prop = Math.floor(val); this.requestUpdate(&#x27;prop&#x27;, oldVal); &#125; get prop() &#123; return this._prop; &#125; constructor() &#123; super(); this._prop = 0; &#125; render() &#123; return html` &lt;p&gt;prop: $&#123;this.prop&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;() =&gt; &#123; this.prop = Math.random()*10; &#125;&#125;&quot;&gt; change prop &lt;/button&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); Prevent LitElement from generating a property accessor사용법123static get properties() &#123; return &#123; myProp: &#123; type: Number, noAccessor: true &#125; &#125;; &#125; noAccessor가 true면, prop이 getter와 setter 접근자에 의해 변경된다. noAccessor가 false면 getter와 setter가 사용되지 않는다. code examplesuper-element.js 123456789101112131415161718192021222324252627282930import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;export class SuperElement extends LitElement &#123; static get properties() &#123; return &#123; prop: &#123; type: Number &#125; &#125;; &#125; set prop(val) &#123; let oldVal = this._prop; this._prop = Math.floor(val); this.requestUpdate(&#x27;prop&#x27;, oldVal); &#125; get prop() &#123; return this._prop; &#125; constructor() &#123; super(); this._prop = 0; &#125; render() &#123; return html` &lt;p&gt;prop: $&#123;this.prop&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;() =&gt; &#123; this.prop = Math.random()*10; &#125;&#125;&quot;&gt; change prop &lt;/button&gt; `; &#125;&#125;customElements.define(&#x27;super-element&#x27;, SuperElement); sub-element.js 123456789import &#123; SuperElement &#125; from &#x27;./super-element.js&#x27;;class SubElement extends SuperElement &#123; static get properties() &#123; return &#123; prop: &#123; reflectToAttribute: true, noAccessor: true &#125; &#125;; &#125;&#125;customElements.define(&#x27;sub-element&#x27;, SubElement); Configure property changeshasChanged: prop이 변경됬는지 검사true가 반환되면, update를 실행한다. false가 반환되면, 변화가 없다는 뜻이다. 사용법1234567myProp: &#123; hasChanged(newVal, oldVal) &#123; if (newVal &gt; oldVal) &#123; return true &#125; else &#123; return false &#125;&#125;&#125; code example12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties()&#123; return &#123; myProp: &#123; type: Number, /** * Compare myProp&#x27;s new value with its old value. * * Only consider myProp to have changed if newVal is larger than * oldVal. */ hasChanged(newVal, oldVal) &#123; if (newVal &gt; oldVal) &#123; console.log(`$&#123;newVal&#125; &gt; $&#123;oldVal&#125;. hasChanged: true.`); return true; &#125; else &#123; console.log(`$&#123;newVal&#125; &lt;= $&#123;oldVal&#125;. hasChanged: false.`); return false; &#125; &#125; &#125;&#125;; &#125; constructor()&#123; super(); this.myProp = 1; &#125; render()&#123; return html` &lt;p&gt;$&#123;this.myProp&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;this.getNewVal&#125;&quot;&gt;get new value&lt;/button&gt; `; &#125; updated()&#123; console.log(&#x27;updated&#x27;); &#125; getNewVal()&#123; let newVal = Math.floor(Math.random()*10); this.myProp = newVal; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); Events목차 개요 이벤트 핸들러 추가 위치 this 사용 useCase Fire Event Custom-event handler Shadow Dom에서 이벤트 이벤트 버블링 이벤트 리타겟팅 커스텀 이벤트 개요이벤트 핸들러 추가 위치컴포넌트를 이용한 이벤트 추가@이벤트명을 이용 123render() &#123; return html`&lt;button @click=&quot;$&#123;this.handleClick&#125;&quot;&gt;`;&#125; Dom으로 추가되기 전에 받는 이벤트는 constructor()에서 선언1234constructor() &#123; super(); this.addEventListener(&#x27;DOMContentLoaded&#x27;, this.handleLoaded);&#125; firstUpdated()LifeCycle을 이용한 이벤트 추가, 처음으로 업데이트되거나 렌더링됬을 때 실행된다. 123firstUpdated(changedProperties) &#123; this.addEventListener(&#x27;click&#x27;, this.handleClick);&#125; connectedCallback()커스텀 엘리먼트에서 존재하던 LifeCycle. 엘리먼트가 Dom에 추가되면 발생하는 LifeCycle. disconnectedCallback()엘리먼트가 Dom에서 제거되면 발생하는 LifeCycle.connectedCallback에서 생성된 이벤트들을 여기서 제거해준다. 예제12345678connectedCallback() &#123; super.connectedCallback(); document.addEventListener(&#x27;readystatechange&#x27;, this.handleChange);&#125;disconnectedCallback() &#123; document.removeEventListener(&#x27;readystatechange&#x27;, this.handleChange); super.disconnectedCallback();&#125; this사용예제12345678class MyElement extends LitElement &#123; render() &#123; return html`&lt;button @click=&quot;$&#123;this.handleClick&#125;&quot;&gt;click&lt;/button&gt;`; &#125; handleClick(e) &#123; console.log(this.prop); &#125;&#125; Fire EventFire Custom Event12345678910111213class MyElement extends LitElement &#123; render() &#123; return html`&lt;div&gt;Hello World&lt;/div&gt;`; &#125; firstUpdated(changedProperties) &#123; let event = new CustomEvent(&#x27;my-event&#x27;, &#123; detail: &#123; message: &#x27;Something important happened&#x27; &#125; &#125;); this.dispatchEvent(event); &#125;&#125; Fire Standard Event123456789class MyElement extends LitElement &#123; render() &#123; return html`&lt;div&gt;Hello World&lt;/div&gt;`; &#125; updated(changedProperties) &#123; let click = new Event(&#x27;click&#x27;); this.dispatchEvent(click); &#125;&#125; LitElement 기반에 이벤트 핸들러 추가1&lt;my-element @my-event=&quot;$&#123;(e) =&gt; &#123; console.log(e.detail.message) &#125;&#125;&quot;&gt;&lt;/my-element&gt; 기본 방식12const myElement = document.querySelector(&#x27;my-element&#x27;);myElement.addEventListener(&#x27;my-event&#x27;, (e) =&gt; &#123;console.log(e)&#125;); Shadow Dom에서 이벤트이벤트 버블링버블링인지 아닌지 확인하는 방법 123handleEvent(e)&#123; console.log(e.bubbles);&#125; Event retargeting1&lt;my-element onClick=&quot;(e) =&gt; console.log(e.target)&quot;&gt;&lt;/my-element&gt; 123456render() &#123; return html` &lt;button id=&quot;mybutton&quot; @click=&quot;$&#123;(e) =&gt; console.log(e.target)&#125;&quot;&gt; click me &lt;/button&gt;`;&#125; 이벤트 발생원인 찾을 때123handleMyEvent(event) &#123; console.log(&#x27;Origin: &#x27;, event.composedPath()[0]);&#125; 커스텀 이벤트버블링은 Shadow Dom 내부에서 발생하기 때문에, Shadow-root에 도달하면 중지된다.만약 shadow-root를 통과하고 싶다면, 다음과같이 설정한다. 12345678firstUpdated(changedProperties) &#123; let myEvent = new CustomEvent(&#x27;my-event&#x27;, &#123; detail: &#123; message: &#x27;my-event happened.&#x27; &#125;, bubbles: true, composed: true &#125;); this.dispatchEvent(myEvent);&#125; LifeCycle목차 개요 Methods and Prop prop.hasChanged() requestUpdate() performUpdate() shouldUpdate() update() render() firstUpdated() updated() updateComplete() 예제 개요Update LifeCycle: property 설정. 업데이트 필요한지 확인, 필요하다면 요청. 업데이트 Process properties and attributes. Render the element. Resolve a Promise, indicating that the update is complete. LitElement and the browser event loopThe browser executes JavaScript code by processing a queue of tasks in the event loop.In each iteration of the event loop, the browser takes a task from the queue and runs it to completion. When the task completes, before taking the next task from the queue,the browser allocates time to perform work from other sources—including DOM updates, user interactions, and the microtask queue. By default, LitElement updates are requested asynchronously, and queued as microtasks.This means that Step 3 above (Perform the update) is executed at the end of the next iteration of the event loop. You can change this behavior so that Step 3 awaits a Promise before performing the update.See performUpdate for more information. For a more detailed explanation of the browser event loop, see Jake Archibald’s article. 흠냐… 코드가 없어서 생략 Lifecycle callbacks connectedCallback: Invoked when a component is added to the document’s DOM. disconnectedCallback: Invoked when a component is removed from the document’s DOM. adoptedCallback: Invoked when a component is moved to a new document. attributeChangedCallback: Invoked when component attribute changes. Be aware that adoptedCallback is not polyfilled. 커스텀 엘리먼트와 동일함 Promises and asynchronous functions12345678910// `async` makes the function return a Promise &amp; lets you use `await`async myFunc(data) &#123; // Set a property, triggering an update this.myProp = data; // Wait for the updateComplete promise to resolve await this.updateComplete; // ...do stuff... return &#x27;done&#x27;;&#125; Method and Propprop.hasChanged()prop이 변경됬는지 검사 requestUpdate()return값, PromiseReturns the updateComplete Promise, which resolves on completion of the update. 12345// Manually start an updatethis.requestUpdate();// Call from within a custom property setterthis.requestUpdate(propertyName, oldValue); 왜 oldValue를 집어넣는거지?, 아무거나 집어넣어도 update를 하는 것으로 확인(다른 method에서 oldValue를 쓰나?) 이전: 요소 업데이트를 수동으로 했을 경우12345678910111213141516171819202122232425import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; constructor() &#123; super(); // Request an update in response to an event this.addEventListener(&#x27;load-complete&#x27;, async (e) =&gt; &#123; console.log(e.detail.message); console.log(await this.requestUpdate()); &#125;); &#125; render() &#123; return html` &lt;button @click=&quot;$&#123;this.fire&#125;&quot;&gt;Fire a &quot;load-complete&quot; event&lt;/button&gt; `; &#125; fire() &#123; let newMessage = new CustomEvent(&#x27;load-complete&#x27;, &#123; detail: &#123; message: &#x27;hello. a load-complete happened.&#x27; &#125; &#125;); this.dispatchEvent(newMessage); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); getter, setter 으로, 사용했을 경우123456789101112131415161718192021222324252627282930import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop: &#123; type: Number &#125; &#125;; &#125; set prop(val) &#123; let oldVal = this._prop; this._prop = Math.floor(val); this.requestUpdate(&#x27;prop&#x27;, oldVal); &#125; get prop() &#123; return this._prop; &#125; constructor() &#123; super(); this._prop = 0; &#125; render() &#123; return html` &lt;p&gt;prop: $&#123;this.prop&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;() =&gt; &#123; this.prop = Math.random()*10; &#125;&#125;&quot;&gt; change prop &lt;/button&gt; `; &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); performUpdate()return값, void or Promise 1234567/** * Implement to override default behavior. */async performUpdate() &#123; await new Promise((resolve) =&gt; requestAnimationFrame(() =&gt; resolve())); super.performUpdate();&#125; Full example code1234567891011121314151617181920212223242526272829import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop1: &#123; type: Number &#125; &#125;; &#125; constructor() &#123; super(); this.prop1 = 0; &#125; render() &#123; return html` &lt;p&gt;prop1: $&#123;this.prop1&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;() =&gt; this.prop1=this.change()&#125;&quot;&gt;Change prop1&lt;/button&gt; `; &#125; async performUpdate() &#123; console.log(&#x27;Requesting animation frame...&#x27;); await new Promise((resolve) =&gt; requestAnimationFrame(() =&gt; resolve())); console.log(&#x27;Got animation frame. Performing update&#x27;); super.performUpdate(); &#125; change() &#123; return Math.floor(Math.random()*10); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); shouldUpdate(changedProperties)return값, BooleanIf true, update proceeds. Default return value is true. updates: YES 특정 prop이 바뀔 때만 업데이트를 시킬 수 있음 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop1: &#123; type: Number &#125;, prop2: &#123; type: Number &#125; &#125;; &#125; constructor() &#123; super(); this.prop1 = 0; this.prop2 = 0; &#125; render() &#123; return html` &lt;p&gt;prop1: $&#123;this.prop1&#125;&lt;/p&gt; &lt;p&gt;prop2: $&#123;this.prop2&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;() =&gt; this.prop1=this.change()&#125;&quot;&gt;Change prop1&lt;/button&gt; &lt;button @click=&quot;$&#123;() =&gt; this.prop2=this.change()&#125;&quot;&gt;Change prop2&lt;/button&gt; `; &#125; /** * Only update element if prop1 changed. */ shouldUpdate(changedProperties) &#123; changedProperties.forEach((oldValue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; changed. oldValue: $&#123;oldValue&#125;`); &#125;); // prop1이 바뀔 때만, update return changedProperties.has(&#x27;prop1&#x27;); &#125; change() &#123; return Math.floor(Math.random()*10); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); update(changedProperties)Reflects property values to attributes and calls render to render DOM via lit-html. Provided here for reference. You don’t need to override or call this method. render()return값, TemplateResult firstUpdated(changedProperties)Updates: YES Updated 이전에 호출된다. 12345678910111213141516171819202122232425262728import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; textAreaId: &#123; type: String &#125;, startingText: &#123; type: String &#125; &#125;; &#125; constructor() &#123; super(); this.textAreaId = &#x27;myText&#x27;; this.startingText = &#x27;Focus me on first update&#x27;; &#125; render() &#123; return html` &lt;textarea id=&quot;$&#123;this.textAreaId&#125;&quot;&gt;$&#123;this.startingText&#125;&lt;/textarea&gt; `; &#125; firstUpdated(changedProperties) &#123; changedProperties.forEach((oldValue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; changed. oldValue: $&#123;oldValue&#125;`); &#125;); const textArea = this.shadowRoot.getElementById(this.textAreaId); textArea.focus(); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); updated(changedProperties)Updates: YES 12345678910111213141516171819202122232425262728293031323334import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop1: &#123; type: Number &#125;, prop2: &#123; type: Number &#125; &#125;; &#125; constructor() &#123; super(); this.prop1 = 0; this.prop2 = 0; &#125; render() &#123; return html` &lt;style&gt;button:focus &#123; background-color: aliceblue; &#125;&lt;/style&gt; &lt;p&gt;prop1: $&#123;this.prop1&#125;&lt;/p&gt; &lt;p&gt;prop2: $&#123;this.prop2&#125;&lt;/p&gt; &lt;button id=&quot;a&quot; @click=&quot;$&#123;() =&gt; this.prop1=Math.random()&#125;&quot;&gt;prop1&lt;/button&gt; &lt;button id=&quot;b&quot; @click=&quot;$&#123;() =&gt; this.prop2=Math.random()&#125;&quot;&gt;prop2&lt;/button&gt; `; &#125; updated(changedProperties) &#123; changedProperties.forEach((oldValue, propName) =&gt; &#123; console.log(`$&#123;propName&#125; changed. oldValue: $&#123;oldValue&#125;`); &#125;); let b = this.shadowRoot.getElementById(&#x27;b&#x27;); b.focus(); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); updateComplete()12345await this.updateComplete;// do stuff// orthis.updateComplete.then(() =&gt; &#123; /* do stuff */ &#125;); 예제123456789101112131415161718192021222324252627282930313233import &#123; LitElement, html &#125; from &#x27;lit-element&#x27;;class MyElement extends LitElement &#123; static get properties() &#123; return &#123; prop1: &#123; type: Number &#125; &#125;; &#125; constructor() &#123; super(); this.prop1 = 0; &#125; render() &#123; return html` &lt;p&gt;prop1: $&#123;this.prop1&#125;&lt;/p&gt; &lt;button @click=&quot;$&#123;this.changeProp&#125;&quot;&gt;prop1&lt;/button&gt; `; &#125; async getMoreState() &#123; return; &#125; async changeProp() &#123; this.prop1 = Math.random(); await Promise.all([this.updateComplete, this.getMoreState()]); console.log(&#x27;Update complete. Other state completed.&#x27;); &#125;&#125;customElements.define(&#x27;my-element&#x27;, MyElement); 예제Control when updates are processedperformUpdate1234async performUpdate() &#123; await new Promise((resolve) =&gt; requestAnimationFrame(() =&gt; resolve()); super.performUpdate();&#125; Customize which property changes should cause an updateshouldUpdate123shouldUpdate(changedProps) &#123; return changedProps.has(&#x27;prop1&#x27;);&#125; Customize what constitutes a property changehasChanged()Manage property changes and updates for object subpropertiesMutations (changes to object subproperties and array items) are not observable.Instead, either rewrite the whole object, or call requestUpdate after a mutation. 123456// Option 1: Rewrite whole object, triggering an updatethis.prop1 = Object.assign(&#123;&#125;, this.prop1, &#123; subProp: &#x27;data&#x27; &#125;);// Option 2: Mutate a subproperty, then call requestUpdatethis.prop1.subProp = &#x27;data&#x27;;this.requestUpdate(); 아하, requestUpdate()는 prop.subProp의 변화를 감지해주네 Update in response to something that isn’t a property changerequestUpdate12345// Request an update in response to an eventthis.addEventListener(&#x27;load-complete&#x27;, async (e) =&gt; &#123; console.log(e.detail.message); console.log(await this.requestUpdate());&#125;); Request an update regardless of property changes1this.requestUpdate(); Request an update for a specific property123let oldValue = this.prop1;this.prop1 = &#x27;new value&#x27;;this.requestUpdate(&#x27;prop1&#x27;, oldValue); Do something after the first update123firstUpdated(changedProps) &#123; console.log(changedProps.get(&#x27;prop1&#x27;));&#125; Do something after every update123updated(changedProps) &#123; console.log(changedProps.get(&#x27;prop1&#x27;));&#125; Do something when the element next updates12345678await this.updateComplete;// do stuff// orthis.updateComplete.then(() =&gt; &#123; // do stuff&#125;); Wait for an element to finish updating123456let done = await updateComplete;// orupdateComplete.then(() =&gt; &#123; // finished updating&#125;); 123updateComplete.then(() &#x3D;&gt; &#123; &#x2F;&#x2F; finished updating&#125;); Publish an elementnpm으로 게시하는 방법ES2017이상 문법으로 작성하는 것을 추천. 그렇지 않다면, 변환을 해야함 package.json 수정1234&#123; &quot;main&quot;: &quot;my-element.js&quot;, &quot;module&quot;: &quot;my-element.js&quot;&#125; 사용방법 README 작성npm packages 가이드에 따라 작성한글 가이드 블로그 글Transpiling with BabelTo transpile a LitElement component that uses proposed JavaScript features, use Babel. Install Babel and the Babel plugins you need. For example: 123npm install --save-dev @babel/corenpm install --save-dev @babel/plugin-proposal-class-propertiesnpm install --save-dev @babel/plugin-proposal-decorators Configure Babel. For example: babel.config.js123456const plugins = [ &#x27;@babel/plugin-proposal-class-properties&#x27;, [&#x27;@babel/plugin-proposal-decorators&#x27;, &#123; decoratorsBeforeExport: true &#125; ],];module.exports = &#123; plugins &#125;; You can run Babel via a bundler plugin such as rollup-plugin-babel, or from the command line. See the Babel documentation for more information. Use a component목차 lit-element 사용하기 Build for production Polyfill lit-element 사용하기 npm install 모듈명 1npm install some-package-name Javascript에서 사용 1import &#x27;some-package-name&#x27;; HTML에서 사용 123&lt;script type=&quot;module&quot;&gt;import &#x27;./path-to/some-package-name/some-component.js&#x27;;&lt;/script&gt; Or: 1&lt;script type=&quot;module&quot; src=&quot;./path-to/some-package-name/some-component.js&quot;&gt;&lt;/script&gt; 이후, READE에 따른 컴포넌트 사용 1&lt;some-component&gt;&lt;/some-component&gt; Build for productionwebpack과 비슷한 rollup을 써서 하는 듯 123456789101112131415import resolve from &#x27;rollup-plugin-node-resolve&#x27;;export default &#123; // If using any exports from a symlinked project, uncomment the following: // preserveSymlinks: true, input: [&#x27;src/index.js&#x27;], output: &#123; file: &#x27;build/index.js&#x27;, format: &#x27;es&#x27;, sourcemap: true &#125;, plugins: [ resolve() ]&#125;; rollup과 webpack3을 비교하는 글을 읽고 요약해봄(그런데 지금은 webpack4잖아?) rollup 장점 webpack은 ESM형태 번들이 안된다고함 (ts -&gt; js ?) webpack은 빌드시, 중복코드 제거기능이 없다고함 Webpack 에서는 import는 __webpack_require__로 바뀌고 export는 exports 오브젝트로 바뀌면서 코드가 증가합니다.그래서 상수를 사용하면 상수 이름을 그대로 쓰고 uglify가 되지 않기 때문에 오히려 코드가 증가할 수 있습니다.Webpack에서도 ModuleConcatenationPlugin이 있어 Rollup과 비슷한 효과를 볼 수 있습니다.하지만 typescript, babel 플러그인을 통해 생긴 함수의 중복은 제거할 수 없습니다.대표적인 예로 assign, extends 등과 같이 ES6 이상의 문법을 ES5로 바꾸면서 생기는 polyfill이 있습니다.이 함수는 파일(모듈)마다 존재하고 각자 다른 함수로 인식해 파일 개수만큼 늘어납니다. webpack이 평균 빌드 용량이 큰 듯 webpack3에서 Tree Shaking이 잘 안된다고 함 rollup 단점 entry(input, output)가 많아질수록 복잡해질 수 있습니다. plugin의 규칙을 정할 수 없습니다. 흐음… 내가 rollup으로 바꿀 수가 있나? webpack에 의존되는 기술이 뭐가 있지?css파일모아 합치기, scss, babel, postcss(autoprefixer), webpack-dev-server생각보다 의존성이 있네… 그런데 webpack4에서 극복한 느낌이군 Polyfill폴리필 하는법 npm install 1npm install --save-dev @webcomponents/webcomponentsjs HTML Script 추가 12345678910111213141516171819202122&lt;head&gt; &lt;script src&#x3D;&quot;.&#x2F;path-to&#x2F;custom-elements-es5-loader.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;path-to&#x2F;webcomponents-loader.js&quot; defer&gt; &lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;module&quot;&gt; &#x2F;&#x2F; Take care of cases in which the browser runs this &#x2F;&#x2F; script before it has finished running &#x2F;&#x2F; webcomponents-loader.js (e.g. Firefox script execution order) window.WebComponents &#x3D; window.WebComponents || &#123; waitFor(cb)&#123; addEventListener(&#39;WebComponentsReady&#39;, cb) &#125; &#125; WebComponents.waitFor(async () &#x3D;&gt; &#123; import(&#39;.&#x2F;path-to&#x2F;some-element.js&#39;); &#125;); &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;some-element&gt;&lt;&#x2F;some-element&gt;&lt;&#x2F;body&gt; Ensure that node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js and node_modules/@webcomponents/webcomponentsjs/bundles/**.* are included in your build. Do not transpile the polyfills. Bundling them is okay. 아직 lit-element를 잘 모르는 상태로 작업한 문서기 때문에,추후 프로젝트에 많이 사용한 뒤 요약본을 다시 작성해야겠다. 작성해보니, lit-html에 이은 스택이지만, lit-html의 모든 docs를 담진 않았네당장 이벤트 캡쳐링 부분도 없고, 123456789clickTest() &#123; const root = this return &#123; handleEvent(event) &#123; console.log(`event!`) &#125;, capture: false, &#125;&#125;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"lit-element","slug":"lit-element","permalink":"https://taeuk-gang.github.io/tags/lit-element/"}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"}]},{"title":"Mutation Observer 잘 쓰이는 코드 기록","date":"2019-08-28T13:25:04.000Z","path":"wiki/Js-mutation-observer/","text":"Mutation Observer 코드12345678910111213141516171819202122const observer = new MutationObserver(mutations =&gt; &#123; mutations.forEach(mutation =&gt; &#123; console.log(mutation) &#125;)&#125;)observer.observe(document.querySelector(`#div-exam`), &#123; attributes: true, childList: true, characterData: true, subtree: true || null, attributeOldValue: true || null, characterDataOldValue: true || null,&#125;)document.querySelector(`#attr`).addEventListener(`click`, () =&gt; &#123; target.setAttribute(`class`, `attr`)&#125;)document.querySelector(`#child`).addEventListener(`click`, () =&gt; &#123; document.querySelector(`#div-exam`).textContent = `changed!`&#125;) 나중에, 이걸 써서 프로젝트를 다시 해보자","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"}]},{"title":"이슈 - VScode Editor에서 탭해도 ESLint 경고 뜨는 현상","date":"2019-08-26T14:36:59.000Z","path":"wiki/Issue-vscode-indent/","text":"ESLint “indent”: [1, “tab”] 안먹는 현상 해결 VSCode 설정으로 들어간다.(Ctrl + , 입력) Detect Indentation 체크를 미표시로 설정 이후, 에디터에서 확인","tags":[{"name":"Issue","slug":"Issue","permalink":"https://taeuk-gang.github.io/tags/Issue/"}],"categories":[{"name":"Issue","slug":"Issue","permalink":"https://taeuk-gang.github.io/categories/Issue/"}]},{"title":"Git 이슈·PR 템플릿 등록","date":"2019-08-25T12:43:45.000Z","path":"wiki/Git-template/","text":"이슈 템플릿 등록 방법Git UI를 이용한 방법 Git Repo 메뉴 중 Insight - Community 메뉴를 클릭 CheckList 중 Issue templates Add 버튼을 클릭 이슈별 항목들을 만든다. (기본값으로, Bug, Feature 항목이 존재한다.) 원하는 항목을 만들 때는, custom template를 클릭 이슈 작성하기를 눌러 확인 Git Push를 이용한 방법 레포 최상단 폴더 위치에 .github/ISSUE_TEMPLATE 폴더를 생성 ISSUE_TEMPLATE 폴더 내에 README 작성 양식 예시123456789101112131415161718192021222324252627282930313233---name: Bug reportabout: Create a report to help us improvetitle: &quot;제목&quot;labels: bugassignees: &#x27;&#x27;---## 버그 내용 ## 재현 과정 1. Go to &#x27;...&#x27;2. Click on &#x27;....&#x27;3. Scroll down to &#x27;....&#x27;4. See error## 우려 사항## 스크린샷 ## 환경(Desktop)- OS: [e.g. iOS]- Browser [e.g. chrome, safari]- Version [e.g. 22] ## 환경(Mobile)- Device: [e.g. iPhone6]- OS: [e.g. iOS8.1]- Browser [e.g. stock browser, safari]- Version [e.g. 22] ## 기타 master에 push하고 이슈를 작성하여 확인 상세 스크린샷 과정Git UI를 이용 이름 이미지 과정1 과정2 과정3 PR 템플릿 등록 방법Git Repo에서 PR 템플릿 등록은 지원하지 않는다. 그러므로, Git Repo에 특정 파일을 Push 해야한다. Git Repo 최상단 위치에 .github 폴더 생성 .github 폴더 내에 PULL_REQUEST_TEMPLATE.md 이름으로 파일을 생성한다. (양식은 자유) Git Repo로 PR을 날려, 양식이 적용됬는지 확인한다.","tags":[{"name":"Git","slug":"Git","permalink":"https://taeuk-gang.github.io/tags/Git/"}],"categories":[{"name":"Git","slug":"Git","permalink":"https://taeuk-gang.github.io/categories/Git/"}]},{"title":"오픈 튜브 프로젝트 일지","date":"2019-08-24T14:12:45.000Z","path":"wiki/Project-open-tube/","text":"1차 작업 일지요약1차 레이아웃 작업 내용 ㅇㅅㅇ 구현사항 SCSS + Autoprefixer 추가 로그인 페이지 / 메인 페이지 구현 로그인 구현 (firebase Auth - Apache 2.0 이용) 폴더구조 변경 상세사항은 아래에 작성 크로스 플랫폼 고려 (모바일 환경 고려) 상세사항은 아래에 작성 IE 지원 X 그리드 자동배치, 파이어베이스 미지원으로 인하여 지원 종료 Shadow DOM 제거 - FOUC 현상으로 인하여 제거 코드 테스트 방법로그인 확인 구글 로그인 여부 확인 라우팅 처리 잘 되어있는지 확인비로그인시 /report 라우팅 접속 불가 폴더구조 확인 삭제된 파일 및 이동된 폴더 검사 모바일 창에서 확인 브라우저 크기를 작게하여 확인 IE 미지원 확인 IE 에서 접속시, 해당 브라우저는 지원되지 않습니다. 문구 표시 스크린샷로그인 페이지 이름 이미지 로그인 메인 페이지 이름 이미지 메인 모바일 창 GIF 캡쳐 프로그램 오류로, 색 변조 존재함…. (하늘색 무시해줘용) 이름 이미지 로그인 폴더구조 변경📦client ┣ 📂.storybook ┃ ┗ 📜config.js ┣ 📂functions ┃ ┣ 📜.eslintrc.json ┃ ┣ 📜.gitignore ┃ ┣ 📜index.js ┃ ┣ 📜package-lock.json ┃ ┗ 📜package.json ┣ 📂public ┃ ┣ 📂src ┃ ┃ ┗ 📂css ┃ ┃ ┃ ┣ 📜foundation.min.css ┃ ┃ ┃ ┗ 📜style.css # 추가 - SCSS 번들링 파일 ┃ ┣ 📜index.css ┃ ┗ 📜index.html ┣ 📂src ┃ ┣ 📂components ┃ ┃ ┣ 📜app-footer.js ┃ ┃ ┣ 📜filter-list.js ┃ ┃ ┣ 📜nav-top.js ┃ ┃ ┗ 📜report-list.js ┃ ┣ 📂libs # 삭제 - LitRender 파일 삭제 ┃ ┃ ┣ 📜actions.js ┃ ┃ ┣ 📜i18n.js ┃ ┃ ┣ 📜redux-zero.js ┃ ┃ ┗ 📜store.js ┃ ┣ 📂pages # 추가 - 페이지별 JS파일 별도 관리 ┃ ┃ ┣ 📜page-login.js ┃ ┃ ┗ 📜page-reports.js ┃ ┣ 📂scss # 추가 - SCSS 파일 모음 ┃ ┃ ┣ 📂components ┃ ┃ ┃ ┣ 📜app-footer.scss ┃ ┃ ┃ ┣ 📜filter-list.scss ┃ ┃ ┃ ┣ 📜nav-top.scss ┃ ┃ ┃ ┗ 📜report-list.scss ┃ ┃ ┣ 📂pages ┃ ┃ ┃ ┣ 📜page-login.scss ┃ ┃ ┃ ┣ 📜page-reports.scss ┃ ┃ ┃ ┗ 📜vars.scss ┃ ┃ ┗ 📜main.scss ┃ ┣ 📂stories ┃ ┃ ┗ 📜index.stories.js ┃ ┣ 📂_locale # 추가 - 언어리소스 모음 ┃ ┃ ┗ 📜ko.js ┃ ┗ 📜main.js ┣ 📂test ┃ ┗ 📜index.html ┣ 📜.babelrc ┣ 📜.codebeatignore ┣ 📜.eslintignore ┣ 📜.eslintrc.js ┣ 📜.firebaserc ┣ 📜.gitignore ┣ 📜.travis.yml ┣ 📜database.rules.json ┣ 📜firebase.json ┣ 📜firestore.indexes.json ┣ 📜firestore.rules ┣ 📜package-lock.json ┣ 📜package.json ┣ 📜postcss.config.js ┣ 📜README.md ┣ 📜storage.rules ┣ 📜wct.conf.json ┗ 📜webpack.config.js 기타 2차 작업 일지요약 일반 유저와 관리자를 uid를 통해 구분하는 코드를 작성했으며, 사용자가 우리 서비스에 레포트를 요청할 수 있는 모달창을 구현했습니다. 구현 사항 firebase.auth ~ uid를 통해, 관리자ID 구별 (서버리스 함수로 구현) CSS duplicate 되던 버그 수정 쉬운 아이콘 사용을 위해 Foundation-icon 모듈 추가 (자세한 사항] 레포트 요청 모달창 구현 (아래의 스크린샷 첨부) 코드 테스트 방법유저 이름 확인 로그인 페이지에서 로그인을 하여, 메인 페이지 상단바의 사용자 이름이 뜨는지 확인 레포트 요청 모달창 확인 메인 페이지에서 레포트 요청 버튼을 클릭하여 정상 표시되는지 확인 스크린샷 이름 이미지 사용자 이름 이름 이미지 모달창 기타 3차 작업 일지요약 더미 API를 받고, 레포트를 불러오는 기능과 레포트 모달창 구현 구현 사항 더미 API 작성(레포트 상태, 영상제목, URL) 레포트 UI 추가 레포트 Router 추가 코드 테스트 방법 구글 open.tube.service 계정으로 로그인 (슬랙: info에 ID/PW 있음) 레포트가 정상적으로 받아오는지 확인 레포트를 클릭하여 모달창 뜨는지 확인 스크린샷 이름 이미지 더미 DB 이름 이미지 더미 API 이름 이미지 메인 페이지 이름 이미지 메인 페이지 기타 close #44 4차 작업 일지요약 웹팩 번들링 파일 분석을 위한 모듈 추가 및 라우팅 최적화 구현 사항 webpack-stylish, webpack-visualizer-plugin 모듈 추가 기능 설명: 각 모듈의 파일 사이즈, 번들링 시간 등을 파악 라우팅 최적화 firebaseui cdn -&gt; 로컬로 변경, 네트워크에서 느리게 받아오는 것을 확인하여 변경 코드 테스트 방법 각 리뷰어가 확인할 사항 없음 스크린샷 No ScreenShot 기타 5차 작업 일지요약 레포트 페이지 구현 및 CSS 테마1 적용 구현 사항 레포트 - 영상 삽입 (동적 이용을 위해 Youtube Iframe API 사용) 레포트 - 영상 기본 정보 레포트 - 얼굴 인식 레포트 - 댓글 분석 레포트 - 키워드 분석 코드 테스트 방법 https://open-tube.web.app 접속 open.tube.service 구글 ID 로그인 ID의 부여된 4개의 레포트 테스팅 스크린샷 이름 이미지 로그인 페이지 이름 이미지 메인 페이지 이름 이미지 요청 페이지 History API 수정 전으로, 아직 API 연결 안함 (아직 Status 분류가 되어있지 않음) 이름 이미지 영상정보 및 얼굴인식 Seconds Link 클릭시, 그 시간대로 영상 재생 이름 이미지 댓글 분석 각 항목별 오른차순·내림차순 정렬 가능 이름 이미지 키워드분석 특이 사항 Youtube Iframe API 사용 Word-Cloud 오픈소스(MIT) 사용 기타 closed issue #58 6차 작업 일지요약레포트 상태 분류 / API 연결 / GIF 설명 삽입 구현 사항 레포트 - 상태 분류 표시 (대기/ 분석/ 완료) 모달 메세지 컴포넌트 추가 레포트 요청 API 연결 로그인 GIF 설명 추가 코드 테스트 방법 https://open-tube.web.app 접속 open.tube.service 구글 ID 로그인 ID의 부여된 4개의 레포트 테스팅 스크린샷 이름 이미지 최종상태 기타 7차 작업 일지요약 자잘한 버그 수정 기타","tags":[{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/tags/Projects/"},{"name":"open-tube","slug":"open-tube","permalink":"https://taeuk-gang.github.io/tags/open-tube/"}],"categories":[{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/categories/Projects/"},{"name":"open-tube","slug":"Projects/open-tube","permalink":"https://taeuk-gang.github.io/categories/Projects/open-tube/"}]},{"title":"자바스크립트를 말하다 (2)","date":"2019-08-19T13:11:11.000Z","path":"wiki/Book-tell-javascript-2/","text":"Why Javascript?Speaking Javascript 책을 읽으며, 특별히 눈에 들어왔던 내용만 기록한 것으로 옛날 내용이 많습니다. 프로그래밍 언어를 쓸 때, 선택하는 기준 7가지 무료로 사용 가능한가? 명쾌한가? 현실적으로 유용한가? 좋은 도구, IDE가 있는가? 필요한 일을 빨리할 수 있는가? 널리 쓰이는가? 장래성이 좋은가? 1. 무료 여부 YES, TC39 위원회는 주요 브라우저 제조사를 포함해 여러 회사로 구성, 자바스크립트의 발전을 위해 일함 TC39 위원회가 뭘까… 2. 명쾌한가?명쾌하진 않지만 유연한 언어, 객체지향과 함수형 프로그래밍을 동시에 사용할 수 있는 언어 test262 프로그램 가 사용되면서, 엔진 사이의 명세 준수도를 체크했었음 브라우저와 DOM의 차이점을 해결하기 위해 프레임워크를 사용 3. 유용한가?HTML5의 혜택으로 인하여, 운영체제를 가리지 않는 애플리케이션 플랫폼이 됨예전에는 OS간의 호환을 크로스 플랫폼이라고 했지만, 현재는 웹과 모바일이라는 대화형 플랫폼이 추가됨 HTML5을 기반으로, 폰갭, 확장프로그램, TideSDK 등 플랫폼 등을 지원할 수 있게 됨 보완하는 여러 라이브러리, Node.js, JSON, NoSQL 등이 존재 4. 좋은 도구 여부Grunt, mocha 등 테스트환경 + Node.js를 통한 브라우저 제약 탈피 5. 속도느린 인터프리터 -&gt; 빠른 적시 컴파일러로 빠른 발전, 애플리케이션 대부분이 이정도의 성능에 만족하지만, 영상처리, 게임 등을 위한 아이디어가 개발 중 6. 널리 쓰이는가?널리 쓰이는 언어의 2가지 혜택 좋은 문서화 고용의 기회와 수요가 많음 7. 장래성단독 기업이 아닌, 여러 회사 및 커뮤니티에서의 발전으로 어느 하나의 좌지우지 되지않음 자바스크립트 성질동적실행 중에 바뀔 수 있음, 객체 생성 후, 자유롭게 프로퍼티를 추가, 제거가 가능 타입이 동적변수와 객체 프로퍼티 값 타입에 제한이 없음 함수형 + 객체지향적함수형: 일급 객체 함수, 클로저 , bind()를 통한 부분 어플리케이션, map(), reduce() 객체지향: 객체, 상속 조용한 실패 ECMAscript 3에서 예외 처리 구현됨자바스크립트는 종종 자동으로 타입을 바꾸거나, 에러가 있어도 조용히 실패함 으음… 그래서 항상 ESLint Rule을 보면서, 어느사항을 체크해줘야하는지 사용자가 수동으로 알아야…. 소스코드 상태로 배포 항상 소스 코드 상태로 배포, 자바스크립트 엔진에서 컴파일 파일 크기를 줄이는 테크닉(gzip 처리), 최소화(변수명 변경, 주석제거, 공백제거 등) webpack의 발전으로 여러가지가 간편화되서 좋아짐 웹 플랫폼은 일부분이다node.js, electron 등 여러 다른 플랫폼의 사용할 가능성이 있음 변덕과 특이블록 수준의 스코프, 모듈, 하위 클래스가 이전까지는 빠져있었음 현재는 const, let, import, class 등 여러 기능이 생김 자바스크립트 명세에는 정수가 없고 오직 부동소수점 숫자만 존재, 내부적으로 대부분의 스크립트 엔진이 가능한 정수를 사용 배열이 인덱스를 매기는 것이 아닌, 숫자와 요소를 연결인덱스와 연결된 값이 없을 수 있음. 영향자바스크립트의 영향을 준 언어 자바(문법), 펄(문자열, 배열, 정규표현식), 스키마(클로저, 환경), 하이퍼토크(onEvent), 셀프(프로토타입 상속), 오크(함수) ECMAscript 역사ECMA 1초판 ECMA 2ECMA-262 ISO/IEC 16262 표준과 맞춤 ECMA 3do-while, 정규표현식, 새 문자열 메서드 (concat, match, replace, slice, split과 정규표현식), 예외 처리 ECMA 4ML로 시작한 자바스크립트 다음 프토토타입이었지만, TC39는 이 버전을 수용하지 않음 교착 상태에 빠지는 걸 막기 위해 핵심 4가지 기능만 수용 ECMA 3을 점진적으로 업데이트 (이후 ECMA 5가 됨) ECMA 4보다는 덜 급진적이지만, 더 발전된 주요버전을 만든다 package, namespace, 빠른 바인딩 등 ECMA 4 일부 기능은 제외 다른 아이디어는 TC39 위원이 모두 동의하면 개발한다 ECMA 5스트릭트 모드, getter, setter, 새 배열 메서드, JSON 지원 ECMA 5.1ECMA-262를 ISO/IEC 16262:2011 국제표준 3판과 맞춤 ECMA 6이 책을 집필할 때는 개발 중이었나 보다. 이 후, 따로 한 컬럼으로 추가 작성해야 할 듯 간략한 역사1997 Dynamic HTML1999 XMLHttpRequest2001 JSON = Javascript Object Notation2004 Dojo 툴킷, 대규모 프레임워크2005 Ajax, 브라우저 기반 애플리케이션 Ajax는 웹 페이지 응답성과 조작성을 데스크톱 수준으로 올린 기술들의 총칭 대표적 사례 구글맵스 Asynchronous Javascript and XML 비동기적 자바스크립트와 XMLAjax를 AJAX로 쓰면안됨, 약어가 아님 이후, HTTP와 웹소켓 사용 증가와 양방향 통신이 가능해짐 2005 아파치, CouchDB, 자바스크립트 중심 DB2006 jQuery, DOM 조작 지원자브라우저의 차이점을 추상화함으로써 메꾸는 조력자 2007 웹킷, 모바일웹을 주류로애플이 KDE에 기초해 웹킷 HTML 엔진을 제작, 오픈소스로 공개아이폰 출시로 인해 모바일 환경이 주류로 뜸 2008 V8 자바스크립트에 속도를구글이 크롬 웹 브라우저를 출시하며, V8 엔진의 속도를 강점으로 내세움 V8은 임베디드 소드이며, 빠른 임베디드 언어가 필요할 때 구성요소로 채택도 가능 2009 Node.js, 서버 자바스크립트Node.js는 이벤트 기반, 비동기적 I/O와 V8을 지원Node.js 창시자 라이언 달은 다음의 이유로 자바스크립트를 선택 I/O API가 포함되있지 앟음, 독자적인 비동기적 API를 구현 웹 개발자들이 이미 자바스크립트를 사용 DOM API는 이벤트 기반, 자바스크립트 개발자들은 이미 스레드없이 이벤트 루프에서 프로그래밍하는데 익숙이미 비동기적 코딩에 익숙 서버와 같은 언어를 쓴다는 것은 코드를 더 많이 공유할 수 있다는 것을 의미하며 (유효성 데이터 검사 등), 동형 자바스크립트 같은 테크닉이 사용 가능 해짐 동형 자바스크립트의 장점, 첫화면이 빨리 표시, 검색 엔진 최적화에 유리, 낮은 버전의 자바스크립트 환경에도 문제가 없음 2009 폰갭, HTML5 네이티브 애플리케이션 작성2009 크롬 OS, 브라우저를 운영체제로","tags":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/tags/Book/"},{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"}],"categories":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/categories/Book/"}]},{"title":"자바스크립트를 말하다 (1)","date":"2019-08-16T06:40:19.000Z","path":"wiki/Book-tell-javascript/","text":"자바스크립트를 말하다 (1) 복습Speaking Javascript 책을 읽으며, 특별히 눈에 들어왔던 내용만 기록 Statement(문)과 Expression(표현식)1var foo; 문은 ‘동작’을 의미하며, 프로그램은 기본적으로 문의 연속입니다. 12345678// 표현식var x = y &gt;= 0 ? y : -y;// 이런식으로도 가능func(y &gt;= 0 ? y : -y)// 이런 것도 표현식foo(7, 1); 표현식은 값을 생성하며, 함수 매개변수와 할당문의 오른편을 말합니다. 원시값다음은 모두 원시 값*입니다. 불리언: true, false 숫자: 1736, 1.351 문자열: ‘abc’ 값 아닌 값: undefined, null 특징1: 항상 불변프로퍼티를 변경, 추가, 제거 할 수 없음 123456let str = &#x27;abc&#x27;;str.length = 1;console.log(str.length); // 3 &lt;= 효과없음str.foo = 3;console.log(str.foo); // undenfined &lt;= 마찬가지 객체 = 원시값이 아닌 것종류1: 객체 리터럴1234&#123; firstName: `taeuk`, lastName: `Kang`&#125; 종류2: 배열 리터럴1[1,2,3] 종류3: 정규표현식 리터럴1/^a+b+$/ 특징1: 유일성을 비교하며, 값이 같더라도 엄연히 다르다참조 비교시 12345678const empty1 = &#123;&#125;;const empty2 = &#123;&#125;;console.log(empty1 === empty2); // false// 얇은 복사는 참조만 가져오기에 같다고 함const obj1 = &#123;&#125;;const obj2 = obj1;console.log(obj1 === obj2); // true 특징2: 변경이 가능 (원시값과 차별점)123const obj = &#123;&#125;;obj.foo = 123;console.log(obj.foo); // 123 undefined와 null정보가 없음을 의미하는 두 단위 개인적으로 생각하는 차이점은 undefined는 선언도 되지 않았다. null은 선언되었지만 값이 존재하지 않는다. 로 생각한다. null은 객체가 아니다라는 뜻 undefined, null 둘다 프로퍼티와 표준 메서드가 존재하지 않음 체크법123456789if (x === undefined || x === null) &#123; // undefined == null은 true지만, ===은 false이다. ...&#125; // or if (!x) &#123; ...&#125; typeof와 instanceof 로 값 분류1typeof value // boolean or string, function, object(ex. [], &#123;&#125;) 참고로, typeof null은 object로 반환된다. 자바스크립트 자체 버그잼 1234567891011value instanceof Constructorconst b = new Bar();console.log(b instanceof Bar); // true&#123;&#125; instanceof Object // true[] instanceof Array // true[] instanceof Object // true, Array이는 Object의 부속 생성자undefined instanceof Object // falsenull instanceof Object // false, typeof와 다른 점 숫자11 === 1.0 // true NaN = Not a Number에러값 1Number(`xyz`) // NaN Infinity에러로 생긴 값 1233 / 0 // infinityMath.pow(2, 1024); // 너무 큰 숫자 연산자조금 신기한 함수 연산자 12+a(); // 함수는 문자열을 반환하고, 연산자는 이를 숫자!로 변환++a(); // Error! 끌어올림 = hoisting호이스팅을 한글화하면 끌어올림이라고 하는구나, 처음 앎 자릿수 강제12345function pair(x, y) &#123; if (arguments.length !== 2) &#123; throw new Error(`Need exactly 2 arguments`); &#125;&#125; 그런데 arguments를 이용한 코딩을 잘 안하는걸로 알고 있는데 좀 알아봐야겠군… Arguments를 배열로 변환arguments는 배열이 아님, 조금 특별한 객체일 뿐. 하지만 length가 붙어있음.그러나, 인덱스를 써서 요소에 접근은 가능하지만, 제거하거나 배열 메서드를 호출할 수는 없다. 그러므로 가끔 배열로 써야할 경우 다음 방법을 사용 123function toArray(arrayLikeObject) &#123; return Array.prototype.slice.call(arrayLikeObject);&#125; IIFE 패턴: 새 스코프IIFE가 뭔지 몰랐었는데 즉시 호출 함수식을 말하는거 였음. 이피 잼 1234567891011121314151617181920212223242526let result = [];for (var i = 0; i &lt; 5; i++) &#123; result.push(() =&gt; i);&#125;console.log(result[1]()); // 5, 1이 아님console.log(result[3]()); // 5, 3이 아님// IIFE 식을 쓰면, 그당시 i 값을 가지는게 가능for (var i=0; i &lt; 5; i++) &#123; (function() &#123; var i2 = i; result.push(() =&gt; i2); &#125;)();&#125;// 사실 let을 쓰면 끝남let result = [];for (let i = 0; i &lt; 5; i++) &#123; result.push(() =&gt; i);&#125;console.log(result[1]()); // 5console.log(result[3]()); // 5 in 연산자12345678const taeuk = &#123; name: `taeuk`, tell() &#123; return `i am $&#123;this.name&#125;` &#125;&#125;tell in taeuk // true 추출 메서드주의점: 메서드를 추출하면 객체와의 연결이 사라짐, 함수로 변경되는 것그러므로, this도 undefined로 변경됨 1234567891011121314const taeuk = &#123; name: `taeuk`, tell() &#123; return `i am $&#123;this.name&#125;` &#125;&#125;const func = taeuk.tell;func() // Error!// Binding을 하지 않아서 그럼const func = taeuk.tell.bind(taeuk);func() // i am taeuk forEach의 두번째 문구가 this 바꾸는거였음1arr.forEach(callback[, thisArg]); 매개변수각 요소에 대해 실행할 함수. 다음 세 가지 인수를 받습니다. currentValue 처리할 현재 요소. index Optional 처리할 현재 요소의 인덱스. array Optional forEach()를 호출한 배열. thisArg Optional callback을 실행할 때 this로 사용할 값. 정규표현식12/^abc$//[A-Za-z0-9]+/ test() 메서드: 일치하는 것이 있는지 확인123/^a+b+$/.test(`aaab`) // true/^a+b+$/.test(`aaa`) // false exec() 메서드: 일치하는 그룹을 캡처1/a(b+)a/.exec(`_abbba_aba_`) // [`abbba`, `bbb`] 반환된 배열의 인덱스 0은 일치하는 그룹 전체!, 1 이후부터는 캡처한 그룹! 이 메서드를 반복해 일치하는 그룹을 모두 캡처하는 방법도 존재 (추후에 알아볼 듯) replace() 메서드: 검색과 교체1` `.replace(/&lt;(.*?)&gt;/g, &#x27;[$1]&#x27;) // [a] [bbb] 으음 위 코드 정상 작동 안하는거 같은데… replace MDN 참조해봐야 알 듯","tags":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/tags/Book/"},{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"}],"categories":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/categories/Book/"}]},{"title":"Kubernetes 학습 기록 (2) - Kubernetes","date":"2019-08-04T12:45:42.000Z","path":"wiki/Server-kubernetes-2/","text":"“Kubernetes in Action” 책으로 학습한 내용입니다.1장에 이어서… 2장 시작 쿠버네티스 클러스터 설정1장에서 도커 이미지에 패키지를 만들고 도커 허브를 통해 사용할 수 있게 됬다.이제 도커에서 직접 실행하는 대신, 쿠버네티스 클러스터에 배포를 하고 실행해보자. 소개하는 3가지 방법 로컬에서 단일 노드 쿠버네티스 클러스터 실행 구글 쿠버네티스 엔진에서 호스트받은 클러스터에서 실행 (추후 작성) kubeadm 툴을 사용해 설치하는 방법 (추후 작성) 미니큐브를 사용해 로컬 단일 노드 쿠버네티스 실행미니큐브 = 쿠버네티스를 실행하고 로컬에서 어플리케이션을 개발하는데 유용한 도구여러노드를 관리할 수는 없음, 단일 노드 개발에 특화 미니큐브 설치OSX, 리눅스, 윈도우 지원 (설치법) 1curl -Lo minikube https://storage.googleapis.com/minikube/releases/v0.23.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/ 결과 화면 미니큐브 시작1minikub start 클러스터를 시작하는데 1분 이상 소모되므로, 대기 쿠버네티스 설치OSX 설치 (리눅스 또는 윈도우는 darwin을 linux 또는 windows로 변경) 1curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl &amp;&amp; chmod +x kubectl &amp;&amp; sudo mv kubectl /usr/local/bin/ 클러스터 작동 확인 / kubectl로 명령1kubectl cluster-info 결과 화면 (선택) alias와 kubectl 설정kubectl을 자주 치기 귀찮을 때, 설정법 로컬내에 /root/.bashrc 파일에 alias k=&#39;kubectl&#39;을 추가하여 사용이후 k cluster-info등으로 kubectl을 대체가능하다. 클러스터 노드 목록 확인1k get nodes 결과 화면 쿠버네티스에서 Node App 실행Node.js App 배포1k run taeuk-test --image=kangtaeuk/taeuk-test --port=9381 --generator=run-pod/v1 run은 deprecated 된 듯… , 대신 create 또는 --generator=run-pod/v1 삽입--port=9381은 앱이 포트 9381에서 수신 대기하고 있음을 알려준다 포드에 관하여…쿠버네티스는 개별 컨테이너는 직접 취급하지 않고, 여러 위치 배치되면 컨테이너 그룹 개념을 사용한다.이러한 컨테이너 그룹을 pod라고 한다. 포드는 동일한 리눅스 네임스페이스와 동일한 워커 노드에서 항상 함께 실행된다. 각 포드는 애플리케이션을 실행하는 자체 IP, Host, Process 등이 있는 별도 논리적 시스템이다.(이 부분은 완벽히 이해가 되질 않는군…) 포드 나열하기1kubectl get pods 결과 화면 이미지가 다운로드 중이라면, 상태가 PENDING으로 뜸다운로드 완료시, RUNNIG으로 전환됨 계속 안된다면, k describe pods taeuk-test 실행하여 확인 포드 삭제하기1k delete po 이름 포드를 잘못 만들었을 경우나, 무한 wait시 삭제하고 다시 run 강제 삭제 명령어k delete pods taeuk-test --grace-period=0 --force 웹 애플리케이션 접근각 포드의 자체 IP가 존재하지만, 이 주소는 클러스터 내부에 존재하며 외부에서 접근 불가능함 외부에서 액세스하려면, 서비스 객체를 통해 IP를 노출해야함 이를 위해, LoadBalancer 형태의 특별한 서비스가 필요함 (로드밸런서의 공용IP로 포드에 연결가능) 서비스 객체 생성1k expose rc taeuk-test --type=LoadBalancer --name taeuk-http 서비스 목록 보기1k get services 바로 생성했다면, 아직 외부 IP주소가 없는 것을 확인.클라우드 인프라에서 로드 밸런서를 생성하는데 시간이 걸리기 때문. 외부 IP가 생길 때까지 대기 (이슈해결) 쿠버네티스에서 삭제해도, 계속 실행중일시k delete pods name을 해도 뒤의 다른 이름을 달고 계속 생성될 때가 있다. 결과 화면 이것은 지워도 deployment와 rc(레플리카컨트롤러) 에서 계속 생성하기 때문이다. 그러므로, k get deployment 또는 k get rc를 하여 목록을 확인하고, 결과 화면 k delete deployment taeuk-test 또는 k delete rc taeuk-test를 하여 계속 실행되는 것을 방지","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"},{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/tags/Server/"}],"categories":[{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/categories/Server/"},{"name":"Kubernetes","slug":"Server/Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Server/Kubernetes/"}]},{"title":"Kubernetes 학습 기록 (1) - Docker","date":"2019-08-03T10:51:32.000Z","path":"wiki/Server-kubernetes/","text":"“Kubernetes in Action” 책으로 학습한 내용입니다. Docker 설치CentOs 7에서 도커 설치 Hello World 컨테이너 실행1docker run busybox echo &quot;Hello world&quot; 결과 화면 간단한 Node.js 앱 만들기컨테이너 이미지 버전 실행법1docker run &lt;image&gt;:&lt;tag&gt; app.js 파일 생성으로 애플리케이션 생성12345678910111213// app.js 파일const http = require(`http`)const os = require(`os`)console.log(`Kubia server starting...`)var handler = (req, res) =&gt; &#123; console.log(`Received request from $&#123;req.connection.remoteAddress&#125;`) res.writeHead(200) res.end(`You&#x27;ve hit $&#123;os.hostname()&#125;`)&#125;var www = http.createServer(handler)www.listen(8080) 이미지용 도커 파일 만들기이미지에 패키징하려면 도커 파일 필요 도커 파일에는 도커가 수행할 지시 사항 목록이 들어있다. 도커 파일은 동일한 디렉토리에 위치할 것! 123FROM node:10ADD app.js /app.jsENTRYPOINT [&quot;node&quot;, &quot;app.js&quot;] 컨테이너 이미지 만들기1docker build -t taeuk-test . 도커에게 현재 디렉터리의 내용을 taeuk-test라는 이미지로 빌드하라는 요청 도커파일을 찾고 설정에 따라 이미지 빌드 (대문자는 되지않음) 결과 화면 빌드 프로세스가 완료되면, 새 이미지가 로컬에 저장됨1docker images 결과 화면 도커 이미지 실행1docker run --name taeuk-container -p 9381:8080 -d taeuk-test 컨테이너는 콘솔에서 분리된다. (백그라운드에서 실행) -p 8080:8080 로컬 컴퓨터의 8080은 컨테이너 내부 포트 8080에 매핑이후, http://localhost:8080을 통해 접속이 가능하다. 도커 데몬이 아닌 경우(Mac or Window는 VM 내부에서 데몬실행), VM의 호스트 네임이나 IP를 사용 (이슈) 이미 사용된 포트일 경우, exist 상태이지만, running은 아니라서 컨테이너가 docker ps 명령어에도 뜨지 않는다. 이미 사용중인 포트라고 해서, 다시 로컬 포트를 바꿨지만 이미 생성되있다고 뜬다 docker kill을 실행 중이 아니라고 지워지지 않는다. 그러므로, docker rm을 하여 지운 후 다시 docker run 결과 화면 제대로 작동하고 있는지 확인, curl localhost:port 결과 화면 hit가 뜬다면 정상 만약 curl: (56) Recv failure: Connection reset by peer가 뜬다면,포트(외부포트:컨테이너내부포트 둘중 하나가 맞지 않다는 뜻이다) 또는 docker inspect taeuk-container 를 쳐서 확인 결과 화면 이후, 터널링 1ssh -l 9381:127.0.0.1:9381 root@101.101.164.175 명령어 친후, 내 컴퓨터에서 localhost:9381로 접속하여 확인 실행 중인 컨테이너 내부 탐색1docker exec -it taeuk-container bash -i: stdin을 오픈상태로 유지, 셸에 명령 입력시 필요 -t: pseudo 터미널(TTY)을 할당한다. 1ps aux 컨테이너 내부 프로세스 나열하기 결과 화면 컨테이너 내부 프로세스와 호스트내부 프로세스 ID가 다르다. 컨테이너는 자체 PID 리눅스 네임스페이스를 사용 고유 시퀀스 번호를 갖는 완전히 분리된 프로세스 트리를 소유한다. 컨테이너 중지 및 제거1docker stop taeuk-container 실행중인 기본 프로세스 중지, 컨테이너 중지 컨테이너 자체는 docker ps -a 명령어를 통해 확인 가능 1docker rm taeuk-container 컨테이너가 삭제되고, 모든 내용이 제거되면 다시 시작할 수 없다. 이미지 레지스트리로 이미지 푸시지금까지 한 작업은 로컬에서만 사용가능하다. 다른 컴퓨터에서 빌드한 이미지를 실행하려면, 외부 이미지 레지스트리로 푸시해야한다. 공개적으로 이용가능한 레지스트리 중 하나인 도커 허브에 이미지 푸시, 다른 것으로는 Quay.io, 구글 컨테이너 레지스트리가 있다. 이미지 푸시 전에, 도커 허브 RULE에 따라 이미지 태그부터 지정해야한다.도커 허브는 이미지의 소티리지 이름이 도커 허브 ID로 시작하면 이미지를 푸시할 수 있다.도커 허브 ID는 도커허브에서 등록하여 만든다. 1docker tag taeuk-test kangtaeuk/taeuk-test 이후, docker images | head 명령어로 태그가 생성된 것을 확인할 수 있다. 결과 화면 1docker login 도커에 푸시하기전에, 로그인을 먼저 한다. 1docker push kangtaeuk/taeuk-test 도커에 이미지 푸시 터미널 - 결과 화면 도커사이트 - 결과 화면 이후, 다른 머신에서 이미지를 실행1docker run -p 9381:8080 -d kangtaeuk/taeuk-test Docker의 장점애플리케이션이이 언제 어디서나 동일한 환경을 유지한다는 것이다. 모든 컴퓨터 안 리눅스에서 정상 실행이 되기 때문에, 호스트 시스템에 node.js가 있는지는 걱정할 필요가 없어진다.","tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"},{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/tags/Server/"}],"categories":[{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/categories/Server/"},{"name":"Kubernetes","slug":"Server/Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Server/Kubernetes/"}]},{"title":"처음 써보는 네이버 클라우드 이용기","date":"2019-08-02T23:00:48.000Z","path":"wiki/SERVER-naver-cloud/","text":"서버생성네이버 클라우드 플랫폼 console페이지 로 이동 - 사이트 이후, All Products - Server 메뉴를 클릭하여, +서버 생성메뉴 선택 아코디언 사용을 위한 마스터 서버 생성권장사양 그러나, 네이버 클라우드 플랫폼은 Redhat을 지원하지않고, CentOS 7.3이 최대버전이기 때문에 CentOS 7.3을 일단 설치 후, 리눅스 상에서 업그레이드를 거치고 이미지를 생성하기로 결정 서버 이미지 선택창 입력 후, 다음 버튼 클릭 기존 인증키가 있다면, 인증키 선택 후 다음 없다면, 생성 - 과정이 간단함 이것은 이후 SSH 서버 접속시, 비밀번호 생성할 때 사용됨 네트워크 접근 설정 후, 다음 버튼 최종 확인 후, 서버 생성 끝 이후, 생성 중 &gt; 설정 중 &gt; 부팅 중 &gt; 운영 중 순으로 5분 정도 가량 시간이 소모된다.서버 설정공인 IP 생성메뉴 중, Public IP 클릭 공인 IP 신청 클릭 이후, 처리 절차를 따라 생성 - 서버당 1개의 IP만 소유 가능 다시 Server 메뉴로 이동 후, 서버 이미지 오른쪽 클릭 후, 공인 IP 설정 변경 클릭 마지막으로, 터미널을 통하여 SSH 접속 커널 업데이트12345// 현재 커널 릴리즈 확인cat /etc/redhat-release// 최신 버전 업데이트yum update -y 내 서버 이미지 생성 해당 서버 오른쪽 클릭 후, 내 서버 이미지 생성 클릭 후 진행 비밀번호 로그인 방식이 아닌, publickey 방식으로 전환 서버에서 비밀키/공유키 생성 1ssh-keygen 생성된 공개키를 서버에 등록 1cat 키-이름.pub &gt;&gt; ~/.ssh/authorized_keys 권한 변경 12chmod 700 ~/.ssh # 소유자만 해당 디렉토리 읽기, 쓰기, 접근 가능chmod 600 ~/.ssh/authorized_keys # 소유자만 해당 파일 읽기, 쓰기 가능 이후 서버 설정 변경 vi /etc/ssh/sshd_config 입력하여, 아래와 같이 설정 (패스워드 사용없이 공개키로만 접속하게 설정) 12PubkeyAuthentication yesPasswordAuthentication no 서버 재설정 시작 1systemctl restart sshd 접속하고자하는 환경에서 1ssh root(또는 사용자명)@IP -i ./공개키 파일","tags":[{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/tags/Server/"},{"name":"Cloud","slug":"Cloud","permalink":"https://taeuk-gang.github.io/tags/Cloud/"},{"name":"Naver-Cloud","slug":"Naver-Cloud","permalink":"https://taeuk-gang.github.io/tags/Naver-Cloud/"}],"categories":[{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/categories/Server/"},{"name":"Cloud","slug":"Server/Cloud","permalink":"https://taeuk-gang.github.io/categories/Server/Cloud/"}]},{"title":"링크 클릭시, 스크롤 이동 처리","date":"2019-08-02T14:09:44.000Z","path":"wiki/HTML-move-scroll/","text":"See the Pen 스크롤 이동 by taeuk_kang (@taeuk_kang) on CodePen.","tags":[{"name":"HTML","slug":"HTML","permalink":"https://taeuk-gang.github.io/tags/HTML/"}],"categories":[{"name":"HTML","slug":"HTML","permalink":"https://taeuk-gang.github.io/categories/HTML/"}]},{"title":"마우스 드래그시 색 조정","date":"2019-08-02T14:06:40.000Z","path":"wiki/CSS-selection/","text":"selection 마우스 드래그시 색 조정 See the Pen 마우스 드래그시 색변경 by taeuk_kang (@taeuk_kang) on CodePen.","tags":[{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/tags/CSS/"}],"categories":[{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/categories/CSS/"}]},{"title":"pointer-events를 이용한 클릭 방지 및 이벤트 위임","date":"2019-08-01T11:37:22.000Z","path":"wiki/Css-pointer-events/","text":"pointer-events상위 요소에 있지만 클릭 못하게 하는 방법 + 이벤트 버블링 방지 123456789101112event.preventDefault()현재 이벤트의 기본 동작을 중단한다.event.stopPropagation()현재 이벤트가 상위로 전파되지 않도록 중단한다.event.stopImmediatePropagation()현재 이벤트가 상위뿐 아니라 현재 레벨에 걸린 다른 이벤트도 동작하지 않도록 중단한다.return falsejQuery를 사용할 때는 위의 두개 모두를 수행한 것과 같고,jQuery를 사용하지 않을 때는&amp;nbsp;event.preventDefault() 와 같다. See the Pen 투명하지만 클릭못하는 DIV by taeuk_kang (@taeuk_kang) on CodePen.","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/tags/CSS/"}],"categories":[{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/categories/CSS/"}]},{"title":"그리드 레이아웃","date":"2019-07-29T13:24:55.000Z","path":"wiki/Css-grid/","text":"그리드 레이아웃 적용 See the Pen 그리드 레이아웃 적용 by taeuk_kang (@taeuk_kang) on CodePen.","tags":[{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/tags/CSS/"}],"categories":[{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/categories/CSS/"}]},{"title":"Shadow DOM 만들기","date":"2019-07-27T13:33:18.000Z","path":"wiki/Js-shadow-dom/","text":"Shadow_DOMShadow DOM 만들기 See the Pen Shadow DOM 만들기 by taeuk_kang (@taeuk_kang) on CodePen.","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"}],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"}]},{"title":"웹디자이너를 위한 CSS3 도서 요약","date":"2019-07-25T11:51:45.000Z","path":"wiki/Book-css3-for-webDesigner/","text":"다시 보게된 CSS 속성들text-shadow123p &#123; text-shadow: 1px 1px 2px #999;&#125; 다중 배경 이미지123456789101112body &#123; background: url(image.png) no-repeat top left, url(image2.png) repeat-x bottom left, url(image3.png) repeat-y top right;&#125;/* 또는 투명도를 이용한 방법 */body &#123; background: url(image.png) repeat-x fixed -130% 0, url(image2.png) repeat-x fixed 40% 0, url(image3.png) repeat-x fixed -80% 0;&#125; 트랜지션 지연1234567891011a.foo &#123; transition-property: background; transition-duration: 03s; transition-timing-function: ease; transition-delay: 0.5s;&#125;/* 축약 표기 */a.foo &#123; transition: background 0.3s ease 0.5s;&#125; 브라우저 개발사 접두어 개발사 접두어 Apple -webkit- Google -webkit- Mozilla -moz- Opera -o- Konqueror -khtml- Microsoft -ms- 애니메이션을 왜 자바스크립트로 사용하지 않나?Jquery, Prototype, script.aculo.us, 그리고 요즘은 anime.js같은 프레임워크에서 에니메이션이 사용가능합니다. 그러나, 웹사이트 레이아웃에서 에니메이션은 개발 최소단위로 들어가진 않기에 단순히 CSS 코드 몇줄로 간단히 구현하는 것이 현명한 처사로 보입니다. 책에는 없지만 나름 유용한 CSS 속성들object-fit, object-position&lt;img /&gt; 태그에서 background-size, background-position 속성과 같이 사용할 수 있는 CSS 속성","tags":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/tags/Book/"}],"categories":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/categories/Book/"}]},{"title":"새로운 CSS 레이아웃 도서 요약","date":"2019-07-23T10:19:49.000Z","path":"wiki/Book-new-css-layout/","text":"새로운 CSS 레이아웃 요약이전 레이아웃플롯의 문제플롯은 모든 요소의 높이가 똑같다면 괜찮은 방식임그렇지 않다면, 아래와 같이 레이아웃이 망가질 수 있음 See the Pen 플롯 - 망가진 레이아웃 by taeuk_kang (@taeuk_kang) on CodePen. 플롯 문제 해결 현재컴포넌트 우선 디자인 새로운 레이아웃column-count, column-width See the Pen column-count by taeuk_kang (@taeuk_kang) on CodePen. shape-outside신기한 방식 See the Pen shape-outside by taeuk_kang (@taeuk_kang) on CodePen. flex-wrap마지막 엘리먼트를 지워보고, 어떻게 영향을 끼치는지 확인하자 그리고 flex: 0 0 auto;로 변경해보자. flex: 0 0 auto; = flex-grow, flex-shrink, flex-basis 순서로 배치됨 이게 grid와 flex에 가장 큰 차이라고 생각된다. grid에서는 아무리 찾아봐도, 각 행의 길이를 다르게 하는 방법을 모르겠다… (아직 공부가 부족한가…) See the Pen flex-wrap by taeuk_kang (@taeuk_kang) on CodePen. 그리드 레이아웃* 내가 몰랐던 사실grid-gap, grid-column-gap, grid-row-gap을 grid를 빼고 사용이 가능하게 바뀌었다.이제는 gap, column-gap, row-gap으로 사용 가능하다.하지만, 아직 브라우저 지원률은 grid를 붙인 것이 높은 듯 하다.IE는 확인해봐야 알 듯… (내가 알기로 폴리필을 해도 grid-gap 지원 안했던 것 같은데…) 그리드 레이아웃 빈칸은 .으로 표시 1234grid-template-areas: &quot;a a b&quot; &quot;. d d&quot; &quot;c e e&quot;; 배치와 정렬grid-align-slef See the Pen grid-align-self by taeuk_kang (@taeuk_kang) on CodePen. align-content: space-between;justify-content: space-between; See the Pen grid-align-content by taeuk_kang (@taeuk_kang) on CodePen. justify-items ,justify-self See the Pen grid-justify by taeuk_kang (@taeuk_kang) on CodePen. ★반응형 디자인flex -grow, -shrink, -basis커지는 비율, 작아지는 비율, 플렉스 아이템의 기본값(넓이·높이) See the Pen flex-basis by taeuk_kang (@taeuk_kang) on CodePen. ★소스 순서와 표현 순서grid-auto-flowgrid-auto-flow: dense를 해제시켜보고 차이를 이해 See the Pen grid-auto-flow by taeuk_kang (@taeuk_kang) on CodePen. order그리드에서는 사용 용도가 불분명한 편, 애초에 grid-area로 숫자·이름 둘다 지정할 수 있기 때문에 See the Pen layout-order by taeuk_kang (@taeuk_kang) on CodePen. display: contents인정하지 않은 자식 요소도 플렉스 또는 그리드 레이아웃의 구성요소가 될 수 있게 만듦 See the Pen display: contents by taeuk_kang (@taeuk_kang) on CodePen. 준비하는 미래 support 문법 발견 123456supports (display: grid) &#123; /* grid 지원 브라우저에만 적용됨 */ .container &#123; display: grid; &#125;&#125; 앞으로의 여정참고파일 예제 코드 Download","tags":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/tags/Book/"}],"categories":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/categories/Book/"}]},{"title":"레이아웃 엔진 만들기 일지","date":"2019-07-22T17:40:04.000Z","path":"wiki/Project-one-page-layout/","text":"레이아웃 엔진 짜기현재 Github에서 진행 중 결국에는 비율 문제 아닌가?화면이 작고 크고는 폰트와 이미지의 크기를 늘리고 줄이면 되는 문제 비율 분류(3분류) 가로 크게 세로 크게 정사각형 (1:1 비율) 크기 분류(3분류) 모바일 PC 빔 프로젝트 이미지의 개수(이건 선택 IF) 1개 2개 3개 4개 5개 이상 생각 스케치​ 엘리먼트​ 엘리먼트로 나누고 최상위로 분류(depth 없음)​ 엘리먼트 분류(이미지/ 텍스트)​ 불필요 엘리먼트 날리기 ​ 단​ 엘리먼트 개수에 따라 단 나누기(2단 3단 4단) ​ 배치​ 우선순위에 따른 배열(이미지(상)/ 텍스트(하)) ​ 그룹화​ 관련성 엘리먼트 묶기​ grid-area로 묶어주면 Nice 생각 주의사항 이미지는 일부만 보여져도 된다 폰트 CSS 좌우·상하 단어 줄바꿈 등 모두 찾아서 고려 여러 디바이스 화면 고려(troy 사이트 사용) 전체 레이아웃은 grid로 형성하고, 이후 하위 레이아웃은 flex로 해야함 공부해야할 것 font관련 CSS 모두 파악 일단 grid레이아웃 극한으로 배워야 한다 (∵ 써먹을 것은 써먹어야하기 때문) media query에 대해서도 극한으로 학습 (반응형) foundation, bootstrap, ant design 등 에서 영감 받을 수 있는 것 확인 codepen에서 영감받을 수 있는 것 확인 (빡고수들이 많기 때문에 분명히 존재할 것임) CSS / 폰트 관련letter-spacing 자간word-spacing 어간line-height 행간transform 변형작업 진행1. 고정 / 반응형 엘리먼트 구분 (O)고정: 언론사 / 제목 / 시간 / + 페이지 이동바(하단) 반응: 이미지 / 본문글 2. header / body / footer 공간 구분하여 레이아웃 형성 (O)header: 언론사 / 제목 / 시간 body: 본문 footer: 페이지 이동바 3. Header 정리 (O)가운데 정렬 : 언론사 / 제목 / 시간(작게) 4. X 위치 절대위치로 잡기5. IE11 이슈 해결 - node.remove() 메소드 없음parent.removeChild(childNode)로 해결 6. 페이지 이동바 제작7. #textNode -&gt; p 엘리먼트 씌우기 (O)8. ★ 레이아웃 알고리즘 짜기columns를 쓰면 안됨 (∵ 각 단을 다른 크기로 배정할 수 없음) 이미지 여러개 처리 방법한 이미지 뷰어에서 처리이미지 엘리먼트 대신, 이미지 뷰어 순서 참조 넣기 9. 스크린 크기에 따른 폰트 사이즈 조정10. columns 응용할 방법 찾기 or flex로 변경* 페이지 이동은 화면 왼쪽 / 오른쪽 클릭시 이동하는 걸로 조건: 모바일 뷰에서는 작동하지 않기(상하 스크롤로 이동하기 때문에) 모바일 뷰어에서는 끝까지 페이지 스크롤시, 다음 페이지 여부 묻기 (만화 사이트 형식 참고) * 크롬 버그 page-break 개발자 도구에서 바로 적용 안됨columns를 해체했다 다시 켜야 적용됨","tags":[{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/tags/Projects/"},{"name":"naver-d2","slug":"naver-d2","permalink":"https://taeuk-gang.github.io/tags/naver-d2/"},{"name":"One-Page","slug":"One-Page","permalink":"https://taeuk-gang.github.io/tags/One-Page/"}],"categories":[{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/categories/Projects/"},{"name":"One-Page","slug":"Projects/One-Page","permalink":"https://taeuk-gang.github.io/categories/Projects/One-Page/"}]},{"title":"자바스크립트 언락 도서 요약","date":"2019-07-22T05:28:21.000Z","path":"wiki/Book-Javascript-Unlocked/","text":"자바스크립트 언락 (2017년 발행)새롭게 알게된 사실들조건부 호출조건문 간략하게 작성 123const age = 20age &gt;= 18 &amp;&amp; console.log(`나이가 18세 이상이구나!`)age &gt;= 18 || console.log(`나이가 18세 미만이구나...`) 함수 호출 단축 조건 123456789101112function fn(cb) &#123; cb &amp;&amp; cb()&#125;// 또는class AbstractFoo &#123; constructor() &#123; // init 메서드가 있을경우에만 호출 this.init &amp;&amp; this.init() &#125;&#125; 나머지 연산자ES5는 작성하지 않음([].slice.call(arguments) 찾아보아요) ES6 1234let cb = (foo, bar, ...args) =&#123; console.log(foo, bar, args)&#125;cb(`foo`, `bar`, 1, 2, 3) // foo bar [1,2,3] 변수 나머지 연산(선언이 특이하네) 12let [bar, ...others] = [`bar`, `foo`, `baz`, `qux`]console.log([bar, others]) // [`bar`, [`foo`, `baz`, `qux`]] 펼침 연산자배열 요소를 인수로 확산 123let args = [2015, 6, 17]let relDate = new Date(...args)console.log(relDate.toString()) // Fri Jul 17 2015 00:00:00 GMT+0900 (한국 표준시) ES6 컬렉션객체 중복없이 넣기 12345let foo = new Set()foo.add(1)foo.add(1)foo.add(2)console.log(Array.from(foo)) // [1, 2] Map vs Set비교Objects의 키는 Strings이며, Map은 모든 값을 가질 수 있음Objects의 사이즈는 수동으로 체크해야하지만, Map은 쉽게 얻을 수 있음Map은 삽입된 순서대로 반복됨 사용팁실행시까지, 키를 알 수 없고 모든 키·값이 동일한 타입이면 Map을 사용각 개별 요소에 대한 적용이 있을 경우는 Object를 사용 참고자료MDNJavascript Info getter/setter (알려진 속성에 대한 접근제어)SyntaxError 객체가 흥미롭네 12345678910111213class Bar &#123; constructor() &#123; this.arr = [1, 2] &#125; get length() &#123; return this.arr.length &#125; set length(val) &#123; throw new SyntaxError(`Cannot assign to read only property &#x27;length&#x27;`) &#125;&#125; proxy (임의 속성에 대한 접근 제어)오오… proxy, IE11 적용법 찾긴 해야되는데…아직 이해도가 낮은 것 같다.(★★★) 1234567891011121314151617181920212223242526const myStorage = &#123; data: &#123;&#125;, getItem(key) &#123; return this.data[key] &#125;, setItem(key, val) &#123; this.data[key] = val &#125;&#125;let storage = new Proxy(myStorage, &#123; get(storage, key) &#123; return storage.getItem(key) &#125;, set(storage, key, val) &#123; return storage.setItem(key, val) &#125;&#125;)storage.bar = `bar`console.log(myStorage.getItem(`bar`))myStorage.setItem(`bar`, `baz`)console.log(storage.bar) NodeList에 관하여라이브 콜렉션으로 상당한 비싼 자원(DOM이 reflow될때마다 갱신)그러므로, 라이브일 필요가 없을 경우는 배열로 변환 123const li = document.querySelectorAll(`li`)console.log(li.slice.call(li)) // ES5 방식console.log([...li]) // ES6 방식 DOM 이벤트 핸들링Event 객체 상세사항 event.type: 이벤트 이름 event.target: 발생한 이벤트 타겟 event.currentTarget: 리스너가 부착된 타겟 event.eventPhase : 이벤트 단계 (none, capturing, at target, bublling) event.bublles: 이벤트 버블 여부 event.cancelable: 이벤트 디폴트 동작 방지 여부 event.timeStamp: 이벤트 시간 지정 메서드 event.stopPropagation(): 추가전파 중지 event.stopImmediatePropagation(): 다른 이벤트 호출X event.preventDefault(): 디폴트 동작 방지 (ex. submit) XHR vs Axiosfetch는 취소 불가, 다른 브라우저 호환성, 인코딩 문제(★)로 별로 쓰고싶지 않다. Fetch API보다 Axios가 더 좋은 장점은 아래와 같습니다.(출저) 구형브라우저를 지원합니다.(Fetch API의 경우는 폴리필이 필요합니다.) 요청을 중단시킬 수 있습니다. 응답 시간 초과를 설정하는 방법이 있습니다. CSRF 보호 기능이 내장되어있다. JSON 데이터 자동변환 Node.js에서의 사용 웹 스토리지 API쿠키의 단점으로 생겨남. ​ 단점1. 최대크기 4KB ​ 단점2. Cross-site-scripting-acttack에 취약함 웹 스토리지 API는 5~25MB를 저장, HTTP 요청헤더에 어떠한 데이터도 추가하지 않음 ​ 종류1. localStorage : 다른 탭과 공유, 영구히 유지 ​ 종류2. sessionStorage : 하나의 탭, 세션 동안에만 유지 사용 예제 12345678910function useStorage() &#123; if (!localStorage) &#123; return &#125; let storage = localStorage storage.setItem(`foo`, `Foo`) console.log(storage.getItem(`foo`)) storage.removeItem(`foo`)&#125;useStorage() 또는 (getter/setter 사용) 12345678910function useStorage() &#123; if (!localStorage) &#123; return &#125; let storage = localStorage storage.foo = `food` console.log(storage.foo) delete storage.foo&#125;useStorage() 반복문 사용시 123456let len = storage.lengthlet keyfor(let i = 0 ;i &lt; len; i++) &#123; key = storage.key(i) console.log(storage.key)&#125; 여기서부터 정리안됨, 이후 다시 책봐서 정리… Web Storage 예제 (쇼핑카트) 접기/펼치기 버튼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;html&gt; &lt;head&gt; &lt;title&gt;Web Storage&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button data-bind=&quot;btn&quot;&gt;Add to cart&lt;/button&gt; &lt;button data-bind=&quot;reset&quot;&gt;Reset&lt;/button&gt; &lt;/div&gt; &lt;output data-bind=&quot;output&quot;&gt; &lt;/output&gt; &lt;script&gt; var output = document.querySelector( &quot;[data-bind=\\&quot;output\\&quot;]&quot; ), btn = document.querySelector( &quot;[data-bind=\\&quot;btn\\&quot;]&quot; ), reset = document.querySelector( &quot;[data-bind=\\&quot;reset\\&quot;]&quot; ), storage = localStorage, /** * Read from the storage * @return &#123;Arrays&#125; */ get = function()&#123; return JSON.parse( storage.getItem( &quot;cart&quot; ) ) || []; &#125;, /** * Append an item to the cart * @param &#123;Object&#125; product */ append = function( product ) &#123; var data = get(); data.push( product ); storage.setItem( &quot;cart&quot;, JSON.stringify( data ) ); &#125;, /** Re-render list of items */ updateView = function()&#123; var data = get(); output.innerHTML = &quot;&quot;; data &amp;&amp; data.forEach(function( item )&#123; output.innerHTML += [ &quot;id: &quot;, item.id, &quot;&lt;br /&gt;&quot; ].join( &quot;&quot; ); &#125;); &#125;; this.btn.addEventListener( &quot;click&quot;, function()&#123; append(&#123; id: Math.floor(( Math.random() * 100 ) + 1 ) &#125;); updateView(); &#125;, false ); this.reset.addEventListener( &quot;click&quot;, function()&#123; storage.clear(); updateView(); &#125;, false ); // Update item list when a new item is added in another window/tab window.addEventListener( &quot;storage&quot;, updateView, false ); updateView(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 인덱스 DB 예제 접기/펼치기 버튼 123456789101112131415161718192021222324252627282930313233343536373839404142/** * IndexDB usage example *//** * @type &#123;IDBOpenDBRequest&#125; */var request = indexedDB.open( &quot;Cem&quot;, 2 );/** Report error */request.onerror = function() &#123; alert( &quot;Opps, something went wrong&quot; );&#125;;/** * Create DB * @param &#123;Event&#125; e */request.onupgradeneeded = function ( e ) &#123; var objectStore; if ( e.oldVersion ) &#123; return; &#125; // define schema objectStore = e.currentTarget.result.createObjectStore( &quot;employees&quot;, &#123; keyPath: &quot;email&quot; &#125;); objectStore.createIndex( &quot;name&quot;, &quot;name&quot;, &#123; unique: false &#125; ); // Populate objectStore with test data objectStore.add(&#123; name: &quot;John Dow&quot;, email: &quot;john@company.com&quot; &#125;); objectStore.add(&#123; name: &quot;Don Dow&quot;, email: &quot;don@company.com&quot; &#125;);&#125;;/** * Find a row from the DB * @param &#123;Event&#125; e */request.onsuccess = function( e ) &#123; var db = e.target.result, req = db.transaction([ &quot;employees&quot; ]).objectStore( &quot;employees&quot; ).get( &quot;don@company.com&quot; ); req.onsuccess = function() &#123; console.log( &quot;Employee matching `don@company.com` is `&quot; + req.result.name + &quot;`&quot; ); &#125;;&#125;; 접기/펼치기 버튼 12345678910111213141516171819202122232425/** * IndexDB with Dexie */var db = new Dexie( &quot;Cem&quot; );// Define DBdb.version( 3 ) .stores(&#123; employees: &quot;name, email&quot; &#125;);// Open the databasedb.open().catch(function( err )&#123; alert( &quot;Opps, something went wrong: &quot; + err );&#125;);// Populate objectStore with test datadb.employees.add(&#123; name: &quot;John Dow&quot;, email: &quot;john@company.com&quot; &#125;);db.employees.add(&#123; name: &quot;Don Dow&quot;, email: &quot;don@company.com&quot; &#125;);// Find an employee by emaildb.employees .where( &quot;email&quot; ) .equals( &quot;don@company.com&quot; ) .each(function( employee )&#123; console.log( &quot;Employee matching `don@company.com` is `&quot; + employee.name + &quot;`&quot; ); &#125;); 파일 시스템 API 예제 접기/펼치기 버튼 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * FileSystem API usage example */window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem; /** * Read file from a given FileSystem * @param &#123;DOMFileSystem&#125; fs * @param &#123;String&#125; file */var readFile = function( fs, file ) &#123; console.log( &quot;Reading file &quot; + file ); // Obtain FileEntry object fs.root.getFile( file, &#123;&#125;, function( fileEntry ) &#123; fileEntry.file(function( file )&#123; // Create FileReader var reader = new FileReader(); reader.onloadend = function() &#123; console.log( &quot;Fetched content: &quot;, this.result ); &#125;; // Read file reader.readAsText( file ); &#125;, console.error ); &#125;, console.error ); &#125;, /** * Save file into a given FileSystem and run onDone when ready * @param &#123;DOMFileSystem&#125; fs * @param &#123;String&#125; file * @param &#123;Function&#125; onDone */ saveFile = function( fs, file, onDone ) &#123; console.log( &quot;Writing file &quot; + file ); // Obtain FileEntry object fs.root.getFile( file, &#123; create: true &#125;, function( fileEntry ) &#123; // Create a FileWriter object for the FileEntry fileEntry.createWriter(function( fileWriter ) &#123; var blob; fileWriter.onwriteend = onDone; fileWriter.onerror = function(e) &#123; console.error( &quot;Writing error: &quot; + e.toString() ); &#125;; // Create a new Blob out of the text we want into the file. blob = new Blob([ &quot;Lorem Ipsum&quot; ], &#123; type: &quot;text/plain&quot; &#125;); // Write into the file fileWriter.write( blob ); &#125;, console.error ); &#125;, console.error ); &#125;, /** * Run when FileSystem initialized * @param &#123;DOMFileSystem&#125; fs */ onInitFs = function ( fs ) &#123; const FILENAME = &quot;log.txt&quot;; console.log( &quot;Opening file system: &quot; + fs.name ); saveFile( fs, FILENAME, function()&#123; readFile( fs, FILENAME ); &#125;); &#125;;window.requestFileSystem( window.TEMPORARY, 5*1024*1024 /*5MB*/, onInitFs, console.error ); 참고파일 참조 웹 워커 멀티스레드 예제서버 - 브라우저 간 통신 채널 예제웹소켓 예제비동기 자바스크립트(나중에) 자바스크립트 디자인 패턴NW.js, 폰갭 생략 디버깅참고파일 예제 코드 Download","tags":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/tags/Book/"}],"categories":[{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/categories/Book/"}]},{"title":"Git Commit 메세지 분류","date":"2019-07-21T08:35:12.000Z","path":"wiki/Git-Commit/","text":"Git Commit 메세지 분류 Updated Time: 2019-07-21 17:35:12 Commit type Emoji 최초 커밋 🎉 :tada: 기능 추가 🆕 :new: 기능 버전업 🆙 :up: 버스 픽스 🐛 :bug: 문서화 📝 :memo: 작업 완료 ✅ :white_check_mark: 디자인 수정 🎨 :art: 코드개선 🔨 : :hammer: 파일/코드 제거 🔥 :fire: 작업 중 🚧 :construction: 모듈 제거 ➖ :heavy_minus_sign: 모듈 추가 ➕ :heavy_plus_sign: 파일 수정 🔧 :wrench: 패키지 파일 수정 📦 :package: Merged 🔀 :twisted_rightwards_arrows: Trash Code 💩 :hankey: Other Be creative","tags":[{"name":"Git","slug":"Git","permalink":"https://taeuk-gang.github.io/tags/Git/"}],"categories":[{"name":"Git","slug":"Git","permalink":"https://taeuk-gang.github.io/categories/Git/"}]},{"title":"귀여운 펭귄","date":"2019-07-20T17:04:47.000Z","path":"wiki/케로 베로니 이모티콘/","text":"귀여운 펭귄","tags":[{"name":"Life","slug":"Life","permalink":"https://taeuk-gang.github.io/tags/Life/"}],"categories":[{"name":"Life","slug":"Life","permalink":"https://taeuk-gang.github.io/categories/Life/"}]},{"title":"Init Blog","date":"2019-07-19T03:39:05.000Z","path":"wiki/Blog-Init/","text":"블로그 시작 개인 코드 저장소","tags":[{"name":"My Log","slug":"My-Log","permalink":"https://taeuk-gang.github.io/tags/My-Log/"}],"categories":[{"name":"My Log","slug":"My-Log","permalink":"https://taeuk-gang.github.io/categories/My-Log/"}]}],"categories":[{"name":"아키텍처","slug":"아키텍처","permalink":"https://taeuk-gang.github.io/categories/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"name":"HTTP 완벽 가이드","slug":"HTTP-완벽-가이드","permalink":"https://taeuk-gang.github.io/categories/HTTP-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/"},{"name":"Helm","slug":"Kubernetes/Helm","permalink":"https://taeuk-gang.github.io/categories/Kubernetes/Helm/"},{"name":"TIL","slug":"TIL","permalink":"https://taeuk-gang.github.io/categories/TIL/"},{"name":"2021","slug":"TIL/2021","permalink":"https://taeuk-gang.github.io/categories/TIL/2021/"},{"name":"10","slug":"TIL/2021/10","permalink":"https://taeuk-gang.github.io/categories/TIL/2021/10/"},{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/categories/Typescript/"},{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/categories/Projects/"},{"name":"Daily-Commit App","slug":"Projects/Daily-Commit-App","permalink":"https://taeuk-gang.github.io/categories/Projects/Daily-Commit-App/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/categories/Vue-js/"},{"name":"즐겨찾기","slug":"즐겨찾기","permalink":"https://taeuk-gang.github.io/categories/%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/categories/Javascript/"},{"name":"Auth","slug":"Auth","permalink":"https://taeuk-gang.github.io/categories/Auth/"},{"name":"Login","slug":"Auth/Login","permalink":"https://taeuk-gang.github.io/categories/Auth/Login/"},{"name":"문서화","slug":"문서화","permalink":"https://taeuk-gang.github.io/categories/%EB%AC%B8%EC%84%9C%ED%99%94/"},{"name":"Vue","slug":"Vue","permalink":"https://taeuk-gang.github.io/categories/Vue/"},{"name":"Vuex","slug":"Vue/Vuex","permalink":"https://taeuk-gang.github.io/categories/Vue/Vuex/"},{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/categories/Server/"},{"name":"Vscode","slug":"Server/Vscode","permalink":"https://taeuk-gang.github.io/categories/Server/Vscode/"},{"name":"mac-tour","slug":"Projects/mac-tour","permalink":"https://taeuk-gang.github.io/categories/Projects/mac-tour/"},{"name":"Issue","slug":"Issue","permalink":"https://taeuk-gang.github.io/categories/Issue/"},{"name":"Git","slug":"Git","permalink":"https://taeuk-gang.github.io/categories/Git/"},{"name":"open-tube","slug":"Projects/open-tube","permalink":"https://taeuk-gang.github.io/categories/Projects/open-tube/"},{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/categories/Book/"},{"name":"Kubernetes","slug":"Server/Kubernetes","permalink":"https://taeuk-gang.github.io/categories/Server/Kubernetes/"},{"name":"Cloud","slug":"Server/Cloud","permalink":"https://taeuk-gang.github.io/categories/Server/Cloud/"},{"name":"HTML","slug":"HTML","permalink":"https://taeuk-gang.github.io/categories/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/categories/CSS/"},{"name":"One-Page","slug":"Projects/One-Page","permalink":"https://taeuk-gang.github.io/categories/Projects/One-Page/"},{"name":"Life","slug":"Life","permalink":"https://taeuk-gang.github.io/categories/Life/"},{"name":"My Log","slug":"My-Log","permalink":"https://taeuk-gang.github.io/categories/My-Log/"}],"tags":[{"name":"아키텍처","slug":"아키텍처","permalink":"https://taeuk-gang.github.io/tags/%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/"},{"name":"HTTP 완벽 가이드","slug":"HTTP-완벽-가이드","permalink":"https://taeuk-gang.github.io/tags/HTTP-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://taeuk-gang.github.io/tags/Kubernetes/"},{"name":"Helm","slug":"Helm","permalink":"https://taeuk-gang.github.io/tags/Helm/"},{"name":"TIL","slug":"TIL","permalink":"https://taeuk-gang.github.io/tags/TIL/"},{"name":"Typescript","slug":"Typescript","permalink":"https://taeuk-gang.github.io/tags/Typescript/"},{"name":"Projects","slug":"Projects","permalink":"https://taeuk-gang.github.io/tags/Projects/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://taeuk-gang.github.io/tags/Vue-js/"},{"name":"즐겨찾기","slug":"즐겨찾기","permalink":"https://taeuk-gang.github.io/tags/%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0/"},{"name":"Javascript","slug":"Javascript","permalink":"https://taeuk-gang.github.io/tags/Javascript/"},{"name":"Optimize","slug":"Optimize","permalink":"https://taeuk-gang.github.io/tags/Optimize/"},{"name":"Keycloak","slug":"Keycloak","permalink":"https://taeuk-gang.github.io/tags/Keycloak/"},{"name":"Auth","slug":"Auth","permalink":"https://taeuk-gang.github.io/tags/Auth/"},{"name":"문서화","slug":"문서화","permalink":"https://taeuk-gang.github.io/tags/%EB%AC%B8%EC%84%9C%ED%99%94/"},{"name":"Typora","slug":"Typora","permalink":"https://taeuk-gang.github.io/tags/Typora/"},{"name":"Vue","slug":"Vue","permalink":"https://taeuk-gang.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"https://taeuk-gang.github.io/tags/Vuex/"},{"name":"SSH","slug":"SSH","permalink":"https://taeuk-gang.github.io/tags/SSH/"},{"name":"Server","slug":"Server","permalink":"https://taeuk-gang.github.io/tags/Server/"},{"name":"Vscode","slug":"Vscode","permalink":"https://taeuk-gang.github.io/tags/Vscode/"},{"name":"Book","slug":"Book","permalink":"https://taeuk-gang.github.io/tags/Book/"},{"name":"ServiceWorker","slug":"ServiceWorker","permalink":"https://taeuk-gang.github.io/tags/ServiceWorker/"},{"name":"lit-element","slug":"lit-element","permalink":"https://taeuk-gang.github.io/tags/lit-element/"},{"name":"Project","slug":"Project","permalink":"https://taeuk-gang.github.io/tags/Project/"},{"name":"Cordova","slug":"Cordova","permalink":"https://taeuk-gang.github.io/tags/Cordova/"},{"name":"Issue","slug":"Issue","permalink":"https://taeuk-gang.github.io/tags/Issue/"},{"name":"Git","slug":"Git","permalink":"https://taeuk-gang.github.io/tags/Git/"},{"name":"open-tube","slug":"open-tube","permalink":"https://taeuk-gang.github.io/tags/open-tube/"},{"name":"Cloud","slug":"Cloud","permalink":"https://taeuk-gang.github.io/tags/Cloud/"},{"name":"Naver-Cloud","slug":"Naver-Cloud","permalink":"https://taeuk-gang.github.io/tags/Naver-Cloud/"},{"name":"HTML","slug":"HTML","permalink":"https://taeuk-gang.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://taeuk-gang.github.io/tags/CSS/"},{"name":"naver-d2","slug":"naver-d2","permalink":"https://taeuk-gang.github.io/tags/naver-d2/"},{"name":"One-Page","slug":"One-Page","permalink":"https://taeuk-gang.github.io/tags/One-Page/"},{"name":"Life","slug":"Life","permalink":"https://taeuk-gang.github.io/tags/Life/"},{"name":"My Log","slug":"My-Log","permalink":"https://taeuk-gang.github.io/tags/My-Log/"}]}